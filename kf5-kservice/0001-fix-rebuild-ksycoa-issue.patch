diff --git a/autotests/CMakeLists.txt b/autotests/CMakeLists.txt
index c749173..18bb04e 100644
--- a/autotests/CMakeLists.txt
+++ b/autotests/CMakeLists.txt
@@ -14,6 +14,7 @@ macro(KSERVICE_UNIT_TESTS)
 endmacro(KSERVICE_UNIT_TESTS)
 
 kservice_unit_tests(
+ ksycocatest
  kautostarttest
  ksycocadicttest
  ksycocathreadtest
@@ -41,7 +42,7 @@ kcoreaddons_desktop_to_json(fakeplugin ${CMAKE_CURRENT_BINARY_DIR}/fakeplugin_js
 
 ######### kmimeassociationstest ########
 
-set(kmimeassociationstest_SRCS kmimeassociationstest.cpp ../src/kbuildsycoca/kmimeassociations.cpp)
+set(kmimeassociationstest_SRCS kmimeassociationstest.cpp ../src/sycoca/kmimeassociations.cpp)
 
 ecm_add_test(${kmimeassociationstest_SRCS} TEST_NAME kmimeassociationstest
              LINK_LIBRARIES KF5::Service Qt5::Test)
diff --git a/autotests/kmimeassociationstest.cpp b/autotests/kmimeassociationstest.cpp
index 075ab8c..5550938 100644
--- a/autotests/kmimeassociationstest.cpp
+++ b/autotests/kmimeassociationstest.cpp
@@ -27,7 +27,7 @@
 #include <kservicefactory_p.h>
 #include <qtemporaryfile.h>
 #include <qtest.h>
-#include "kmimeassociations.h"
+#include "kmimeassociations_p.h"
 #include <ksycoca.h>
 
 // We need a factory that returns the same KService::Ptr every time it's asked for a given service.
@@ -112,8 +112,6 @@ private Q_SLOTS:
         QStandardPaths::enableTestMode(true);
         qputenv("XDG_CURRENT_DESKTOP", "KDE");
 
-        extern KSERVICE_EXPORT bool kservice_require_kded;
-        kservice_require_kded = false;
 
         m_localConfig = QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation) + QLatin1Char('/');
         QDir(m_localConfig).removeRecursively();
@@ -157,7 +155,7 @@ private Q_SLOTS:
         fakeHtmlApplicationPrefixed = m_localApps + "fakepfx/fakehtmlapplicationpfx.desktop";
         writeAppDesktopFile(fakeHtmlApplicationPrefixed, QStringList() << "text/html");
 
-        // Update ksycoca in ~/.kde-unit-test after creating the above
+        // Update ksycoca in ~/.qttest after creating the above
         runKBuildSycoca();
 
         // Create factory on the heap and don't delete it. This must happen after
diff --git a/autotests/kservicetest.cpp b/autotests/kservicetest.cpp
index c41920e..ffd963d 100644
--- a/autotests/kservicetest.cpp
+++ b/autotests/kservicetest.cpp
@@ -59,13 +59,11 @@ static void eraseProfiles()
     }
 }
 
-extern KSERVICE_EXPORT bool kservice_require_kded;
 
 void KServiceTest::initTestCase()
 {
     QStandardPaths::enableTestMode(true);
 
-    kservice_require_kded = false;
 
     // A non-C locale is necessary for some tests.
     // This locale must have the following properties:
@@ -86,12 +84,20 @@ void KServiceTest::initTestCase()
 
     // Create some fake services for the tests below, and ensure they are in ksycoca.
 
+    bool mustUpdateKSycoca = false;
+
     // fakeservice: deleted and recreated by testKSycocaUpdate, don't use in other tests
-    bool mustUpdateKSycoca = !KService::serviceByDesktopPath("fakeservice.desktop");
-    const QString fakeService = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/") + "fakeservice.desktop";
+    const QString fakeServiceDeleteMe = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/fakeservice_deleteme.desktop");
+    if (!QFile::exists(fakeServiceDeleteMe)) {
+        mustUpdateKSycoca = true;
+        createFakeService("fakeservice_deleteme.desktop", QString());
+    }
+
+    // fakeservice: a plugin that implements FakePluginType
+    const QString fakeService = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/fakeservice.desktop");
     if (!QFile::exists(fakeService)) {
         mustUpdateKSycoca = true;
-        createFakeService();
+        createFakeService("fakeservice.desktop", "FakePluginType");
     }
 
     // fakepart: a readwrite part, like katepart
@@ -237,7 +243,7 @@ void KServiceTest::initTestCase()
     }
 
     if (mustUpdateKSycoca) {
-        // Update ksycoca in ~/.kde-unit-test after creating the above
+        // Update ksycoca in ~/.qttest after creating the above
         runKBuildSycoca(true);
     }
     QVERIFY(KServiceType::serviceType("FakePluginType"));
@@ -247,6 +253,7 @@ void KServiceTest::initTestCase()
 
 void KServiceTest::runKBuildSycoca(bool noincremental)
 {
+    QSignalSpy spy(KSycoca::self(), SIGNAL(databaseChanged(QStringList)));
     QProcess proc;
     const QString kbuildsycoca = QStandardPaths::findExecutable(KBUILDSYCOCA_EXENAME);
     QVERIFY(!kbuildsycoca.isEmpty());
@@ -255,13 +262,15 @@ void KServiceTest::runKBuildSycoca(bool noincremental)
     if (noincremental) {
         args << "--noincremental";
     }
-    //proc.setProcessChannelMode(QProcess::MergedChannels); // silence kbuildsycoca output
+    proc.setProcessChannelMode(QProcess::MergedChannels); // silence kbuildsycoca output
+    //proc.setProcessChannelMode(QProcess::ForwardedChannels); // use this to see the kbuildsycoca output
     proc.start(kbuildsycoca, args);
     proc.waitForFinished();
-    qDebug() << "waiting for signal";
-    QSignalSpy spy(KSycoca::self(), SIGNAL(databaseChanged(QStringList)));
-    QVERIFY(spy.wait(10000));
-    qDebug() << "got signal";
+    if (spy.isEmpty()) {
+        qDebug() << "waiting for signal";
+        QVERIFY(spy.wait(10000));
+        qDebug() << "got signal";
+    }
 }
 
 void KServiceTest::cleanupTestCase()
@@ -676,55 +685,42 @@ void KServiceTest::testServiceGroups()
     // No unit test here yet, but at least this can be valgrinded for errors.
 }
 
-void KServiceTest::testKSycocaUpdate()
+void KServiceTest::testDeletingService()
 {
-    KService::Ptr fakeService = KService::serviceByDesktopPath("fakeservice.desktop");
+    const QString serviceName = "fakeservice_deleteme.desktop";
+    KService::Ptr fakeService = KService::serviceByDesktopPath(serviceName);
     QVERIFY(fakeService); // see initTestCase; it should be found.
 
     // Test deleting a service
-    const QString servPath = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/fakeservice.desktop");
+    const QString servPath = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/") + serviceName;
     QVERIFY(QFile::exists(servPath));
-    QSignalSpy spy(KSycoca::self(), SIGNAL(databaseChanged(QStringList)));
-    QVERIFY(spy.isValid());
     QFile::remove(servPath);
     runKBuildSycoca();
-    while (spy.isEmpty()) {
-        QTest::qWait(50);
-    }
-    QVERIFY(!spy.isEmpty());
-    QVERIFY(!KService::serviceByDesktopPath("fakeservice.desktop")); // not in ksycoca anymore
-    QVERIFY(spy[0][0].toStringList().contains("services"));
-    qDebug() << "got signal ok";
+    QVERIFY(!KService::serviceByDesktopPath(serviceName)); // not in ksycoca anymore
 
-    spy.clear();
     QVERIFY(fakeService); // the whole point of refcounting is that this KService instance is still valid.
     QVERIFY(!QFile::exists(servPath));
 
     // Recreate it, for future tests
-    createFakeService();
+    createFakeService(serviceName, QString());
     QVERIFY(QFile::exists(servPath));
     qDebug() << "executing kbuildsycoca (2)";
     runKBuildSycoca();
-    while (spy.isEmpty()) {
-        QTest::qWait(50);
-    }
-    qDebug() << "got signal ok (2)";
-    QVERIFY(spy[0][0].toStringList().contains("services"));
     if (QThread::currentThread() != QCoreApplication::instance()->thread()) {
         m_sycocaUpdateDone.ref();
     }
 }
 
-void KServiceTest::createFakeService()
+void KServiceTest::createFakeService(const QString &filename, const QString& serviceType)
 {
-    const QString fakeService = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/fakeservice.desktop");
+    const QString fakeService = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/kservices5/") + filename;
     KDesktopFile file(fakeService);
     KConfigGroup group = file.desktopGroup();
     group.writeEntry("Name", "FakePlugin");
     group.writeEntry("Type", "Service");
     group.writeEntry("X-KDE-Library", "fakeservice");
     group.writeEntry("X-KDE-Version", "4.56");
-    group.writeEntry("ServiceTypes", "FakePluginType");
+    group.writeEntry("ServiceTypes", serviceType);
     group.writeEntry("MimeType", "text/plain;");
 }
 
@@ -757,11 +753,10 @@ void KServiceTest::testThreads()
     QFutureSynchronizer<void> sync;
     sync.addFuture(QtConcurrent::run(this, &KServiceTest::testAllServices));
     sync.addFuture(QtConcurrent::run(this, &KServiceTest::testHasServiceType1));
-    sync.addFuture(QtConcurrent::run(this, &KServiceTest::testKSycocaUpdate));
+    sync.addFuture(QtConcurrent::run(this, &KServiceTest::testDeletingService));
     sync.addFuture(QtConcurrent::run(this, &KServiceTest::testTraderConstraints));
-    while (m_sycocaUpdateDone.load() == 0) { // not using a bool, just to silence helgrind
-        QTest::qWait(100);    // process D-Bus events!
-    }
+    // process events (DBus, inotify...), until we get all expected signals
+    QTRY_COMPARE_WITH_TIMEOUT(m_sycocaUpdateDone.load(), 1, 15000); // not using a bool, just to silence helgrind
     qDebug() << "Joining all threads";
     sync.waitForFinished();
 }
diff --git a/autotests/kservicetest.h b/autotests/kservicetest.h
index 9c92e23..62dcbae 100644
--- a/autotests/kservicetest.h
+++ b/autotests/kservicetest.h
@@ -45,7 +45,7 @@ private Q_SLOTS:
     void testByStorageId();
     void testActionsAndDataStream();
     void testServiceGroups();
-    void testKSycocaUpdate();
+    void testDeletingService();
     void testReaderThreads();
     void testThreads();
     void testOperatorKPluginName();
@@ -54,7 +54,7 @@ private Q_SLOTS:
     void testEntryPathToName();
 
 private:
-    void createFakeService();
+    void createFakeService(const QString &filenameSuffix, const QString &serviceType);
     void runKBuildSycoca(bool noincremental = false);
 
     QString m_firstOffer;
diff --git a/autotests/ksycocadicttest.cpp b/autotests/ksycocadicttest.cpp
index beea586..52ce426 100644
--- a/autotests/ksycocadicttest.cpp
+++ b/autotests/ksycocadicttest.cpp
@@ -26,7 +26,6 @@
 #include <kconfiggroup.h>
 #include <ksycocadict_p.h>
 
-extern KSERVICE_EXPORT bool kservice_require_kded;
 
 class KSycocaDictTest : public QObject
 {
@@ -36,10 +35,6 @@ private Q_SLOTS:
     void initTestCase()
     {
         QStandardPaths::enableTestMode(true);
-        kservice_require_kded = false;
-
-        // we don't need the services dir -> ensure there isn't one, so we can check allResourceDirs below.
-        QDir(servicesDir()).removeRecursively();
 
         // dicttestplugintype: a servicetype
         const QString dictTestPluginType = serviceTypesDir() + "/dicttestplugintype.desktop";
@@ -54,11 +49,9 @@ private Q_SLOTS:
         }
         runKBuildSycoca();
     }
-    void testAllResourceDirs();
     void testStandardDict();
 
 private:
-    QString servicesDir() { return QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + "/kservices5"; }
     QString serviceTypesDir() { return QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + "/kservicetypes5"; }
 
     void add(KSycocaDict &dict, const QString &key, const QString &name)
@@ -94,14 +87,6 @@ void KSycocaDictTest::runKBuildSycoca()
 
 }
 
-void KSycocaDictTest::testAllResourceDirs()
-{
-    // Dirs that exist and dirs that don't exist, should both in allResourceDirs().
-    const QStringList dirs = KSycoca::self()->allResourceDirs();
-    QVERIFY2(dirs.contains(servicesDir()), qPrintable(dirs.join(',')));
-    QVERIFY2(dirs.contains(serviceTypesDir()), qPrintable(dirs.join(',')));
-}
-
 // Standard use of KSycocaDict: mapping entry name to entry
 void KSycocaDictTest::testStandardDict()
 {
diff --git a/autotests/ksycocatest.cpp b/autotests/ksycocatest.cpp
new file mode 100644
index 0000000..7c2d91e
--- /dev/null
+++ b/autotests/ksycocatest.cpp
@@ -0,0 +1,132 @@
+/* This file is part of the KDE project
+   Copyright (C) 2015 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include <ksycoca.h>
+#include <QTemporaryDir>
+#include <QTest>
+#include <QDebug>
+#include <kservicetype.h>
+#include <kdesktopfile.h>
+#include <kconfiggroup.h>
+#include <QSignalSpy>
+#include <QProcess>
+#include <kservice.h>
+
+class KSycocaTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase()
+    {
+        QStandardPaths::enableTestMode(true);
+
+        QVERIFY(m_tempDir.isValid());
+
+        // we don't need the services dir -> ensure there isn't one, so we can check allResourceDirs below.
+        QDir(servicesDir()).removeRecursively();
+
+        runKBuildSycoca(QProcessEnvironment::systemEnvironment());
+    }
+    void testAllResourceDirs();
+    void testOtherAppDir();
+
+private:
+    QString servicesDir() { return QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + "/kservices5"; }
+    QString serviceTypesDir() { return QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + "/kservicetypes5"; }
+
+    static void runKBuildSycoca(const QProcessEnvironment &environment);
+
+    QTemporaryDir m_tempDir;
+};
+
+QTEST_MAIN(KSycocaTest)
+
+void KSycocaTest::runKBuildSycoca(const QProcessEnvironment &environment)
+{
+    QSignalSpy spy(KSycoca::self(), SIGNAL(databaseChanged(QStringList)));
+    QProcess proc;
+    const QString kbuildsycoca = QStandardPaths::findExecutable(KBUILDSYCOCA_EXENAME);
+    QVERIFY(!kbuildsycoca.isEmpty());
+    QStringList args;
+    args << "--testmode";
+    proc.setProcessChannelMode(QProcess::MergedChannels); // silence kbuildsycoca output
+    proc.start(kbuildsycoca, args);
+    proc.setProcessEnvironment(environment);
+
+    proc.waitForFinished();
+    QCOMPARE(proc.exitStatus(), QProcess::NormalExit);
+
+    qDebug() << "waiting for signal";
+    QVERIFY(spy.wait(10000));
+    qDebug() << "got signal";
+}
+
+void KSycocaTest::testAllResourceDirs()
+{
+    // Dirs that exist and dirs that don't exist, should both in allResourceDirs().
+    const QStringList dirs = KSycoca::self()->allResourceDirs();
+    QVERIFY2(dirs.contains(servicesDir()), qPrintable(dirs.join(',')));
+    QVERIFY2(dirs.contains(serviceTypesDir()), qPrintable(dirs.join(',')));
+}
+
+// taken from tst_qstandardpaths
+#if defined(Q_OS_UNIX) && !defined(Q_OS_MAC) && !defined(Q_OS_BLACKBERRY) && !defined(Q_OS_ANDROID)
+#define Q_XDG_PLATFORM
+#endif
+
+void KSycocaTest::testOtherAppDir()
+{
+#ifndef Q_XDG_PLATFORM
+    QSKIP("This test requires XDG_DATA_DIRS");
+#endif
+
+    const QString dataDir = m_tempDir.path();
+    qputenv("XDG_DATA_DIRS", QFile::encodeName(dataDir));
+    QCOMPARE(dataDir, QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).last());
+    QVERIFY(!KService::serviceByDesktopPath("test_app_other.desktop"));
+
+    const QString appDir = dataDir + "/applications";
+
+    // test_app_other: live in a different application directory
+    const QString testAppOther = appDir + "/test_app_other.desktop";
+    KDesktopFile file(testAppOther);
+    KConfigGroup group = file.desktopGroup();
+    group.writeEntry("Type", "Application");
+    group.writeEntry("Exec", "kded5");
+    group.writeEntry("Name", "Test App Other");
+    qDebug() << "Just created" << testAppOther;
+    file.sync();
+
+    QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
+    env.insert("XDG_DATA_DIRS", dataDir);
+    runKBuildSycoca(env);
+
+#if 0 // for debugging
+    const KService::List lst = KService::allServices();
+    QVERIFY(!lst.isEmpty());
+    Q_FOREACH (const KService::Ptr &serv, lst) {
+        qDebug() << serv->entryPath() << serv->storageId() /*<< serv->desktopEntryName()*/;
+    }
+#endif
+
+    QVERIFY(KService::serviceByStorageId("test_app_other.desktop"));
+}
+
+#include "ksycocatest.moc"
diff --git a/autotests/ksycocathreadtest.cpp b/autotests/ksycocathreadtest.cpp
index 4c4ec6d..29a096f 100644
--- a/autotests/ksycocathreadtest.cpp
+++ b/autotests/ksycocathreadtest.cpp
@@ -201,7 +201,6 @@ public:
     }
 };
 
-extern KSERVICE_EXPORT bool kservice_require_kded;
 
 // This code runs in the main thread
 class KSycocaThreadTest : public QObject
@@ -261,7 +260,6 @@ static void runKBuildSycoca()
 void KSycocaThreadTest::initTestCase()
 {
     QStandardPaths::enableTestMode(true);
-    kservice_require_kded = false;
 
     // This service is always there. Used in the trader queries from the thread.
     const QString fakeTextPlugin = fakeTextPluginDesktopFile();
diff --git a/docs/kbuildsycoca5/man-kbuildsycoca5.8.docbook b/docs/kbuildsycoca5/man-kbuildsycoca5.8.docbook
index 6e1800e..3419e42 100644
--- a/docs/kbuildsycoca5/man-kbuildsycoca5.8.docbook
+++ b/docs/kbuildsycoca5/man-kbuildsycoca5.8.docbook
@@ -69,9 +69,7 @@ requested of it.
 
 <para>
 Users do not normally need to run this application directly; KService will run
-it if necessary, and if KDED is installed and running it will run
-<command>kbuildsyscoca5</command> whenever any of the files whose data is cached
-are changed.
+it if necessary, when any of the files whose data is cached are changed.
 </para>
 </refsect1>
 
@@ -82,13 +80,6 @@ are changed.
 <variablelist>
 
 <varlistentry>
-<term><option>--checkstamps</option></term>
-<listitem>
-<para>Checks the file timestamps of the cache and the resource directories containing the data to be cached, and only updates the database if any of the resource directories have been modified more recently than the cache.  Ignored if <option>--nocheckfiles</option> or <option>--noincremental</option> is set.</para>
-</listitem>
-</varlistentry>
-
-<varlistentry>
 <term><option>--global</option></term>
 <listitem>
 <para>Ignores any user-set files (in <varname>XDG_DATA_HOME</varname>).  This is currently only supported on Unix systems.</para>
@@ -96,13 +87,6 @@ are changed.
 </varlistentry>
 
 <varlistentry>
-<term><option>--nocheckfiles</option></term>
-<listitem>
-<para>Does not rebuild the cache unless something other than a change in the resource files requires it (such as the format of the cache changing, or <varname>XDG_DATA_DIRS</varname> being changed on a Unix system). Ignored if <option>--global</option> is set.</para>
-</listitem>
-</varlistentry>
-
-<varlistentry>
 <term><option>--noincremental</option></term>
 <listitem>
 <para>Rather than using the existing cache and only updating the information that has changed or been added, start with an empty cache. Ignored if <option>--global</option> is set.</para>
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index a82d260..5ea5b00 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -32,6 +32,14 @@ set(kservice_SRCS
    sycoca/ksycocautils.cpp
    sycoca/kmemfile.cpp
    sycoca/sycocadebug.cpp
+   sycoca/kbuildmimetypefactory.cpp
+   sycoca/kbuildservicetypefactory.cpp
+   sycoca/kbuildservicefactory.cpp
+   sycoca/kbuildservicegroupfactory.cpp
+   sycoca/kbuildsycoca.cpp
+   sycoca/kctimefactory.cpp
+   sycoca/kmimeassociations.cpp
+   sycoca/vfolder_menu.cpp
    plugin/kplugintrader.cpp
    plugin/kdbusservicestarter.cpp
 )
@@ -76,6 +84,7 @@ target_link_libraries(KF5Service
   PRIVATE
     KF5::I18n
     KF5::DBusAddons   # KDEInitInterface
+    Qt5::Xml          # (for vfolder menu) QDomDocument
 )
 
 set_target_properties(KF5Service PROPERTIES VERSION ${KSERVICE_VERSION_STRING}
@@ -125,6 +134,12 @@ install(FILES
    DESTINATION ${KDE_INSTALL_KSERVICETYPES5DIR}
 )
 
+if (WIN32)
+install( FILES applications.menu  DESTINATION  ${KDE_INSTALL_DATAROOTDIR}/xdg/menus )
+else ()
+install( FILES applications.menu  DESTINATION  ${KDE_INSTALL_SYSCONFDIR}/xdg/menus )
+endif ()
+
 install(TARGETS KF5Service EXPORT KF5ServiceTargets ${KF5_INSTALL_TARGETS_DEFAULT_ARGS})
 
 install(FILES
diff --git a/src/applications.menu b/src/applications.menu
new file mode 100644
index 0000000..f2d5253
--- /dev/null
+++ b/src/applications.menu
@@ -0,0 +1,441 @@
+ <!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 1.0//EN"
+  "http://www.freedesktop.org/standards/menu-spec/1.0/menu.dtd">
+
+<Menu>
+	<Name>Applications</Name>
+	<Directory>kde-main.directory</Directory>
+	<!-- Search the default locations -->
+	<KDELegacyDirs/>
+	<DefaultAppDirs/>
+	<DefaultDirectoryDirs/>
+	<DefaultLayout>
+		<Merge type="menus"/>
+		<Merge type="files"/>
+		<Separator/>
+		<Menuname>More</Menuname>
+	</DefaultLayout>
+	<Layout>
+		<Merge type="menus"/>
+		<Menuname>Applications</Menuname>
+		<Merge type="files"/>
+	</Layout>
+
+	<Menu>
+		<Name>Applications</Name>
+		<Directory>kf5-unknown.directory</Directory>
+		<OnlyUnallocated/>
+		<Include>
+			<Not>
+				<!-- Don't list non-KDE core applications -->
+				<And>
+					<Category>Core</Category>
+					<Not><Category>KDE</Category></Not>
+				</And>
+				<!-- Don't list SUSE's YaST in here -->
+				<Category>X-SuSE-YaST</Category>
+				<Category>X-KDE-settings-hardware</Category>
+				<Category>X-KDE-settings-accessibility</Category>
+				<Category>X-KDE-settings-components</Category>
+				<Category>X-KDE-settings-desktop</Category>
+				<Category>X-KDE-settings-looknfeel</Category>
+				<Category>X-KDE-settings-network</Category>
+				<Category>X-KDE-settings-webbrowsing</Category>
+				<Category>X-KDE-settings-peripherals</Category>
+				<Category>X-KDE-settings-hardware</Category>
+				<Category>X-KDE-settings-power</Category>
+				<Category>X-KDE-settings-security</Category>
+				<Category>X-KDE-settings-sound</Category>
+				<Category>X-KDE-settings-system</Category>
+				<Category>X-KDE-information</Category>
+				<Filename>kde-kcm_knetworkconfmodule_ss.desktop</Filename>
+				<Filename>kde-medianotifications.desktop</Filename>
+				<Filename>kde-audioencoding.desktop</Filename>
+			</Not>
+		</Include>
+	</Menu>
+	<Menu>
+		<Name>Development</Name>
+		<Directory>kf5-development.directory</Directory>
+		<Menu>
+			<Name>X-KDE-KDevelopIDE</Name>
+			<Directory>kf5-development-kdevelop.directory</Directory>
+			<Include>
+				<And>
+					<Category>Development</Category>
+					<Category>X-KDE-KDevelopIDE</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Translation</Name>
+			<Directory>kf5-development-translation.directory</Directory>
+			<Include>
+				<And>
+					<Category>Development</Category>
+					<Category>Translation</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Web Development</Name>
+			<Directory>kf5-development-webdevelopment.directory</Directory>
+			<Include>
+				<And>
+					<Category>Development</Category>
+					<Category>WebDevelopment</Category>
+				</And>
+			</Include>
+		</Menu>
+                <Include>
+					<And>
+                        <Category>Development</Category>
+                        <Not><Category>X-KDE-KDevelopIDE</Category></Not>
+                        <Not><Category>Translation</Category></Not>
+                        <Not><Category>WebDevelopment</Category></Not>
+					</And>
+                </Include>
+        </Menu>
+	<Menu>
+		<Name>Science</Name>
+		<Directory>kf5-science.directory</Directory>
+		<Include>
+			<And><!-- Include /any/ Science app which is not an Education app -->
+				<Or>
+					<Category>Astronomy</Category>
+					<Category>Biology</Category>
+					<Category>Chemistry</Category>
+					<Category>Geology</Category>
+					<Category>MedicalSoftware</Category>
+					<Category>Physics</Category>
+					<Category>Math</Category>
+					<Category>Science</Category>
+				</Or>
+				<Not><Category>Education</Category></Not>
+			</And>
+		</Include>
+	</Menu>
+	<Menu>
+		<Name>Education</Name>
+		<Directory>kf5-education.directory</Directory>
+		<Menu>
+			<Name>Languages</Name>
+			<Directory>kf5-edu-languages.directory</Directory>
+			<Include>
+				<And>
+					<Category>Education</Category>
+					<Or>
+						<Category>Languages</Category>
+						<Category>X-KDE-Edu-Language</Category>
+					</Or>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Mathematics</Name>
+			<Directory>kf5-edu-mathematics.directory</Directory>
+			<Include>
+				<And>
+					<Category>Education</Category>
+					<Category>Math</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Miscellaneous</Name>
+			<Directory>kf5-edu-miscellaneous.directory</Directory>
+			<Include>
+				<And>
+					<Category>Education</Category>
+					<Not>
+						<Category>Languages</Category>
+						<Category>X-KDE-Edu-Language</Category>
+						<Category>Math</Category>
+						<Category>Science</Category>
+						<Category>Teaching</Category>
+						<Category>X-KDE-Edu-Teaching</Category>
+					</Not>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Science</Name>
+			<Directory>kf5-edu-science.directory</Directory>
+			<Include>
+				<And>
+					<Category>Education</Category>
+					<Category>Science</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Tools</Name>
+			<Directory>kf5-edu-tools.directory</Directory>
+			<Include>
+				<And>
+					<Category>Education</Category>
+					<Or>
+						<Category>Teaching</Category>
+						<Category>X-KDE-Edu-Teaching</Category>
+					</Or>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Games</Name>
+		<Directory>kf5-games.directory</Directory>
+		<Menu>
+			<Name>Arcade</Name>
+			<Directory>kf5-games-arcade.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Category>ArcadeGame</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Board</Name>
+			<Directory>kf5-games-board.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Category>BoardGame</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Card</Name>
+			<Directory>kf5-games-card.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Category>CardGame</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Kidsgames</Name>
+			<Directory>kf5-games-kids.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Or>
+						<Category>X-KDE-KidsGame</Category>
+						<Category>KidsGame</Category>
+					</Or>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>TacticStrategy</Name>
+			<Directory>kf5-games-strategy.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Category>StrategyGame</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>Logic</Name>
+			<Directory>kf5-games-logic.directory</Directory>
+			<Include>
+				<And>
+					<Category>Game</Category>
+					<Category>LogicGame</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Include>
+			<And>
+				<Category>Game</Category>
+				<Not>
+					<Category>ArcadeGame</Category>
+					<Category>BoardGame</Category>
+					<Category>CardGame</Category>
+					<Category>X-KDE-KidsGame</Category>
+					<Category>KidsGame</Category>
+					<Category>StrategyGame</Category>
+					<Category>LogicGame</Category>
+				</Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>Toys</Name>
+			<Directory>kf5-toys.directory</Directory>
+			<Include>
+				<Category>Amusement</Category>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Graphics</Name>
+		<Directory>kf5-graphics.directory</Directory>
+		<Include>
+			<And>
+				<Category>Graphics</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>Graphics</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Internet</Name>
+		<Directory>kf5-internet.directory</Directory>
+		<Include>
+			<And>
+				<Category>Network</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>Terminal</Name>
+			<Directory>kf5-internet-terminal.directory</Directory>
+		</Menu>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>Network</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Multimedia</Name>
+		<Directory>kf5-multimedia.directory</Directory>
+		<Include>
+			<And>
+				<Category>AudioVideo</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>AudioVideo</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Office</Name>
+		<Directory>kf5-office.directory</Directory>
+		<Layout>
+			<Merge type="menus"/>
+			<Filename>kde-koshell.desktop</Filename>
+			<Filename>kde-Kontact.desktop</Filename>
+			<Separator/>
+			<Filename>kde-kword.desktop</Filename>
+			<Filename>kde-kspread.desktop</Filename>
+			<Filename>kde-kpresenter.desktop</Filename>
+			<Merge type="files"/>
+			<Separator/>
+			<Menuname>More</Menuname>
+		</Layout>
+		<Include>
+			<And>
+				<Category>Office</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>Office</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Settingsmenu</Name>
+		<Directory>kf5-settingsmenu.directory</Directory>
+		<Include>
+			<Category>Settings</Category>
+		</Include>
+	</Menu>
+	<Menu>
+		<Name>System</Name>
+		<Directory>kf5-system.directory</Directory>
+		<Include>
+			<And>
+				<Category>System</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+		</Include>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>System</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+		<Menu>
+			<Name>ScreenSavers</Name>
+			<Directory>kf5-system-screensavers.directory</Directory>
+		</Menu>
+		<Menu>
+			<Name>Terminal</Name>
+			<Directory>kf5-system-terminal.directory</Directory>
+		</Menu>
+	</Menu>
+	<Menu>
+		<Name>Utilities</Name>
+		<Directory>kf5-utilities.directory</Directory>
+		<Include>
+			<And>
+				<Category>Utility</Category>
+				<Not><Category>X-KDE-More</Category></Not>
+			</And>
+			<Category>TextEditor</Category>
+			<Category>Accessibility</Category>
+			<Category>X-KDE-Utilities-Desktop</Category>
+			<Category>X-KDE-Utilities-File</Category>
+			<Category>X-KDE-Utilities-Peripherals</Category>
+			<Category>X-KDE-Utilities-PIM</Category>
+		</Include>
+		<Menu>
+			<Name>XUtilities</Name>
+			<Directory>kf5-utilities-xutils.directory</Directory>
+		</Menu>
+		<Menu>
+			<Name>More</Name>
+			<Directory>kf5-more.directory</Directory>
+			<Include>
+				<And>
+					<Category>Utility</Category>
+					<Category>X-KDE-More</Category>
+				</And>
+			</Include>
+		</Menu>
+	</Menu>
+	<Include>
+		<And>
+			<Category>KDE</Category>
+			<Category>Core</Category>
+		</And>
+	</Include>
+	<DefaultMergeDirs/>
+	<MergeFile>applications-kmenuedit.menu</MergeFile>
+</Menu>
diff --git a/src/kbuildsycoca/CMakeLists.txt b/src/kbuildsycoca/CMakeLists.txt
index 8240b0c..19bdc84 100644
--- a/src/kbuildsycoca/CMakeLists.txt
+++ b/src/kbuildsycoca/CMakeLists.txt
@@ -1,36 +1,20 @@
 include(ECMMarkNonGuiExecutable)
 
 set(kbuildsycoca_SRCS
-   kbuildsycoca.cpp
-   kbuildmimetypefactory.cpp
-   kmimeassociations.cpp
-   kbuildservicetypefactory.cpp
-   kbuildservicefactory.cpp
-   kbuildservicegroupfactory.cpp
-   kctimefactory.cpp
-   vfolder_menu.cpp
+   kbuildsycoca_main.cpp
    )
 
-# We need to add a '5' so that kde3/kde4 apps running kbuildsycoca don't run the kde4 one.
-add_executable( kbuildsycoca5 ${kbuildsycoca_SRCS})
+# We need to add a '5' so that kde3/kde4 apps running kbuildsycoca don't run this one.
+add_executable(kbuildsycoca5 ${kbuildsycoca_SRCS})
 
 # Mark it as non-gui so we won't create an app bundle on Mac OS X
 ecm_mark_nongui_executable(kbuildsycoca5)
 
 target_link_libraries(kbuildsycoca5
-   KF5::Service #KBuildMimeTypeFactory subclasses KMimeTypeFactory, KServiceGroupFactory and KService used as well
-   KF5::Crash  #set a crash handler for ksycoca binary
+   KF5::Service
+   KF5::Crash      # set a crash handler for the kbuildsycoca binary
    KF5::CoreAddons # KAboutData
    KF5::I18n
-   Qt5::Xml #vfolder menui QDomDocument and family
-   Qt5::DBus #kbuildsycoca uses QDBus to talk with interested applications
 )
 
 install(TARGETS kbuildsycoca5 ${KF5_INSTALL_TARGETS_DEFAULT_ARGS} )
-
-########### install files ###############
-if (WIN32)
-install( FILES applications.menu  DESTINATION  ${KDE_INSTALL_DATAROOTDIR}/xdg/menus )
-else ()
-install( FILES applications.menu  DESTINATION  ${KDE_INSTALL_SYSCONFDIR}/xdg/menus )
-endif ()
diff --git a/src/kbuildsycoca/applications.menu b/src/kbuildsycoca/applications.menu
deleted file mode 100644
index f2d5253..0000000
--- a/src/kbuildsycoca/applications.menu
+++ /dev/null
@@ -1,441 +0,0 @@
- <!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 1.0//EN"
-  "http://www.freedesktop.org/standards/menu-spec/1.0/menu.dtd">
-
-<Menu>
-	<Name>Applications</Name>
-	<Directory>kde-main.directory</Directory>
-	<!-- Search the default locations -->
-	<KDELegacyDirs/>
-	<DefaultAppDirs/>
-	<DefaultDirectoryDirs/>
-	<DefaultLayout>
-		<Merge type="menus"/>
-		<Merge type="files"/>
-		<Separator/>
-		<Menuname>More</Menuname>
-	</DefaultLayout>
-	<Layout>
-		<Merge type="menus"/>
-		<Menuname>Applications</Menuname>
-		<Merge type="files"/>
-	</Layout>
-
-	<Menu>
-		<Name>Applications</Name>
-		<Directory>kf5-unknown.directory</Directory>
-		<OnlyUnallocated/>
-		<Include>
-			<Not>
-				<!-- Don't list non-KDE core applications -->
-				<And>
-					<Category>Core</Category>
-					<Not><Category>KDE</Category></Not>
-				</And>
-				<!-- Don't list SUSE's YaST in here -->
-				<Category>X-SuSE-YaST</Category>
-				<Category>X-KDE-settings-hardware</Category>
-				<Category>X-KDE-settings-accessibility</Category>
-				<Category>X-KDE-settings-components</Category>
-				<Category>X-KDE-settings-desktop</Category>
-				<Category>X-KDE-settings-looknfeel</Category>
-				<Category>X-KDE-settings-network</Category>
-				<Category>X-KDE-settings-webbrowsing</Category>
-				<Category>X-KDE-settings-peripherals</Category>
-				<Category>X-KDE-settings-hardware</Category>
-				<Category>X-KDE-settings-power</Category>
-				<Category>X-KDE-settings-security</Category>
-				<Category>X-KDE-settings-sound</Category>
-				<Category>X-KDE-settings-system</Category>
-				<Category>X-KDE-information</Category>
-				<Filename>kde-kcm_knetworkconfmodule_ss.desktop</Filename>
-				<Filename>kde-medianotifications.desktop</Filename>
-				<Filename>kde-audioencoding.desktop</Filename>
-			</Not>
-		</Include>
-	</Menu>
-	<Menu>
-		<Name>Development</Name>
-		<Directory>kf5-development.directory</Directory>
-		<Menu>
-			<Name>X-KDE-KDevelopIDE</Name>
-			<Directory>kf5-development-kdevelop.directory</Directory>
-			<Include>
-				<And>
-					<Category>Development</Category>
-					<Category>X-KDE-KDevelopIDE</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Translation</Name>
-			<Directory>kf5-development-translation.directory</Directory>
-			<Include>
-				<And>
-					<Category>Development</Category>
-					<Category>Translation</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Web Development</Name>
-			<Directory>kf5-development-webdevelopment.directory</Directory>
-			<Include>
-				<And>
-					<Category>Development</Category>
-					<Category>WebDevelopment</Category>
-				</And>
-			</Include>
-		</Menu>
-                <Include>
-					<And>
-                        <Category>Development</Category>
-                        <Not><Category>X-KDE-KDevelopIDE</Category></Not>
-                        <Not><Category>Translation</Category></Not>
-                        <Not><Category>WebDevelopment</Category></Not>
-					</And>
-                </Include>
-        </Menu>
-	<Menu>
-		<Name>Science</Name>
-		<Directory>kf5-science.directory</Directory>
-		<Include>
-			<And><!-- Include /any/ Science app which is not an Education app -->
-				<Or>
-					<Category>Astronomy</Category>
-					<Category>Biology</Category>
-					<Category>Chemistry</Category>
-					<Category>Geology</Category>
-					<Category>MedicalSoftware</Category>
-					<Category>Physics</Category>
-					<Category>Math</Category>
-					<Category>Science</Category>
-				</Or>
-				<Not><Category>Education</Category></Not>
-			</And>
-		</Include>
-	</Menu>
-	<Menu>
-		<Name>Education</Name>
-		<Directory>kf5-education.directory</Directory>
-		<Menu>
-			<Name>Languages</Name>
-			<Directory>kf5-edu-languages.directory</Directory>
-			<Include>
-				<And>
-					<Category>Education</Category>
-					<Or>
-						<Category>Languages</Category>
-						<Category>X-KDE-Edu-Language</Category>
-					</Or>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Mathematics</Name>
-			<Directory>kf5-edu-mathematics.directory</Directory>
-			<Include>
-				<And>
-					<Category>Education</Category>
-					<Category>Math</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Miscellaneous</Name>
-			<Directory>kf5-edu-miscellaneous.directory</Directory>
-			<Include>
-				<And>
-					<Category>Education</Category>
-					<Not>
-						<Category>Languages</Category>
-						<Category>X-KDE-Edu-Language</Category>
-						<Category>Math</Category>
-						<Category>Science</Category>
-						<Category>Teaching</Category>
-						<Category>X-KDE-Edu-Teaching</Category>
-					</Not>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Science</Name>
-			<Directory>kf5-edu-science.directory</Directory>
-			<Include>
-				<And>
-					<Category>Education</Category>
-					<Category>Science</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Tools</Name>
-			<Directory>kf5-edu-tools.directory</Directory>
-			<Include>
-				<And>
-					<Category>Education</Category>
-					<Or>
-						<Category>Teaching</Category>
-						<Category>X-KDE-Edu-Teaching</Category>
-					</Or>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Games</Name>
-		<Directory>kf5-games.directory</Directory>
-		<Menu>
-			<Name>Arcade</Name>
-			<Directory>kf5-games-arcade.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Category>ArcadeGame</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Board</Name>
-			<Directory>kf5-games-board.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Category>BoardGame</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Card</Name>
-			<Directory>kf5-games-card.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Category>CardGame</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Kidsgames</Name>
-			<Directory>kf5-games-kids.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Or>
-						<Category>X-KDE-KidsGame</Category>
-						<Category>KidsGame</Category>
-					</Or>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>TacticStrategy</Name>
-			<Directory>kf5-games-strategy.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Category>StrategyGame</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>Logic</Name>
-			<Directory>kf5-games-logic.directory</Directory>
-			<Include>
-				<And>
-					<Category>Game</Category>
-					<Category>LogicGame</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Include>
-			<And>
-				<Category>Game</Category>
-				<Not>
-					<Category>ArcadeGame</Category>
-					<Category>BoardGame</Category>
-					<Category>CardGame</Category>
-					<Category>X-KDE-KidsGame</Category>
-					<Category>KidsGame</Category>
-					<Category>StrategyGame</Category>
-					<Category>LogicGame</Category>
-				</Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>Toys</Name>
-			<Directory>kf5-toys.directory</Directory>
-			<Include>
-				<Category>Amusement</Category>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Graphics</Name>
-		<Directory>kf5-graphics.directory</Directory>
-		<Include>
-			<And>
-				<Category>Graphics</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>Graphics</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Internet</Name>
-		<Directory>kf5-internet.directory</Directory>
-		<Include>
-			<And>
-				<Category>Network</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>Terminal</Name>
-			<Directory>kf5-internet-terminal.directory</Directory>
-		</Menu>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>Network</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Multimedia</Name>
-		<Directory>kf5-multimedia.directory</Directory>
-		<Include>
-			<And>
-				<Category>AudioVideo</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>AudioVideo</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Office</Name>
-		<Directory>kf5-office.directory</Directory>
-		<Layout>
-			<Merge type="menus"/>
-			<Filename>kde-koshell.desktop</Filename>
-			<Filename>kde-Kontact.desktop</Filename>
-			<Separator/>
-			<Filename>kde-kword.desktop</Filename>
-			<Filename>kde-kspread.desktop</Filename>
-			<Filename>kde-kpresenter.desktop</Filename>
-			<Merge type="files"/>
-			<Separator/>
-			<Menuname>More</Menuname>
-		</Layout>
-		<Include>
-			<And>
-				<Category>Office</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>Office</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Settingsmenu</Name>
-		<Directory>kf5-settingsmenu.directory</Directory>
-		<Include>
-			<Category>Settings</Category>
-		</Include>
-	</Menu>
-	<Menu>
-		<Name>System</Name>
-		<Directory>kf5-system.directory</Directory>
-		<Include>
-			<And>
-				<Category>System</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-		</Include>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>System</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-		<Menu>
-			<Name>ScreenSavers</Name>
-			<Directory>kf5-system-screensavers.directory</Directory>
-		</Menu>
-		<Menu>
-			<Name>Terminal</Name>
-			<Directory>kf5-system-terminal.directory</Directory>
-		</Menu>
-	</Menu>
-	<Menu>
-		<Name>Utilities</Name>
-		<Directory>kf5-utilities.directory</Directory>
-		<Include>
-			<And>
-				<Category>Utility</Category>
-				<Not><Category>X-KDE-More</Category></Not>
-			</And>
-			<Category>TextEditor</Category>
-			<Category>Accessibility</Category>
-			<Category>X-KDE-Utilities-Desktop</Category>
-			<Category>X-KDE-Utilities-File</Category>
-			<Category>X-KDE-Utilities-Peripherals</Category>
-			<Category>X-KDE-Utilities-PIM</Category>
-		</Include>
-		<Menu>
-			<Name>XUtilities</Name>
-			<Directory>kf5-utilities-xutils.directory</Directory>
-		</Menu>
-		<Menu>
-			<Name>More</Name>
-			<Directory>kf5-more.directory</Directory>
-			<Include>
-				<And>
-					<Category>Utility</Category>
-					<Category>X-KDE-More</Category>
-				</And>
-			</Include>
-		</Menu>
-	</Menu>
-	<Include>
-		<And>
-			<Category>KDE</Category>
-			<Category>Core</Category>
-		</And>
-	</Include>
-	<DefaultMergeDirs/>
-	<MergeFile>applications-kmenuedit.menu</MergeFile>
-</Menu>
diff --git a/src/kbuildsycoca/kbuildmimetypefactory.cpp b/src/kbuildsycoca/kbuildmimetypefactory.cpp
deleted file mode 100644
index 520c777..0000000
--- a/src/kbuildsycoca/kbuildmimetypefactory.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright 1999-2007 David Faure <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- */
-
-#include "kbuildmimetypefactory.h"
-#include "ksycoca.h"
-#include "ksycocadict_p.h"
-#include "ksycocaresourcelist.h"
-
-#include <assert.h>
-#include <QDebug>
-#include <QtCore/QHash>
-#include <qstandardpaths.h>
-
-KBuildMimeTypeFactory::KBuildMimeTypeFactory(KSycoca *db)
-    : KMimeTypeFactory(db)
-{
-    m_resourceList = new KSycocaResourceList;
-    // We want all xml files under xdgdata/mime - but not mime/packages/*.xml
-    m_resourceList->add("xdgdata-mime", "mime", "*.xml");
-}
-
-KBuildMimeTypeFactory::~KBuildMimeTypeFactory()
-{
-    delete m_resourceList;
-}
-
-KSycocaEntry::List KBuildMimeTypeFactory::allEntries() const
-{
-    assert(sycoca()->isBuilding());
-    KSycocaEntry::List lst;
-    KSycocaEntryDict::Iterator itmime = m_entryDict->begin();
-    const KSycocaEntryDict::Iterator endmime = m_entryDict->end();
-    for (; itmime != endmime; ++itmime) {
-        lst.append(*itmime);
-    }
-    return lst;
-}
-
-KSycocaEntry *KBuildMimeTypeFactory::createEntry(const QString &file) const
-{
-    // file=text/plain.xml  ->  name=plain.xml dirName=text
-    Q_ASSERT(!file.startsWith("mime/"));
-
-    const int pos = file.lastIndexOf('/');
-    if (pos == -1) { // huh?
-        return 0;
-    }
-    const QString dirName = file.left(pos);
-    if (dirName == "packages") { // special subdir
-        return 0;
-    }
-
-    const int dot = file.lastIndexOf('.');
-    if (dot == -1) { // huh?
-        return 0;
-    }
-    const QString name = file.left(dot);
-
-    //qDebug() << "Creating mimetype" << name << "from file" << file;
-
-    MimeTypeEntry *e = new MimeTypeEntry(file, name);
-    return e;
-}
-
-void KBuildMimeTypeFactory::saveHeader(QDataStream &str)
-{
-    KSycocaFactory::saveHeader(str);
-}
-
-void KBuildMimeTypeFactory::save(QDataStream &str)
-{
-    KSycocaFactory::save(str);
-
-    str << qint32(0);
-
-    const int endOfFactoryData = str.device()->pos();
-
-    // Update header (pass #3)
-    saveHeader(str);
-
-    // Seek to end.
-    str.device()->seek(endOfFactoryData);
-}
-
-void KBuildMimeTypeFactory::createFakeMimeType(const QString &name)
-{
-    const QString file = name; // hack
-    KSycocaEntry::Ptr entry = m_entryDict->value(file);
-    if (!entry) {
-        MimeTypeEntry *e = new MimeTypeEntry(file, name);
-        entry = e;
-    }
-
-    Q_ASSERT(entry && entry->isValid());
-    addEntry(entry);
-}
diff --git a/src/kbuildsycoca/kbuildmimetypefactory.h b/src/kbuildsycoca/kbuildmimetypefactory.h
deleted file mode 100644
index 4cd1841..0000000
--- a/src/kbuildsycoca/kbuildmimetypefactory.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* This file is part of the KDE project
-   Copyright 1999-2007 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_KBUILD_MIME_TYPE_FACTORY_H
-#define KDED_KBUILD_MIME_TYPE_FACTORY_H
-
-#include <kmimetypefactory_p.h>
-#include <QtCore/QStringList>
-
-/**
- * Mime-type factory for building ksycoca
- * @internal
- */
-class KBuildMimeTypeFactory : public KMimeTypeFactory
-{
-public:
-    /**
-     * Create factory
-     */
-    KBuildMimeTypeFactory(KSycoca *db);
-
-    virtual ~KBuildMimeTypeFactory();
-
-    virtual KSycocaEntry::List allEntries() const;
-
-    /**
-     * Construct a KMimeType from a config file.
-     */
-    virtual KSycocaEntry *createEntry(const QString &file) const;
-
-    virtual MimeTypeEntry *createEntry(int) const
-    {
-        assert(0);
-        return 0L;
-    }
-
-    void createFakeMimeType(const QString &name);
-
-    /**
-     * Write out mime type specific index files.
-     */
-    virtual void save(QDataStream &str);
-
-    /**
-     * Write out header information
-     *
-     * Don't forget to call the parent first when you override
-     * this function.
-     */
-    virtual void saveHeader(QDataStream &str);
-};
-
-#endif
diff --git a/src/kbuildsycoca/kbuildservicefactory.cpp b/src/kbuildsycoca/kbuildservicefactory.cpp
deleted file mode 100644
index e085d96..0000000
--- a/src/kbuildsycoca/kbuildservicefactory.cpp
+++ /dev/null
@@ -1,422 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 1999, 2007 David Faure <faure@kde.org>
- *                1999 Waldo Bastian <bastian@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "kbuildservicefactory.h"
-#include "kbuildservicegroupfactory.h"
-#include "kbuildmimetypefactory.h"
-#include "kservicetypefactory_p.h"
-#include "ksycoca.h"
-#include "ksycocadict_p.h"
-#include "ksycocaresourcelist.h"
-#include "kdesktopfile.h"
-#include <kservicetype.h>
-
-#include <QDebug>
-#include <QDir>
-#include <qmimedatabase.h>
-
-#include <assert.h>
-#include <kmimetypefactory_p.h>
-#include <qstandardpaths.h>
-
-KBuildServiceFactory::KBuildServiceFactory(KServiceTypeFactory *serviceTypeFactory,
-        KBuildMimeTypeFactory *mimeTypeFactory,
-        KBuildServiceGroupFactory *serviceGroupFactory) :
-    KServiceFactory(serviceTypeFactory->sycoca()),
-    m_nameMemoryHash(),
-    m_relNameMemoryHash(),
-    m_menuIdMemoryHash(),
-    m_dupeDict(),
-    m_serviceTypeFactory(serviceTypeFactory),
-    m_mimeTypeFactory(mimeTypeFactory),
-    m_serviceGroupFactory(serviceGroupFactory)
-{
-    m_resourceList = new KSycocaResourceList();
-    // We directly care about services desktop files.
-    // All the application desktop files are parsed on demand from the vfolder menu code.
-    m_resourceList->add("services", "kservices5", "*.desktop");
-
-    m_nameDict = new KSycocaDict();
-    m_relNameDict = new KSycocaDict();
-    m_menuIdDict = new KSycocaDict();
-}
-
-KBuildServiceFactory::~KBuildServiceFactory()
-{
-    delete m_resourceList;
-}
-
-KService::Ptr KBuildServiceFactory::findServiceByDesktopName(const QString &name)
-{
-    return m_nameMemoryHash.value(name);
-}
-
-KService::Ptr KBuildServiceFactory::findServiceByDesktopPath(const QString &name)
-{
-    return m_relNameMemoryHash.value(name);
-}
-
-KService::Ptr KBuildServiceFactory::findServiceByMenuId(const QString &menuId)
-{
-    return m_menuIdMemoryHash.value(menuId);
-}
-
-KSycocaEntry *KBuildServiceFactory::createEntry(const QString &file) const
-{
-    Q_ASSERT(!file.startsWith("kservices5/")); // we add this ourselves, below
-
-    QString name = file;
-    int pos = name.lastIndexOf('/');
-    if (pos != -1) {
-        name = name.mid(pos + 1);
-    }
-    // Is it a .desktop file?
-    if (name.endsWith(QLatin1String(".desktop"))) {
-
-        //qDebug() << file;
-
-        KService *serv;
-        if (QDir::isAbsolutePath(file)) { // vfolder sends us full paths for applications
-            serv = new KService(file);
-        } else { // we get relative paths for services
-            KDesktopFile desktopFile(QStandardPaths::GenericDataLocation, "kservices5/" + file);
-            // Note that the second arg below MUST be 'file', unchanged.
-            // If the entry path doesn't match the 'file' parameter to createEntry, reusing old entries
-            // (via time dict, which uses the entry path as key) cannot work.
-            serv = new KService(&desktopFile, file);
-        }
-
-        //qDebug() << "Creating KService from" << file << "entryPath=" << serv->entryPath();
-        // Note that the menuId will be set by the vfolder_menu.cpp code just after
-        // createEntry returns.
-
-        if (serv->isValid() && !serv->isDeleted()) {
-            //qDebug() << "Creating KService from" << file << "entryPath=" << serv->entryPath() << "storageId=" << serv->storageId();
-            return serv;
-        } else {
-            if (!serv->isDeleted()) {
-                qWarning() << "Invalid Service : " << file;
-            }
-            delete serv;
-            return 0;
-        }
-    } // TODO else if a Windows application,  new KService(name, exec, icon)
-    return 0;
-}
-
-void KBuildServiceFactory::saveHeader(QDataStream &str)
-{
-    KSycocaFactory::saveHeader(str);
-
-    str << qint32(m_nameDictOffset);
-    str << qint32(m_relNameDictOffset);
-    str << qint32(m_offerListOffset);
-    str << qint32(m_menuIdDictOffset);
-}
-
-void KBuildServiceFactory::save(QDataStream &str)
-{
-    KSycocaFactory::save(str);
-
-    m_nameDictOffset = str.device()->pos();
-    m_nameDict->save(str);
-
-    m_relNameDictOffset = str.device()->pos();
-    m_relNameDict->save(str);
-
-    saveOfferList(str);
-
-    m_menuIdDictOffset = str.device()->pos();
-    m_menuIdDict->save(str);
-
-    int endOfFactoryData = str.device()->pos();
-
-    // Update header (pass #3)
-    saveHeader(str);
-
-    // Seek to end.
-    str.device()->seek(endOfFactoryData);
-}
-
-void KBuildServiceFactory::collectInheritedServices()
-{
-    // For each mimetype, go up the parent-mimetype chains and collect offers.
-    // For "removed associations" to work, we can't just grab everything from all parents.
-    // We need to process parents before children, hence the recursive call in
-    // collectInheritedServices(mime) and the QSet to process a given parent only once.
-    QSet<QString> visitedMimes;
-    const QStringList allMimeTypes = m_mimeTypeFactory->allMimeTypes();
-    Q_FOREACH (const QString &mimeType, allMimeTypes) {
-        collectInheritedServices(mimeType, visitedMimes);
-    }
-}
-
-void KBuildServiceFactory::collectInheritedServices(const QString &mimeTypeName, QSet<QString> &visitedMimes)
-{
-    if (visitedMimes.contains(mimeTypeName)) {
-        return;
-    }
-    visitedMimes.insert(mimeTypeName);
-
-    // With multiple inheritance, the "mimeTypeInheritanceLevel" isn't exactly
-    // correct (it should only be increased when going up a level, not when iterating
-    // through the multiple parents at a given level). I don't think we care, though.
-    int mimeTypeInheritanceLevel = 0;
-
-    QMimeDatabase db;
-    QMimeType qmime = db.mimeTypeForName(mimeTypeName);
-    Q_FOREACH (const QString &parentMimeType, qmime.parentMimeTypes()) {
-
-        collectInheritedServices(parentMimeType, visitedMimes);
-
-        ++mimeTypeInheritanceLevel;
-        const QList<KServiceOffer> &offers = m_offerHash.offersFor(parentMimeType);
-        QList<KServiceOffer>::const_iterator itserv = offers.begin();
-        const QList<KServiceOffer>::const_iterator endserv = offers.end();
-        for (; itserv != endserv; ++itserv) {
-            if (!m_offerHash.hasRemovedOffer(mimeTypeName, (*itserv).service())) {
-                KServiceOffer offer(*itserv);
-                offer.setMimeTypeInheritanceLevel(mimeTypeInheritanceLevel);
-                //qDebug() << "INHERITANCE: Adding service" << (*itserv).service()->entryPath() << "to" << mimeTypeName << "mimeTypeInheritanceLevel=" << mimeTypeInheritanceLevel;
-                m_offerHash.addServiceOffer(mimeTypeName, offer);
-            }
-        }
-    }
-}
-
-void KBuildServiceFactory::postProcessServices()
-{
-    // By doing all this here rather than in addEntry (and removing when replacing
-    // with local override), we only do it for the final applications.
-    // Note that this also affects resolution of the by-desktop-name lookup,
-    // as name resolution is only performed *after* all the duplicates (based on
-    // storage ID) have been removed.
-
-    // For every service...
-    KSycocaEntryDict::Iterator itserv = m_entryDict->begin();
-    const KSycocaEntryDict::Iterator endserv = m_entryDict->end();
-    for (; itserv != endserv; ++itserv) {
-
-        KSycocaEntry::Ptr entry = *itserv;
-        KService::Ptr service(static_cast<KService*>(entry.data()));
-
-        if (!service->isDeleted()) {
-            const QString parent = service->parentApp();
-            if (!parent.isEmpty()) {
-                m_serviceGroupFactory->addNewChild(parent, KSycocaEntry::Ptr(service));
-            }
-        }
-
-        const QString name = service->desktopEntryName();
-        KService::Ptr dup = m_nameMemoryHash.value(name);
-        if (dup) {
-            // The rule is that searching for the desktop name "foo" should find
-            // the desktop file with the storage id "foo.desktop" before it
-            // finds "bar/foo.desktop" (or "bar-foo.desktop").
-            // "bar/foo.desktop" and "baz/foo.desktop" are arbitrarily ordered
-            // (in practice, the one later in the alphabet wins).
-            if (dup->storageId().endsWith(service->storageId())) {
-                // allow dup to be overridden
-                m_nameDict->remove(name);
-                dup = 0;
-            }
-        }
-        if (!dup) {
-            m_nameDict->add(name, entry);
-            m_nameMemoryHash.insert(name, service);
-        }
-
-        const QString relName = service->entryPath();
-        //qDebug() << "adding service" << service.data() << "isApp=" << service->isApplication() << "menuId=" << service->menuId() << "name=" << name << "relName=" << relName;
-        m_relNameDict->add(relName, entry);
-        m_relNameMemoryHash.insert(relName, service); // for KMimeAssociations
-
-        const QString menuId = service->menuId();
-        if (!menuId.isEmpty()) { // empty for services, non-empty for applications
-            m_menuIdDict->add(menuId, entry);
-            m_menuIdMemoryHash.insert(menuId, service); // for KMimeAssociations
-        }
-    }
-    populateServiceTypes();
-}
-
-void KBuildServiceFactory::populateServiceTypes()
-{
-    QMimeDatabase db;
-    // For every service...
-    KSycocaEntryDict::Iterator itserv = m_entryDict->begin();
-    const KSycocaEntryDict::Iterator endserv = m_entryDict->end();
-    for (; itserv != endserv; ++itserv) {
-
-        KService::Ptr service(static_cast<KService*>((*itserv).data()));
-        QVector<KService::ServiceTypeAndPreference> serviceTypeList = service->_k_accessServiceTypes();
-        //bool hasAllAll = false;
-        //bool hasAllFiles = false;
-
-        // Add this service to all its servicetypes (and their parents) and to all its mimetypes
-        for (int i = 0; i < serviceTypeList.count() /*don't cache it, it can change during iteration!*/; ++i) {
-            const QString stName = serviceTypeList[i].serviceType;
-            // It could be a servicetype or a mimetype.
-            KServiceType::Ptr serviceType = m_serviceTypeFactory->findServiceTypeByName(stName);
-            if (serviceType) {
-                const int preference = serviceTypeList[i].preference;
-                const QString parent = serviceType->parentServiceType();
-                if (!parent.isEmpty()) {
-                    serviceTypeList.append(KService::ServiceTypeAndPreference(preference, parent));
-                }
-
-                //qDebug() << "Adding service" << service->entryPath() << "to" << serviceType->name() << "pref=" << preference;
-                m_offerHash.addServiceOffer(stName, KServiceOffer(service, preference, 0, service->allowAsDefault()));
-            } else {
-                KServiceOffer offer(service, serviceTypeList[i].preference, 0, service->allowAsDefault());
-                QMimeType mime = db.mimeTypeForName(stName);
-                if (!mime.isValid()) {
-                    if (stName.startsWith(QLatin1String("x-scheme-handler/"))) {
-                        // Create those on demand
-                        m_mimeTypeFactory->createFakeMimeType(stName);
-                        m_offerHash.addServiceOffer(stName, offer);
-                    } else {
-                        //qDebug() << service->entryPath() << "specifies undefined mimetype/servicetype" << stName;
-                        // technically we could call addServiceOffer here, 'mime' isn't used. But it
-                        // would be useless, since the loops for writing out the offers iterate
-                        // over all known servicetypes and mimetypes. Unknown -> never written out.
-                        continue;
-                    }
-                } else {
-                    bool shouldAdd = true;
-                    foreach (const QString &otherType, service->serviceTypes()) {
-                        // Skip derived types if the base class is listed (#321706)
-                        if (stName != otherType && mime.inherits(otherType)) {
-                            // But don't skip aliases (they got resolved into mime->name() already, but don't let two aliases cancel out)
-                            if (db.mimeTypeForName(otherType).name() != mime.name()) {
-                                //qDebug() << "Skipping" << mime->name() << "because of" << otherType << "(canonical" << KMimeTypeRepository::self()->canonicalName(otherType) << ") while parsing" << service->entryPath();
-                                shouldAdd = false;
-                            }
-                        }
-                    }
-                    if (shouldAdd) {
-                        //qDebug() << "Adding service" << service->entryPath() << "to" << mime->name();
-                        m_offerHash.addServiceOffer(mime.name(), offer); // mime->name so that we resolve aliases
-                    }
-                }
-            }
-        }
-    }
-
-    // Read user preferences (added/removed associations) and add/remove serviceoffers to m_offerHash
-    KMimeAssociations mimeAssociations(m_offerHash, this);
-    mimeAssociations.parseAllMimeAppsList();
-
-    // Now for each mimetype, collect services from parent mimetypes
-    collectInheritedServices();
-
-    // Now collect the offsets into the (future) offer list
-    // The loops look very much like the ones in saveOfferList obviously.
-    int offersOffset = 0;
-    const int offerEntrySize = sizeof(qint32) * 4;   // four qint32s, see saveOfferList.
-
-    // TODO: idea: we could iterate over m_offerHash, and look up the servicetype or mimetype.
-    // Would that be faster than iterating over all servicetypes and mimetypes?
-
-    KSycocaEntryDict::const_iterator itstf = m_serviceTypeFactory->entryDict()->constBegin();
-    const KSycocaEntryDict::const_iterator endstf = m_serviceTypeFactory->entryDict()->constEnd();
-    for (; itstf != endstf; ++itstf) {
-        KServiceType::Ptr entry(static_cast<KServiceType*>((*itstf).data()));
-        const int numOffers = m_offerHash.offersFor(entry->name()).count();
-        if (numOffers) {
-            entry->setServiceOffersOffset(offersOffset);
-            offersOffset += offerEntrySize * numOffers;
-        }
-    }
-    KSycocaEntryDict::const_iterator itmtf = m_mimeTypeFactory->entryDict()->constBegin();
-    const KSycocaEntryDict::const_iterator endmtf = m_mimeTypeFactory->entryDict()->constEnd();
-    for (; itmtf != endmtf; ++itmtf) {
-        KMimeTypeFactory::MimeTypeEntry::Ptr entry(static_cast<KMimeTypeFactory::MimeTypeEntry*>((*itmtf).data()));
-        const int numOffers = m_offerHash.offersFor(entry->name()).count();
-        if (numOffers) {
-            //qDebug() << entry->name() << "offset=" << offersOffset;
-            entry->setServiceOffersOffset(offersOffset);
-            offersOffset += offerEntrySize * numOffers;
-        }
-    }
-}
-
-void KBuildServiceFactory::saveOfferList(QDataStream &str)
-{
-    m_offerListOffset = str.device()->pos();
-
-    // For each entry in servicetypeFactory
-    KSycocaEntryDict::const_iterator itstf = m_serviceTypeFactory->entryDict()->constBegin();
-    const KSycocaEntryDict::const_iterator endstf = m_serviceTypeFactory->entryDict()->constEnd();
-    for (; itstf != endstf; ++itstf) {
-        // export associated services
-        const KServiceType::Ptr entry(static_cast<KServiceType*>((*itstf).data()));
-        Q_ASSERT(entry);
-
-        QList<KServiceOffer> offers = m_offerHash.offersFor(entry->name());
-        qStableSort(offers);   // by initial preference
-
-        for (QList<KServiceOffer>::const_iterator it2 = offers.constBegin();
-                it2 != offers.constEnd(); ++it2) {
-            //qDebug() << "servicetype offers list:" << entry->name() << "->" << (*it2).service()->entryPath();
-
-            str << qint32(entry->offset());
-            str << qint32((*it2).service()->offset());
-            str << qint32((*it2).preference());
-            str << qint32(0); // mimeTypeInheritanceLevel
-            // update offerEntrySize in populateServiceTypes if you add/remove something here
-        }
-    }
-
-    // For each entry in mimeTypeFactory
-    KSycocaEntryDict::const_iterator itmtf = m_mimeTypeFactory->entryDict()->constBegin();
-    const KSycocaEntryDict::const_iterator endmtf = m_mimeTypeFactory->entryDict()->constEnd();
-    for (; itmtf != endmtf; ++itmtf) {
-        // export associated services
-        const KMimeTypeFactory::MimeTypeEntry::Ptr entry(static_cast<KMimeTypeFactory::MimeTypeEntry*>((*itmtf).data()));
-        Q_ASSERT(entry);
-        QList<KServiceOffer> offers = m_offerHash.offersFor(entry->name());
-        qStableSort(offers);   // by initial preference
-
-        for (QList<KServiceOffer>::const_iterator it2 = offers.constBegin();
-                it2 != offers.constEnd(); ++it2) {
-            //qDebug() << "mimetype offers list:" << entry->name() << "->" << (*it2).service()->entryPath() << "pref" << (*it2).preference();
-            Q_ASSERT((*it2).service()->offset() != 0);
-            str << qint32(entry->offset());
-            str << qint32((*it2).service()->offset());
-            str << qint32((*it2).preference());
-            str << qint32((*it2).mimeTypeInheritanceLevel());
-            // update offerEntrySize in populateServiceTypes if you add/remove something here
-        }
-    }
-
-    str << qint32(0);               // End of list marker (0)
-}
-
-void KBuildServiceFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
-{
-    Q_ASSERT(newEntry);
-    if (m_dupeDict.contains(newEntry)) {
-        return;
-    }
-
-    const KService::Ptr service(static_cast<KService*>(newEntry.data()));
-    m_dupeDict.insert(newEntry);
-    KSycocaFactory::addEntry(newEntry);
-}
diff --git a/src/kbuildsycoca/kbuildservicefactory.h b/src/kbuildsycoca/kbuildservicefactory.h
deleted file mode 100644
index d0aff55..0000000
--- a/src/kbuildsycoca/kbuildservicefactory.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 1999, 2007 David Faure <faure@kde.org>
-                 1999 Waldo Bastian <bastian@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_KBUILD_SERVICE_FACTORY_H
-#define KDED_KBUILD_SERVICE_FACTORY_H
-
-#include <QtCore/QStringList>
-
-#include "kmimeassociations.h"
-#include <kservicefactory_p.h>
-// We export the services to the service group factory!
-class KBuildServiceGroupFactory;
-class KBuildMimeTypeFactory;
-class KServiceTypeFactory;
-
-/**
- * Service factory for building ksycoca
- * @internal
- */
-class KBuildServiceFactory : public KServiceFactory
-{
-public:
-    /**
-     * Create factory
-     */
-    KBuildServiceFactory(KServiceTypeFactory *serviceTypeFactory,
-                         KBuildMimeTypeFactory *mimeTypeFactory,
-                         KBuildServiceGroupFactory *serviceGroupFactory);
-
-    virtual ~KBuildServiceFactory();
-
-    /// Reimplemented from KServiceFactory
-    virtual KService::Ptr findServiceByDesktopName(const QString &name);
-    /// Reimplemented from KServiceFactory
-    virtual KService::Ptr findServiceByDesktopPath(const QString &name);
-    /// Reimplemented from KServiceFactory
-    virtual KService::Ptr findServiceByMenuId(const QString &menuId);
-
-    /**
-     * Construct a KService from a config file.
-     */
-    virtual KSycocaEntry *createEntry(const QString &file) const;
-
-    virtual KService *createEntry(int) const
-    {
-        assert(0);
-        return 0;
-    }
-
-    /**
-     * Add a new entry.
-     */
-    virtual void addEntry(const KSycocaEntry::Ptr &newEntry);
-
-    /**
-     * Write out service specific index files.
-     */
-    virtual void save(QDataStream &str);
-
-    /**
-     * Write out header information
-     *
-     * Don't forget to call the parent first when you override
-     * this function.
-     */
-    virtual void saveHeader(QDataStream &str);
-
-    void postProcessServices();
-
-private:
-    void populateServiceTypes();
-    void saveOfferList(QDataStream &str);
-    void collectInheritedServices();
-    void collectInheritedServices(const QString &mime, QSet<QString> &visitedMimes);
-
-    QHash<QString, KService::Ptr> m_nameMemoryHash; // m_nameDict is not useable while building ksycoca
-    QHash<QString, KService::Ptr> m_relNameMemoryHash; // m_relNameDict is not useable while building ksycoca
-    QHash<QString, KService::Ptr> m_menuIdMemoryHash; // m_menuIdDict is not useable while building ksycoca
-    QSet<KSycocaEntry::Ptr> m_dupeDict;
-
-    KOfferHash m_offerHash;
-
-    KServiceTypeFactory *m_serviceTypeFactory;
-    KBuildMimeTypeFactory *m_mimeTypeFactory;
-    KBuildServiceGroupFactory *m_serviceGroupFactory;
-};
-
-#endif
diff --git a/src/kbuildsycoca/kbuildservicegroupfactory.cpp b/src/kbuildsycoca/kbuildservicegroupfactory.cpp
deleted file mode 100644
index ce53fd4..0000000
--- a/src/kbuildsycoca/kbuildservicegroupfactory.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "kbuildservicegroupfactory.h"
-#include "ksycoca.h"
-#include "ksycocadict_p.h"
-#include "ksycocaresourcelist.h"
-#include <kservicegroup_p.h>
-
-#include <QDebug>
-#include <assert.h>
-#include <QtCore/QHash>
-
-KBuildServiceGroupFactory::KBuildServiceGroupFactory(KSycoca *db)
-    : KServiceGroupFactory(db)
-{
-    m_resourceList = new KSycocaResourceList;
-//   m_resourceList->add( "apps", "*.directory" );
-
-    m_baseGroupDict = new KSycocaDict();
-}
-
-KBuildServiceGroupFactory::~KBuildServiceGroupFactory()
-{
-    delete m_resourceList;
-}
-
-KServiceGroup *KBuildServiceGroupFactory::createEntry(const QString &) const
-{
-    // Unused
-    qWarning() << "called!";
-    return 0;
-}
-
-void KBuildServiceGroupFactory::addNewEntryTo(const QString &menuName, const KService::Ptr &newEntry)
-{
-    KSycocaEntry::Ptr ptr = m_entryDict->value(menuName);
-    KServiceGroup::Ptr entry;
-    if (ptr && ptr->isType(KST_KServiceGroup)) {
-        entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
-    }
-
-    if (!entry) {
-        qWarning() << "( " << menuName << ", " << newEntry->name() << " ): menu does not exists!";
-        return;
-    }
-    entry->addEntry(KSycocaEntry::Ptr(newEntry));
-}
-
-KServiceGroup::Ptr
-KBuildServiceGroupFactory::addNew(const QString &menuName, const QString &file, KServiceGroup::Ptr entry, bool isDeleted)
-{
-    KSycocaEntry::Ptr ptr = m_entryDict->value(menuName);
-    if (ptr) {
-        qWarning() << "( " << menuName << ", " << file << " ): menu already exists!";
-        return KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
-    }
-
-    // Create new group entry
-    if (!entry) {
-        entry = new KServiceGroup(file, menuName);
-    }
-
-    entry->d_func()->m_childCount = -1; // Recalculate
-
-    addEntry(KSycocaEntry::Ptr(entry));
-
-    if (menuName != "/") {
-        // Make sure parent dir exists.
-        QString parent = menuName.left(menuName.length() - 1);
-        int i = parent.lastIndexOf('/');
-        if (i > 0) {
-            parent = parent.left(i + 1);
-        } else {
-            parent = '/';
-        }
-
-        KServiceGroup::Ptr parentEntry;
-        ptr = m_entryDict->value(parent);
-        if (ptr && ptr->isType(KST_KServiceGroup)) {
-            parentEntry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
-        }
-        if (!parentEntry) {
-            qWarning() << "( " << menuName << ", " << file << " ): parent menu does not exist!";
-        } else {
-            if (!isDeleted && !entry->isDeleted()) {
-                parentEntry->addEntry(KSycocaEntry::Ptr(entry));
-            }
-        }
-    }
-    return entry;
-}
-
-void
-KBuildServiceGroupFactory::addNewChild(const QString &parent, const KSycocaEntry::Ptr &newEntry)
-{
-    QString name = "#parent#" + parent;
-
-    KServiceGroup::Ptr entry;
-    KSycocaEntry::Ptr ptr = m_entryDict->value(name);
-    if (ptr && ptr->isType(KST_KServiceGroup)) {
-        entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
-    }
-
-    if (!entry) {
-        entry = new KServiceGroup(name);
-        addEntry(KSycocaEntry::Ptr(entry));
-    }
-    if (newEntry) {
-        entry->addEntry(newEntry);
-    }
-}
-
-void
-KBuildServiceGroupFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
-{
-    KSycocaFactory::addEntry(newEntry);
-
-    KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(newEntry.data()));
-    serviceGroup->d_func()->m_serviceList.clear();
-
-    if (!serviceGroup->baseGroupName().isEmpty()) {
-        m_baseGroupDict->add(serviceGroup->baseGroupName(), newEntry);
-    }
-}
-
-void
-KBuildServiceGroupFactory::saveHeader(QDataStream &str)
-{
-    KSycocaFactory::saveHeader(str);
-
-    str << qint32(m_baseGroupDictOffset);
-}
-
-void
-KBuildServiceGroupFactory::save(QDataStream &str)
-{
-    KSycocaFactory::save(str);
-
-    m_baseGroupDictOffset = str.device()->pos();
-    m_baseGroupDict->save(str);
-
-    int endOfFactoryData = str.device()->pos();
-
-    // Update header (pass #3)
-    saveHeader(str);
-
-    // Seek to end.
-    str.device()->seek(endOfFactoryData);
-}
-
-KServiceGroup::Ptr KBuildServiceGroupFactory::findGroupByDesktopPath(const QString &_name, bool deep)
-{
-    assert(sycoca()->isBuilding());
-    Q_UNUSED(deep); // ?
-    // We're building a database - the service type must be in memory
-    KSycocaEntry::Ptr group = m_entryDict->value(_name);
-    return KServiceGroup::Ptr(static_cast<KServiceGroup*>(group.data()));
-}
diff --git a/src/kbuildsycoca/kbuildservicegroupfactory.h b/src/kbuildsycoca/kbuildservicegroupfactory.h
deleted file mode 100644
index ceb573b..0000000
--- a/src/kbuildsycoca/kbuildservicegroupfactory.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License version 2as published by the Free Software Foundation.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_KBUILD_SERVICE_GROUP_FACTORY_H
-#define KDED_KBUILD_SERVICE_GROUP_FACTORY_H
-
-#include <kservice.h>
-#include <kservicegroupfactory_p.h>
-#include <QtCore/QStringList>
-
-/**
- * Service group factory for building ksycoca
- * @internal
- */
-class KBuildServiceGroupFactory : public KServiceGroupFactory
-{
-public:
-    /**
-     * Create factory
-     */
-    KBuildServiceGroupFactory(KSycoca *db);
-
-    virtual ~KBuildServiceGroupFactory();
-
-    /**
-     * Create new entry.
-     */
-    virtual KServiceGroup *createEntry(const QString &) const;
-
-    virtual KServiceGroup *createEntry(int) const
-    {
-        assert(0);
-        return 0L;
-    }
-
-    /**
-     * Adds the entry @p newEntry to the menu @p menuName
-     */
-    void addNewEntryTo(const QString &menuName, const KService::Ptr &newEntry);
-
-    /**
-     * Adds the entry @p newEntry to the "parent group" @p parent, creating
-     * the group if necassery.
-     * A "parent group" is a group of services that all have the same
-     * "X-KDE-ParentApp".
-     */
-    void addNewChild(const QString &parent, const KSycocaEntry::Ptr &newEntry);
-
-    /**
-     * Add new menu @p menuName defined by @p file
-     * When @p entry is non-null it is re-used, otherwise a new group is created.
-     * A pointer to the group is returned.
-     */
-    KServiceGroup::Ptr addNew(const QString &menuName, const QString &file, KServiceGroup::Ptr entry, bool isDeleted);
-
-    /**
-     * Find a group ( by desktop path, e.g. "Applications/Editors")
-     */
-    virtual KServiceGroup::Ptr findGroupByDesktopPath(const QString &_name, bool deep = true);
-
-    /**
-     * Add a new menu entry
-     */
-    virtual void addEntry(const KSycocaEntry::Ptr &newEntry);
-
-    /**
-     * Write out servicegroup  specific index files.
-     */
-    virtual void save(QDataStream &str);
-
-    /**
-     * Write out header information
-     */
-    virtual void saveHeader(QDataStream &str);
-};
-
-#endif
diff --git a/src/kbuildsycoca/kbuildservicetypefactory.cpp b/src/kbuildsycoca/kbuildservicetypefactory.cpp
deleted file mode 100644
index 656ef62..0000000
--- a/src/kbuildsycoca/kbuildservicetypefactory.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 1999 David Faure   <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "kbuildservicetypefactory.h"
-#include "ksycoca.h"
-#include "ksycocadict_p.h"
-#include "ksycocaresourcelist.h"
-
-#include <QDebug>
-#include <assert.h>
-#include <kdesktopfile.h>
-#include <kconfiggroup.h>
-#include <QtCore/QHash>
-#include <qstandardpaths.h>
-
-KBuildServiceTypeFactory::KBuildServiceTypeFactory(KSycoca *db)
-    : KServiceTypeFactory(db)
-{
-    m_resourceList = new KSycocaResourceList;
-    m_resourceList->add("servicetypes", "kservicetypes5", "*.desktop");
-}
-
-KBuildServiceTypeFactory::~KBuildServiceTypeFactory()
-{
-    delete m_resourceList;
-}
-
-KServiceType::Ptr KBuildServiceTypeFactory::findServiceTypeByName(const QString &_name)
-{
-    assert(sycoca()->isBuilding());
-    // We're building a database - the service type must be in memory
-    KSycocaEntry::Ptr servType = m_entryDict->value(_name);
-    return KServiceType::Ptr(static_cast<KServiceType*>(servType.data()));
-}
-
-KSycocaEntry *KBuildServiceTypeFactory::createEntry(const QString &file) const
-{
-    QString name = file;
-    int pos = name.lastIndexOf('/');
-    if (pos != -1) {
-        name = name.mid(pos + 1);
-    }
-
-    if (name.isEmpty()) {
-        return 0;
-    }
-
-    KDesktopFile desktopFile(QStandardPaths::GenericDataLocation, "kservicetypes5/" + file);
-    const KConfigGroup desktopGroup = desktopFile.desktopGroup();
-
-    if (desktopGroup.readEntry("Hidden", false) == true) {
-        return 0;
-    }
-
-    const QString type = desktopGroup.readEntry("Type");
-    if (type != QLatin1String("ServiceType")) {
-        qWarning() << "The service type config file " << desktopFile.fileName() << " has Type=" << type << " instead of Type=ServiceType";
-        return 0;
-    }
-
-    const QString serviceType = desktopGroup.readEntry("X-KDE-ServiceType");
-
-    if (serviceType.isEmpty()) {
-        qWarning() << "The service type config file " << desktopFile.fileName() << " does not contain a ServiceType=... entry";
-        return 0;
-    }
-
-    KServiceType *e = new KServiceType(&desktopFile);
-
-    if (e->isDeleted()) {
-        delete e;
-        return 0;
-    }
-
-    if (!(e->isValid())) {
-        qWarning() << "Invalid ServiceType : " << file;
-        delete e;
-        return 0;
-    }
-
-    return e;
-}
-
-void
-KBuildServiceTypeFactory::saveHeader(QDataStream &str)
-{
-    KSycocaFactory::saveHeader(str);
-    str << qint32(m_propertyTypeDict.count());
-    for (QMap<QString, int>::ConstIterator it = m_propertyTypeDict.constBegin(); it != m_propertyTypeDict.constEnd(); ++it) {
-        str << it.key() << qint32(it.value());
-    }
-}
-
-void
-KBuildServiceTypeFactory::save(QDataStream &str)
-{
-    KSycocaFactory::save(str);
-#if 0 // not needed since don't have any additional index anymore
-    int endOfFactoryData = str.device()->pos();
-
-    // Update header (pass #3)
-    saveHeader(str);
-
-    // Seek to end.
-    str.device()->seek(endOfFactoryData);
-#endif
-}
-
-void
-KBuildServiceTypeFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
-{
-    KSycocaFactory::addEntry(newEntry);
-
-    KServiceType::Ptr serviceType(static_cast<KServiceType*>(newEntry.data()));
-
-    const QMap<QString, QVariant::Type> &pd = serviceType->propertyDefs();
-    QMap<QString, QVariant::Type>::ConstIterator pit = pd.begin();
-    for (; pit != pd.end(); ++pit) {
-        const QString property = pit.key();
-        QMap<QString, int>::iterator dictit = m_propertyTypeDict.find(property);
-        if (dictit == m_propertyTypeDict.end()) {
-            m_propertyTypeDict.insert(property, pit.value());
-        } else if (*dictit != static_cast<int>(pit.value())) {
-            qWarning() << "Property '" << property << "' is defined multiple times (" << serviceType->name() << ")";
-        }
-    }
-}
-
diff --git a/src/kbuildsycoca/kbuildservicetypefactory.h b/src/kbuildsycoca/kbuildservicetypefactory.h
deleted file mode 100644
index f94befb..0000000
--- a/src/kbuildsycoca/kbuildservicetypefactory.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 1999 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_KBUILD_SERVICE_TYPE_FACTORY_H
-#define KDED_KBUILD_SERVICE_TYPE_FACTORY_H
-
-#include <kservicetypefactory_p.h>
-#include <QtCore/QStringList>
-
-/**
- * Service-type factory for building ksycoca
- * @internal
- */
-class KBuildServiceTypeFactory : public KServiceTypeFactory
-{
-public:
-    /**
-     * Create factory
-     */
-    KBuildServiceTypeFactory(KSycoca *db);
-
-    virtual ~KBuildServiceTypeFactory();
-
-    /**
-     * Find a service type in the database file
-     * @return a pointer to the servicetype in the memory dict (don't free!)
-     */
-    virtual KServiceType::Ptr findServiceTypeByName(const QString &_name);
-
-    /**
-     * Construct a KServiceType from a config file.
-     */
-    virtual KSycocaEntry *createEntry(const QString &file) const;
-
-    virtual KServiceType *createEntry(int) const
-    {
-        assert(0);
-        return 0L;
-    }
-
-    /**
-     * Add entry
-     */
-    virtual void addEntry(const KSycocaEntry::Ptr &newEntry);
-
-    /**
-     * Write out service type specific index files.
-     */
-    virtual void save(QDataStream &str);
-
-    /**
-     * Write out header information
-     *
-     * Don't forget to call the parent first when you override
-     * this function.
-     */
-    virtual void saveHeader(QDataStream &str);
-};
-
-#endif
diff --git a/src/kbuildsycoca/kbuildsycoca.cpp b/src/kbuildsycoca/kbuildsycoca.cpp
deleted file mode 100644
index ff66d13..0000000
--- a/src/kbuildsycoca/kbuildsycoca.cpp
+++ /dev/null
@@ -1,856 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 1999 David Faure <faure@kde.org>
- *  Copyright (C) 2002-2003 Waldo Bastian <bastian@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "kbuildsycoca.h"
-#include "ksycoca_p.h"
-#include "ksycocaresourcelist.h"
-#include "vfolder_menu.h"
-
-#include <kservice.h>
-#include "kbuildservicetypefactory.h"
-#include "kbuildmimetypefactory.h"
-#include "kbuildservicefactory.h"
-#include "kbuildservicegroupfactory.h"
-#include "kctimefactory.h"
-#include <QtCore/QDataStream>
-#include <QtCore/QDir>
-#include <QtCore/QEventLoop>
-#include <QtCore/QFile>
-#include <QtCore/QLocale>
-#include <QtCore/QTimer>
-#include <QtCore/QDebug>
-#include <QDBusConnection>
-#include <QDBusMessage>
-#include <QDBusConnectionInterface>
-#include <QDirIterator>
-#include <QDateTime>
-#include <qsavefile.h>
-
-#include <kcrash.h>
-#include <kmemfile_p.h>
-#include <klocalizedstring.h>
-#include <kaboutdata.h>
-
-#include <qplatformdefs.h>
-#include <time.h>
-#include <memory> // auto_ptr
-#include <qstandardpaths.h>
-#include <qcommandlineparser.h>
-#include <qcommandlineoption.h>
-
-#include "../../kservice_version.h"
-
-static qint64 newTimestamp = 0;
-
-static bool bGlobalDatabase = false;
-static bool bMenuTest = false;
-
-static const char *s_cSycocaPath = 0;
-static void crashHandler(int)
-{
-    // If we crash while reading sycoca, we delete the database
-    // in an attempt to recover.
-    if (s_cSycocaPath) {
-        unlink(s_cSycocaPath);
-    }
-}
-
-static QString sycocaPath()
-{
-    QFileInfo fi(KSycoca::absoluteFilePath(bGlobalDatabase ? KSycoca::GlobalDatabase : KSycoca::LocalDatabase));
-    if (!QDir().mkpath(fi.absolutePath())) {
-        qWarning() << "Couldn't create" << fi.absolutePath();
-    }
-    return fi.absoluteFilePath();
-}
-
-KBuildSycocaInterface::~KBuildSycocaInterface() {}
-
-KBuildSycoca::KBuildSycoca()
-    : KSycoca(true),
-      m_allEntries(0),
-      m_serviceFactory(0),
-      m_buildServiceGroupFactory(0),
-      m_currentFactory(0),
-      m_ctimeFactory(0),
-      m_ctimeDict(0),
-      m_currentEntryDict(0),
-      m_serviceGroupEntryDict(0),
-      m_vfolder(0),
-      m_changed(false)
-{
-}
-
-KBuildSycoca::~KBuildSycoca()
-{
-    // Delete the factories while we exist, so that the virtual isBuilding() still works
-    qDeleteAll(*factories());
-    factories()->clear();
-}
-
-KSycocaEntry::Ptr KBuildSycoca::createEntry(const QString &file, bool addToFactory)
-{
-    quint32 timeStamp = m_ctimeFactory->dict()->ctime(file, m_resource);
-    if (!timeStamp) {
-        timeStamp = calcResourceHash(m_resourceSubdir, file);
-    }
-    KSycocaEntry::Ptr entry;
-    if (m_allEntries) {
-        Q_ASSERT(m_ctimeDict);
-        quint32 oldTimestamp = m_ctimeDict->ctime(file, m_resource);
-        if (file.contains("fake")) {
-            qDebug() << "m_ctimeDict->ctime(" << file << ") = " << oldTimestamp << "compared with" << timeStamp;
-        }
-
-        if (timeStamp && (timeStamp == oldTimestamp)) {
-            // Re-use old entry
-            if (m_currentFactory == m_buildServiceGroupFactory) { // Strip .directory from service-group entries
-                entry = m_currentEntryDict->value(file.left(file.length() - 10));
-            } else {
-                entry = m_currentEntryDict->value(file);
-            }
-            // remove from m_ctimeDict; if m_ctimeDict is not empty
-            // after all files have been processed, it means
-            // some files were removed since last time
-            if (file.contains("fake")) {
-                qDebug() << "reusing (and removing) old entry for:" << file << "entry=" << entry;
-            }
-            m_ctimeDict->remove(file, m_resource);
-        } else if (oldTimestamp) {
-            m_changed = true;
-            m_ctimeDict->remove(file, m_resource);
-            qDebug() << "modified:" << file;
-        } else {
-            m_changed = true;
-            qDebug() << "new:" << file;
-        }
-    }
-    m_ctimeFactory->dict()->addCTime(file, m_resource, timeStamp);
-    if (!entry) {
-        // Create a new entry
-        entry = m_currentFactory->createEntry(file);
-    }
-    if (entry && entry->isValid()) {
-        if (addToFactory) {
-            m_currentFactory->addEntry(entry);
-        } else {
-            m_tempStorage.append(entry);
-        }
-        return entry;
-    }
-    return KSycocaEntry::Ptr();
-}
-
-KService::Ptr KBuildSycoca::createService(const QString &path)
-{
-    KSycocaEntry::Ptr entry = createEntry(path, false);
-    return KService::Ptr(static_cast<KService*>(entry.data()));
-}
-
-// returns false if the database is up to date, true if it needs to be saved
-bool KBuildSycoca::build()
-{
-    typedef QLinkedList<KBSEntryDict *> KBSEntryDictList;
-    KBSEntryDictList entryDictList;
-    KBSEntryDict *serviceEntryDict = 0;
-
-    // Convert for each factory the entryList to a Dict.
-    int i = 0;
-    // For each factory
-    for (KSycocaFactoryList::Iterator factory = factories()->begin();
-            factory != factories()->end();
-            ++factory) {
-        KBSEntryDict *entryDict = new KBSEntryDict;
-        if (m_allEntries) {
-            const KSycocaEntry::List list = (*m_allEntries)[i++];
-            Q_FOREACH (const KSycocaEntry::Ptr &entry, list) {
-                //if (entry->entryPath().contains("fake"))
-                //    qDebug() << "inserting into entryDict:" << entry->entryPath() << entry;
-                entryDict->insert(entry->entryPath(), entry);
-            }
-        }
-        if ((*factory) == m_serviceFactory) {
-            serviceEntryDict = entryDict;
-        } else if ((*factory) == m_buildServiceGroupFactory) {
-            m_serviceGroupEntryDict = entryDict;
-        }
-        entryDictList.append(entryDict);
-    }
-
-    QMap<QString, QByteArray> allResourcesSubDirs; // dirs, kstandarddirs-resource-name
-    // For each factory
-    for (KSycocaFactoryList::Iterator factory = factories()->begin();
-            factory != factories()->end();
-            ++factory) {
-        // For each resource the factory deals with
-        const KSycocaResourceList *list = (*factory)->resourceList();
-        if (!list) {
-            continue;
-        }
-        Q_FOREACH (const KSycocaResource &res, *list) {
-            // With this we would get dirs, but not a unique list of relative files (for global+local merging to work)
-            //const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, res.subdir, QStandardPaths::LocateDirectory);
-            //allResourcesSubDirs[res.resource] += dirs;
-            allResourcesSubDirs.insert(res.subdir, res.resource);
-        }
-    }
-
-    m_ctimeFactory = new KCTimeFactory(this); // This is a build factory too, don't delete!!
-    bool uptodate = true;
-    for (QMap<QString, QByteArray>::ConstIterator it1 = allResourcesSubDirs.constBegin();
-            it1 != allResourcesSubDirs.constEnd();
-            ++it1) {
-        m_changed = false;
-        m_resourceSubdir = it1.key();
-        m_resource = it1.value();
-
-        QStringList relFiles;
-        const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, m_resourceSubdir, QStandardPaths::LocateDirectory);
-        Q_FOREACH (const QString &dir, dirs) {
-            QDirIterator it(dir, QDirIterator::Subdirectories);
-            while (it.hasNext()) {
-                const QString filePath = it.next();
-                Q_ASSERT(filePath.startsWith(dir)); // due to the line below...
-                const QString relPath = filePath.mid(dir.length() + 1);
-                if (!relFiles.contains(relPath)) {
-                    relFiles.append(relPath);
-                }
-            }
-        }
-        // Now find all factories that use this resource....
-        // For each factory
-        KBSEntryDictList::const_iterator ed_it = entryDictList.begin();
-        const KBSEntryDictList::const_iterator ed_end = entryDictList.end();
-        KSycocaFactoryList::const_iterator it = factories()->constBegin();
-        const KSycocaFactoryList::const_iterator end = factories()->constEnd();
-        for (; it != end; ++it, ++ed_it) {
-            m_currentFactory = (*it);
-            // m_ctimeInfo gets created after the initial loop, so it has no entryDict.
-            m_currentEntryDict = ed_it == ed_end ? 0 : *ed_it;
-            // For each resource the factory deals with
-            const KSycocaResourceList *list = m_currentFactory->resourceList();
-            if (!list) {
-                continue;
-            }
-
-            for (KSycocaResourceList::ConstIterator it2 = list->constBegin();
-                    it2 != list->constEnd();
-                    ++it2) {
-                KSycocaResource res = (*it2);
-                if (res.resource != (*it1)) {
-                    continue;
-                }
-
-                // For each file in the resource
-                for (QStringList::ConstIterator it3 = relFiles.constBegin();
-                        it3 != relFiles.constEnd();
-                        ++it3) {
-                    // Check if file matches filter
-                    if ((*it3).endsWith(res.extension)) {
-                        QString entryPath = (*it3);
-                        createEntry(entryPath, true);
-                    }
-                }
-            }
-        }
-        if (m_changed || !m_allEntries) {
-            uptodate = false;
-            //qDebug() << "CHANGED:" << resource;
-            m_changedResources.append(m_resource);
-        }
-    }
-
-    bool result = !uptodate || (m_ctimeDict && !m_ctimeDict->isEmpty());
-    if (m_ctimeDict && !m_ctimeDict->isEmpty()) {
-        //qDebug() << "Still in time dict:";
-        //m_ctimeDict->dump();
-        // ## It seems entries filtered out by vfolder are still in there,
-        // so we end up always saving ksycoca, i.e. this method never returns false
-
-        // Get the list of resources from which some files were deleted
-        const QStringList resources = m_ctimeDict->remainingResourceList();
-        qDebug() << "Still in the time dict (i.e. deleted files)" << resources;
-        m_changedResources += resources;
-    }
-
-    if (result || bMenuTest) {
-        m_resource = "apps";
-        m_resourceSubdir = QStringLiteral("applications");
-        m_currentFactory = m_serviceFactory;
-        m_currentEntryDict = serviceEntryDict;
-        m_changed = false;
-
-        m_vfolder = new VFolderMenu(m_serviceFactory, this);
-        if (!m_trackId.isEmpty()) {
-            m_vfolder->setTrackId(m_trackId);
-        }
-
-        VFolderMenu::SubMenu *kdeMenu = m_vfolder->parseMenu(QStringLiteral("applications.menu"));
-
-        KServiceGroup::Ptr entry = m_buildServiceGroupFactory->addNew(QStringLiteral("/"), kdeMenu->directoryFile, KServiceGroup::Ptr(), false);
-        entry->setLayoutInfo(kdeMenu->layoutList);
-        createMenu(QString(), QString(), kdeMenu);
-
-        m_allResourceDirs = factoryResourceDirs();
-        m_allResourceDirs += m_vfolder->allDirectories();
-
-        if (m_changed || !m_allEntries) {
-            uptodate = false;
-            //qDebug() << "CHANGED:" << m_resource;
-            m_changedResources.append(m_resource);
-        }
-        if (bMenuTest) {
-            result = false;
-        }
-    }
-
-    qDeleteAll(entryDictList);
-    return result;
-}
-
-void KBuildSycoca::createMenu(const QString &caption_, const QString &name_, VFolderMenu::SubMenu *menu)
-{
-    QString caption = caption_;
-    QString name = name_;
-    foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus) {
-        QString subName = name + subMenu->name + '/';
-
-        QString directoryFile = subMenu->directoryFile;
-        if (directoryFile.isEmpty()) {
-            directoryFile = subName + QStringLiteral(".directory");
-        }
-        quint32 timeStamp = m_ctimeFactory->dict()->ctime(directoryFile, m_resource);
-        if (!timeStamp) {
-            timeStamp = calcResourceHash(m_resourceSubdir, directoryFile);
-        }
-
-        KServiceGroup::Ptr entry;
-        if (m_allEntries) {
-            const quint32 oldTimestamp = m_ctimeDict->ctime(directoryFile, m_resource);
-
-            if (timeStamp && (timeStamp == oldTimestamp)) {
-                KSycocaEntry::Ptr group = m_serviceGroupEntryDict->value(subName);
-                if (group) {
-                    entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(group.data()));
-                    if (entry->directoryEntryPath() != directoryFile) {
-                        entry = 0;    // Can't reuse this one!
-                    }
-                }
-            }
-        }
-        if (timeStamp) { // bug? (see calcResourceHash). There might not be a .directory file...
-            m_ctimeFactory->dict()->addCTime(directoryFile, m_resource, timeStamp);
-        }
-
-        entry = m_buildServiceGroupFactory->addNew(subName, subMenu->directoryFile, entry, subMenu->isDeleted);
-        entry->setLayoutInfo(subMenu->layoutList);
-        if (!(bMenuTest && entry->noDisplay())) {
-            createMenu(caption + entry->caption() + '/', subName, subMenu);
-        }
-    }
-    if (caption.isEmpty()) {
-        caption += '/';
-    }
-    if (name.isEmpty()) {
-        name += '/';
-    }
-    foreach (const KService::Ptr &p, menu->items) {
-        if (bMenuTest) {
-            if (!menu->isDeleted && !p->noDisplay())
-                printf("%s\t%s\t%s\n", qPrintable(caption), qPrintable(p->menuId()),
-                       qPrintable(QStandardPaths::locate(QStandardPaths::ApplicationsLocation, p->entryPath())));
-        } else {
-            m_buildServiceGroupFactory->addNewEntryTo(name, p);
-        }
-    }
-}
-
-bool KBuildSycoca::recreate(bool incremental)
-{
-    QString path(sycocaPath());
-
-    QByteArray qSycocaPath = QFile::encodeName(path);
-    s_cSycocaPath = qSycocaPath.data();
-
-    m_allEntries = 0;
-    m_ctimeDict = 0;
-    if (incremental) {
-        qDebug() << "Reusing existing ksycoca";
-        KSycoca *oldSycoca = KSycoca::self();
-        m_allEntries = new KSycocaEntryListList;
-        m_ctimeDict = new KCTimeDict;
-
-        // Must be in same order as in KBuildSycoca::recreate()!
-        m_allEntries->append(KServiceTypeFactory::self()->allEntries());
-        m_allEntries->append(KMimeTypeFactory::self()->allEntries());
-        m_allEntries->append(KServiceGroupFactory::self()->allEntries());
-        m_allEntries->append(KServiceFactory::self()->allEntries());
-
-        KCTimeFactory *ctimeInfo = new KCTimeFactory(oldSycoca);
-        *m_ctimeDict = ctimeInfo->loadDict();
-    }
-    s_cSycocaPath = 0;
-
-    QSaveFile database(path);
-    bool openedOK = database.open(QIODevice::WriteOnly);
-
-    if (!openedOK && database.error() == QFile::WriteError && QFile::exists(path)) {
-        QFile::remove(path);
-        openedOK = database.open(QIODevice::WriteOnly);
-    }
-    if (!openedOK) {
-        fprintf(stderr, KBUILDSYCOCA_EXENAME ": ERROR creating database '%s'! %s\n",
-                path.toLocal8Bit().data(), database.errorString().toLocal8Bit().data());
-        return false;
-    }
-
-    QDataStream *str = new QDataStream(&database);
-    str->setVersion(QDataStream::Qt_5_3);
-
-    qDebug().nospace() << "Recreating ksycoca file (" << path << ", version " << KSycoca::version() << ")";
-
-    // It is very important to build the servicetype one first
-    KBuildServiceTypeFactory *stf = new KBuildServiceTypeFactory(this);
-    KBuildMimeTypeFactory *mimeTypeFactory = new KBuildMimeTypeFactory(this);
-    m_buildServiceGroupFactory = new KBuildServiceGroupFactory(this);
-    m_serviceFactory = new KBuildServiceFactory(stf, mimeTypeFactory, m_buildServiceGroupFactory);
-
-    if (build()) { // Parse dirs
-        save(str); // Save database
-        if (str->status() != QDataStream::Ok) { // Probably unnecessary now in Qt5, since QSaveFile detects write errors
-            database.cancelWriting();    // Error
-        }
-        delete str;
-        str = 0;
-
-        //if we are currently via sudo, preserve the original owner
-        //as $HOME may also be that of another user rather than /root
-#ifdef Q_OS_UNIX
-        if (qEnvironmentVariableIsSet("SUDO_UID")) {
-            const int uid = QString(qgetenv("SUDO_UID")).toInt();
-            const int gid = QString(qgetenv("SUDO_GID")).toInt();
-            if (uid && gid) {
-                fchown(database.handle(), uid, gid);
-            }
-        }
-#endif
-
-        if (!database.commit()) {
-            fprintf(stderr, KBUILDSYCOCA_EXENAME ": ERROR writing database '%s'!\n", database.fileName().toLocal8Bit().data());
-            fprintf(stderr, KBUILDSYCOCA_EXENAME ": Disk full?\n");
-            return false;
-        }
-    } else {
-        delete str;
-        str = 0;
-        database.cancelWriting();
-        if (bMenuTest) {
-            return true;
-        }
-        qDebug() << "Database is up to date";
-    }
-
-    if (!bGlobalDatabase) {
-        // update the timestamp file
-        QString stamppath = path + QStringLiteral("stamp");
-        QFile ksycocastamp(stamppath);
-        ksycocastamp.open(QIODevice::WriteOnly);
-        QDataStream str(&ksycocastamp);
-        str.setVersion(QDataStream::Qt_5_3);
-        str << newTimestamp;
-        str << existingResourceDirs();
-        if (m_vfolder) {
-            str << m_vfolder->allDirectories();    // Extra resource dirs
-        }
-    }
-    if (d->m_sycocaStrategy == KSycocaPrivate::StrategyMemFile) {
-        KMemFile::fileContentsChanged(path);
-    }
-
-    return true;
-}
-
-void KBuildSycoca::save(QDataStream *str)
-{
-    // Write header (#pass 1)
-    str->device()->seek(0);
-
-    (*str) << qint32(KSycoca::version());
-    //KSycocaFactory * servicetypeFactory = 0;
-    //KBuildMimeTypeFactory * mimeTypeFactory = 0;
-    KBuildServiceFactory *serviceFactory = 0;
-    for (KSycocaFactoryList::Iterator factory = factories()->begin();
-            factory != factories()->end();
-            ++factory) {
-        qint32 aId;
-        qint32 aOffset;
-        aId = (*factory)->factoryId();
-        //if ( aId == KST_KServiceTypeFactory )
-        //   servicetypeFactory = *factory;
-        //else if ( aId == KST_KMimeTypeFactory )
-        //   mimeTypeFactory = static_cast<KBuildMimeTypeFactory *>( *factory );
-        if (aId == KST_KServiceFactory) {
-            serviceFactory = static_cast<KBuildServiceFactory *>(*factory);
-        }
-        aOffset = (*factory)->offset(); // not set yet, so always 0
-        (*str) << aId;
-        (*str) << aOffset;
-    }
-    (*str) << qint32(0); // No more factories.
-    // Write XDG_DATA_DIRS
-    (*str) << QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).join(QString(QLatin1Char(':')));
-    (*str) << newTimestamp;
-    (*str) << QLocale().bcp47Name();
-    // This makes it possible to trigger a ksycoca update for all users (KIOSK feature)
-    (*str) << calcResourceHash(QStringLiteral("kservices5"), QStringLiteral("update_ksycoca"));
-    (*str) << m_allResourceDirs;
-
-    // Calculate per-servicetype/mimetype data
-    if (serviceFactory) serviceFactory->postProcessServices();
-
-    // Here so that it's the last debug message
-    qDebug() << "Saving";
-
-    // Write factory data....
-    for (KSycocaFactoryList::Iterator factory = factories()->begin();
-            factory != factories()->end();
-            ++factory) {
-        (*factory)->save(*str);
-        if (str->status() != QDataStream::Ok) { // ######## TODO: does this detect write errors, e.g. disk full?
-            return;    // error
-        }
-    }
-
-    int endOfData = str->device()->pos();
-
-    // Write header (#pass 2)
-    str->device()->seek(0);
-
-    (*str) << qint32(KSycoca::version());
-    for (KSycocaFactoryList::Iterator factory = factories()->begin();
-            factory != factories()->end(); ++factory) {
-        qint32 aId;
-        qint32 aOffset;
-        aId = (*factory)->factoryId();
-        aOffset = (*factory)->offset();
-        (*str) << aId;
-        (*str) << aOffset;
-    }
-    (*str) << qint32(0); // No more factories.
-
-    // Jump to end of database
-    str->device()->seek(endOfData);
-}
-
-static bool checkDirTimestamps(const QString &dirname, const QDateTime &stamp)
-{
-    QDir dir(dirname);
-    const QFileInfoList list = dir.entryInfoList(QDir::NoFilter, QDir::Unsorted);
-    if (list.isEmpty()) {
-        return true;
-    }
-
-    foreach (const QFileInfo &fi, list) {
-        if (fi.fileName() == "." || fi.fileName() == "..") {
-            continue;
-        }
-        if (fi.lastModified() > stamp) {
-            qDebug() << "timestamp changed:" << fi.filePath() << fi.lastModified() << ">" << stamp;
-            return false;
-        }
-        if (fi.isDir() && !checkDirTimestamps(fi.filePath(), stamp)) {
-            return false;
-        }
-    }
-    return true;
-}
-
-// check times of last modification of all files on which ksycoca depends,
-// and also their directories
-// if all of them are older than the timestamp in file ksycocastamp, this
-// means that there's no need to rebuild ksycoca
-static bool checkTimestamps(qint64 timestamp, const QStringList &dirs)
-{
-    qDebug() << "checking file timestamps";
-    const QDateTime stamp = QDateTime::fromMSecsSinceEpoch(timestamp);
-    for (QStringList::ConstIterator it = dirs.begin();
-            it != dirs.end();
-            ++it) {
-        QFileInfo inf(*it);
-        if (inf.lastModified() > stamp) {
-            qDebug() << "timestamp changed:" << *it;
-            return false;
-        }
-        if (!checkDirTimestamps(*it, stamp)) {
-            return false;
-        }
-    }
-    qDebug() << "timestamps check ok";
-    return true;
-}
-
-QStringList KBuildSycoca::factoryResourceDirs()
-{
-    static QStringList *dirs = NULL;
-    if (dirs != NULL) {
-        return *dirs;
-    }
-    dirs = new QStringList;
-    // these are all resource dirs cached by ksycoca
-    *dirs += KServiceTypeFactory::resourceDirs();
-    *dirs += KMimeTypeFactory::resourceDirs();
-    *dirs += KServiceFactory::resourceDirs();
-
-    return *dirs;
-}
-
-QStringList KBuildSycoca::existingResourceDirs()
-{
-    static QStringList *dirs = NULL;
-    if (dirs != NULL) {
-        return *dirs;
-    }
-    dirs = new QStringList(factoryResourceDirs());
-
-    for (QStringList::Iterator it = dirs->begin();
-            it != dirs->end();) {
-        QFileInfo inf(*it);
-        if (!inf.exists() || !inf.isReadable()) {
-            it = dirs->erase(it);
-        } else {
-            ++it;
-        }
-    }
-    return *dirs;
-}
-
-static const char appFullName[] = "org.kde.kbuildsycoca";
-
-int main(int argc, char **argv)
-{
-    QCoreApplication app(argc, argv);
-
-    KLocalizedString::setApplicationDomain("kservice5");
-
-    KAboutData about(KBUILDSYCOCA_EXENAME,
-                     i18nc("application name", "KBuildSycoca"),
-                     QStringLiteral(KSERVICE_VERSION_STRING),
-                     i18nc("application description", "Rebuilds the system configuration cache."),
-                     KAboutLicense::GPL,
-                     i18nc("@info:credit", "Copyright 1999-2014 KDE Developers"));
-    about.addAuthor(i18nc("@info:credit", "David Faure"),
-                    i18nc("@info:credit", "Author"),
-                    QStringLiteral("faure@kde.org"));
-    about.addAuthor(i18nc("@info:credit", "Waldo Bastian"),
-                    i18nc("@info:credit", "Author"),
-                    QStringLiteral("bastian@kde.org"));
-    KAboutData::setApplicationData(about);
-
-    QCommandLineParser parser;
-    about.setupCommandLine(&parser);
-    parser.addVersionOption();
-    parser.addHelpOption();
-    parser.addOption(QCommandLineOption(QStringLiteral("nosignal"),
-                i18nc("@info:shell command-line option",
-                      "Do not signal applications to update")));
-    parser.addOption(QCommandLineOption(QStringLiteral("noincremental"),
-                i18nc("@info:shell command-line option",
-                      "Disable incremental update, re-read everything")));
-    parser.addOption(QCommandLineOption(QStringLiteral("checkstamps"),
-                i18nc("@info:shell command-line option",
-                      "Check file timestamps")));
-    parser.addOption(QCommandLineOption(QStringLiteral("nocheckfiles"),
-                i18nc("@info:shell command-line option",
-                      "Disable checking files (dangerous)")));
-    parser.addOption(QCommandLineOption(QStringLiteral("global"),
-                i18nc("@info:shell command-line option",
-                      "Create global database")));
-    parser.addOption(QCommandLineOption(QStringLiteral("menutest"),
-                i18nc("@info:shell command-line option",
-                      "Perform menu generation test run only")));
-    parser.addOption(QCommandLineOption(QStringLiteral("track"),
-                i18nc("@info:shell command-line option",
-                      "Track menu id for debug purposes"),
-                QStringLiteral("menu-id")));
-    parser.addOption(QCommandLineOption(QStringLiteral("testmode"),
-                i18nc("@info:shell command-line option",
-                      "Switch QStandardPaths to test mode, for unit tests only")));
-    parser.process(app);
-    about.processCommandLine(&parser);
-
-    bGlobalDatabase = parser.isSet(QStringLiteral("global"));
-    bMenuTest = parser.isSet(QStringLiteral("menutest"));
-
-    if (parser.isSet(QStringLiteral("testmode"))) {
-        QStandardPaths::enableTestMode(true);
-    }
-
-    if (bGlobalDatabase) {
-        // Qt uses XDG_DATA_HOME as first choice for GenericDataLocation so we set it to 2nd entry
-        QStringList paths = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation);
-        if (paths.size() >= 2) {
-            qputenv("XDG_DATA_HOME", paths.at(1).toLocal8Bit());
-        }
-    }
-
-    KCrash::setEmergencySaveFunction(crashHandler);
-
-    while (QDBusConnection::sessionBus().isConnected()) {
-        // Detect already-running kbuildsycoca instances using DBus.
-        if (QDBusConnection::sessionBus().interface()->registerService(appFullName, QDBusConnectionInterface::QueueService)
-                != QDBusConnectionInterface::ServiceQueued) {
-            break; // Go
-        }
-        fprintf(stderr, "Waiting for already running %s to finish.\n", KBUILDSYCOCA_EXENAME);
-
-        QEventLoop eventLoop;
-        QObject::connect(QDBusConnection::sessionBus().interface(), SIGNAL(serviceRegistered(QString)),
-                         &eventLoop, SLOT(quit()));
-        eventLoop.exec(QEventLoop::ExcludeUserInputEvents);
-    }
-    fprintf(stderr, "%s running...\n", KBUILDSYCOCA_EXENAME);
-
-    bool checkfiles = bGlobalDatabase || !parser.isSet(QStringLiteral("nocheckfiles"));
-
-    bool incremental = !bGlobalDatabase && !parser.isSet(QStringLiteral("noincremental")) && checkfiles;
-    if (incremental || !checkfiles) {
-        KSycoca::disableAutoRebuild(); // Prevent deadlock
-        if (!KBuildSycoca::checkGlobalHeader()) {
-            incremental = false;
-            checkfiles = true;
-            KBuildSycoca::clearCaches();
-        }
-    }
-
-    bool checkstamps = incremental && parser.isSet(QStringLiteral("checkstamps")) && checkfiles;
-    qint64 filestamp = 0;
-    QStringList oldresourcedirs;
-    if (checkstamps && incremental) {
-        QString path = sycocaPath() + QStringLiteral("stamp");
-        QByteArray qPath = QFile::encodeName(path);
-        s_cSycocaPath = qPath.data(); // Delete timestamps on crash
-        QFile ksycocastamp(path);
-        if (ksycocastamp.open(QIODevice::ReadOnly)) {
-            QDataStream str(&ksycocastamp);
-            str.setVersion(QDataStream::Qt_5_3);
-
-            if (!str.atEnd()) {
-                str >> filestamp;
-            }
-            if (!str.atEnd()) {
-                str >> oldresourcedirs;
-                if (oldresourcedirs != KBuildSycoca::existingResourceDirs()) {
-                    checkstamps = false;
-                }
-            } else {
-                checkstamps = false;
-            }
-            if (!str.atEnd()) {
-                QStringList extraResourceDirs;
-                str >> extraResourceDirs;
-                oldresourcedirs += extraResourceDirs;
-            }
-        } else {
-            checkstamps = false;
-        }
-        s_cSycocaPath = 0;
-    }
-
-    newTimestamp = QDateTime::currentMSecsSinceEpoch();
-    QStringList changedResources;
-
-    if (checkfiles && (!checkstamps || !checkTimestamps(filestamp, oldresourcedirs))) {
-
-        KBuildSycoca sycoca; // Build data base
-        if (parser.isSet(QStringLiteral("track"))) {
-            sycoca.setTrackId(parser.value(QStringLiteral("track")));
-        }
-        if (!sycoca.recreate(incremental)) {
-            return -1;
-        }
-        changedResources = sycoca.changedResources();
-
-        if (bGlobalDatabase) {
-            // These directories may have been created with 0700 permission
-            // better delete them if they are empty
-            QString appsDir = QStandardPaths::writableLocation(QStandardPaths::ApplicationsLocation);
-            QDir().remove(appsDir);
-            // was doing the same with servicetypes, but I don't think any of these gets created-by-mistake anymore.
-        }
-    }
-
-    if (!parser.isSet(QStringLiteral("nosignal"))) {
-        // Notify ALL applications that have a ksycoca object, using a signal
-        QDBusMessage signal = QDBusMessage::createSignal("/", "org.kde.KSycoca", "notifyDatabaseChanged");
-        signal << changedResources;
-
-        if (QDBusConnection::sessionBus().isConnected()) {
-            qDebug() << "Emitting notifyDatabaseChanged" << changedResources;
-            QDBusConnection::sessionBus().send(signal);
-            qApp->processEvents(); // make sure the dbus signal is sent before we quit.
-        }
-    }
-
-    return 0;
-}
-
-static quint32 updateHash(const QString &file, quint32 hash)
-{
-    QFileInfo fi(file);
-    if (fi.isReadable() && fi.isFile()) {
-        // This was using buff.st_ctime (in Waldo's initial commit to kstandarddirs.cpp in 2001), but that looks wrong?
-        // Surely we want to catch manual editing, while a chmod doesn't matter much?
-        hash += fi.lastModified().toTime_t();
-    }
-    return hash;
-}
-
-quint32 KBuildSycoca::calcResourceHash(const QString &resourceSubDir, const QString &filename)
-{
-    quint32 hash = 0;
-    if (!QDir::isRelativePath(filename)) {
-        return updateHash(filename, hash);
-    }
-    const QStringList files = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, resourceSubDir + QLatin1Char('/') + filename);
-    Q_FOREACH (const QString &file, files) {
-        hash = updateHash(file, hash);
-    }
-    if (hash == 0 && !filename.endsWith(QLatin1String("update_ksycoca"))
-            && !filename.endsWith(QLatin1String(".directory")) // bug? needs investigation from someone who understands the VFolder spec
-       ) {
-        qWarning() << "File not found or not readable:" << filename << "found:" << files;
-        Q_ASSERT(hash != 0);
-    }
-    return hash;
-}
-
-bool KBuildSycoca::checkGlobalHeader()
-{
-    const QString current_language = QLocale().bcp47Name();
-    const quint32 current_update_sig = KBuildSycoca::calcResourceHash(QStringLiteral("kservices5"), QStringLiteral("update_ksycoca"));
-    const QString current_prefixes = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).join(QString(QLatin1Char(':')));
-
-    const KSycocaHeader header = KSycoca::self()->readSycocaHeader();
-    Q_ASSERT(!header.prefixes.split(':').contains(QDir::homePath()));
-
-    return (current_update_sig == header.updateSignature) &&
-            (current_language == header.language) &&
-            (current_prefixes == header.prefixes) &&
-            (header.timeStamp != 0);
-}
diff --git a/src/kbuildsycoca/kbuildsycoca.h b/src/kbuildsycoca/kbuildsycoca.h
deleted file mode 100644
index 2ac578c..0000000
--- a/src/kbuildsycoca/kbuildsycoca.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 1999 David Faure <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-#ifndef KDED_KBUILDSYCOCA_H
-#define KDED_KBUILDSYCOCA_H
-
-#include "kbuildsycocainterface.h"
-
-#include <sys/stat.h>
-
-#include <QtCore/QObject>
-#include <QtCore/QString>
-
-#include <kservice.h>
-#include <ksycoca.h>
-#include <ksycocatype.h>
-#include <ksycocaentry.h>
-#include <kservicegroup.h>
-
-#include "vfolder_menu.h"
-
-class QDataStream;
-class KCTimeFactory;
-class KCTimeDict;
-
-class KBuildSycoca : public KSycoca, public KBuildSycocaInterface
-{
-    Q_OBJECT
-public:
-    KBuildSycoca();
-    virtual ~KBuildSycoca();
-
-    /**
-     * Recreate the database file
-     */
-    bool recreate(bool incremental);
-
-    static QStringList factoryResourceDirs();
-    static QStringList existingResourceDirs();
-
-    void setTrackId(const QString &id)
-    {
-        m_trackId = id;
-    }
-
-    QStringList changedResources() const
-    {
-        return m_changedResources;
-    }
-
-    // Use our friendly-access-to-KSycoca to make this public
-    static void clearCaches()
-    {
-        KSycoca::clearCaches();
-    }
-
-    /**
-     * Returns a number that identifies the current version of the file @p filename,
-     * which is located under GenericDataLocation (including local overrides).
-     *
-     * When a change is made to the file this number will change.
-     */
-    static quint32 calcResourceHash(const QString &subdir, const QString &filename);
-
-    /**
-     * Compare our current settings (language, prefixes...) with the ones from the existing ksycoca global header.
-     * @return true if they match (= we can reuse this ksycoca), false otherwise (full build)
-     */
-    static bool checkGlobalHeader();
-
-private:
-    /**
-     * Add single entry to the sycoca database.
-     * Either from a previous database or regenerated from file.
-     */
-    KSycocaEntry::Ptr createEntry(const QString &file, bool addToFactory);
-
-    /**
-     * Implementation of KBuildSycocaInterface
-     * Create service and return it. The caller must add it to the servicefactory.
-     */
-    /*! \reimp */ KService::Ptr createService(const QString &path);
-
-    /**
-     * Convert a VFolderMenu::SubMenu to KServiceGroups.
-     */
-    void createMenu(const QString &caption, const QString &name, VFolderMenu::SubMenu *menu);
-
-    /**
-     * Build the whole system cache, from .desktop files
-     */
-    bool build();
-
-    /**
-     * Save the ksycoca file
-     */
-    void save(QDataStream *str);
-
-    /**
-     * Clear the factories
-     */
-    void clear();
-
-    /**
-     * @internal
-     * @return true if building (i.e. if a KBuildSycoca);
-     */
-    virtual bool isBuilding()
-    {
-        return true;
-    }
-
-    QStringList m_changedResources;
-    QStringList m_allResourceDirs;
-    QString m_trackId;
-
-    QByteArray m_resource; // e.g. "services" (old resource name, now only used for the signal, see kctimefactory.cpp)
-    QString m_resourceSubdir; // e.g. "kservices5" (xdgdata subdir)
-
-    KSycocaEntry::List m_tempStorage;
-    typedef QList<KSycocaEntry::List> KSycocaEntryListList;
-    KSycocaEntryListList *m_allEntries; // entries from existing ksycoca
-    KBuildServiceFactory *m_serviceFactory;
-    KBuildServiceGroupFactory *m_buildServiceGroupFactory;
-    KSycocaFactory *m_currentFactory;
-    KCTimeFactory *m_ctimeFactory;
-    KCTimeDict *m_ctimeDict; // old timestamps
-    typedef QHash<QString, KSycocaEntry::Ptr> KBSEntryDict;
-    KBSEntryDict *m_currentEntryDict;
-    KBSEntryDict *m_serviceGroupEntryDict;
-    VFolderMenu *m_vfolder;
-
-    bool m_changed;
-};
-
-#endif
diff --git a/src/kbuildsycoca/kbuildsycoca_main.cpp b/src/kbuildsycoca/kbuildsycoca_main.cpp
new file mode 100644
index 0000000..3292748
--- /dev/null
+++ b/src/kbuildsycoca/kbuildsycoca_main.cpp
@@ -0,0 +1,132 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999 David Faure <faure@kde.org>
+ *  Copyright (C) 2002-2003 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include <kbuildsycoca_p.h>
+
+#include "../../kservice_version.h"
+
+#include <klocalizedstring.h>
+#include <kaboutdata.h>
+#include <kcrash.h>
+
+#include <QCommandLineOption>
+#include <QCommandLineParser>
+#include <QCoreApplication>
+#include <QStandardPaths>
+#include <QFile>
+#include <QDebug>
+#include <QDir>
+#include <QDateTime>
+#include <QFileInfo>
+
+#include <unistd.h> // for unlink
+
+static void crashHandler(int)
+{
+    // If we crash while reading sycoca, we delete the database
+    // in an attempt to recover.
+    if (KBuildSycoca::sycocaPath()) {
+        unlink(KBuildSycoca::sycocaPath());
+    }
+}
+
+int main(int argc, char **argv)
+{
+    QCoreApplication app(argc, argv);
+
+    KLocalizedString::setApplicationDomain("kservice5");
+
+    KAboutData about(KBUILDSYCOCA_EXENAME,
+                     i18nc("application name", "KBuildSycoca"),
+                     QStringLiteral(KSERVICE_VERSION_STRING),
+                     i18nc("application description", "Rebuilds the system configuration cache."),
+                     KAboutLicense::GPL,
+                     i18nc("@info:credit", "Copyright 1999-2014 KDE Developers"));
+    about.addAuthor(i18nc("@info:credit", "David Faure"),
+                    i18nc("@info:credit", "Author"),
+                    QStringLiteral("faure@kde.org"));
+    about.addAuthor(i18nc("@info:credit", "Waldo Bastian"),
+                    i18nc("@info:credit", "Author"),
+                    QStringLiteral("bastian@kde.org"));
+    KAboutData::setApplicationData(about);
+
+    QCommandLineParser parser;
+    about.setupCommandLine(&parser);
+    parser.addVersionOption();
+    parser.addHelpOption();
+    parser.addOption(QCommandLineOption(QStringLiteral("nosignal"),
+                i18nc("@info:shell command-line option",
+                      "Do not signal applications to update (deprecated, no longer having any effect)")));
+    parser.addOption(QCommandLineOption(QStringLiteral("noincremental"),
+                i18nc("@info:shell command-line option",
+                      "Disable incremental update, re-read everything")));
+    parser.addOption(QCommandLineOption(QStringLiteral("checkstamps"),
+                i18nc("@info:shell command-line option",
+                      "Check file timestamps (deprecated, no longer having any effect)")));
+    parser.addOption(QCommandLineOption(QStringLiteral("nocheckfiles"),
+                i18nc("@info:shell command-line option",
+                      "Disable checking files (deprecated, no longer having any effect)")));
+    parser.addOption(QCommandLineOption(QStringLiteral("global"),
+                i18nc("@info:shell command-line option",
+                      "Create global database")));
+    parser.addOption(QCommandLineOption(QStringLiteral("menutest"),
+                i18nc("@info:shell command-line option",
+                      "Perform menu generation test run only")));
+    parser.addOption(QCommandLineOption(QStringLiteral("track"),
+                i18nc("@info:shell command-line option",
+                      "Track menu id for debug purposes"),
+                QStringLiteral("menu-id")));
+    parser.addOption(QCommandLineOption(QStringLiteral("testmode"),
+                i18nc("@info:shell command-line option",
+                      "Switch QStandardPaths to test mode, for unit tests only")));
+    parser.process(app);
+    about.processCommandLine(&parser);
+
+    const bool bGlobalDatabase = parser.isSet(QStringLiteral("global"));
+    const bool bMenuTest = parser.isSet(QStringLiteral("menutest"));
+
+    if (parser.isSet(QStringLiteral("testmode"))) {
+        QStandardPaths::enableTestMode(true);
+    }
+
+    if (bGlobalDatabase) {
+        // Qt uses XDG_DATA_HOME as first choice for GenericDataLocation so we set it to 2nd entry
+        QStringList paths = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation);
+        if (paths.size() >= 2) {
+            qputenv("XDG_DATA_HOME", paths.at(1).toLocal8Bit());
+        }
+    }
+
+    KCrash::setEmergencySaveFunction(crashHandler);
+
+    fprintf(stderr, "%s running...\n", KBUILDSYCOCA_EXENAME);
+
+    const bool incremental = !bGlobalDatabase && !parser.isSet(QStringLiteral("noincremental"));
+
+    KBuildSycoca sycoca(bGlobalDatabase); // Build data base
+    if (parser.isSet(QStringLiteral("track"))) {
+        sycoca.setTrackId(parser.value(QStringLiteral("track")));
+    }
+    sycoca.setMenuTest(bMenuTest);
+    if (!sycoca.recreate(incremental)) {
+        return -1;
+    }
+
+    return 0;
+}
diff --git a/src/kbuildsycoca/kbuildsycocainterface.h b/src/kbuildsycoca/kbuildsycocainterface.h
deleted file mode 100644
index 337f8d0..0000000
--- a/src/kbuildsycoca/kbuildsycocainterface.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* This file is part of the KDE libraries
-    Copyright (c) 2009 David Faure <faure@kde.org>
-
-    This library is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License or ( at
-    your option ) version 3 or, at the discretion of KDE e.V. ( which shall
-    act as a proxy as in section 14 of the GPLv3 ), any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-#ifndef KBUILDSYCOCAINTERFACE_H
-#define KBUILDSYCOCAINTERFACE_H
-
-#include <kservice.h>
-
-class KBuildSycocaInterface
-{
-public:
-    virtual ~KBuildSycocaInterface();
-    virtual KService::Ptr createService(const QString &path) = 0;
-};
-
-#endif /* KBUILDSYCOCAINTERFACE_H */
diff --git a/src/kbuildsycoca/kctimefactory.cpp b/src/kbuildsycoca/kctimefactory.cpp
deleted file mode 100644
index 2236b08..0000000
--- a/src/kbuildsycoca/kctimefactory.cpp
+++ /dev/null
@@ -1,140 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "kctimefactory.h"
-#include <ksycoca.h>
-#include <ksycocautils_p.h>
-#include <ksycocatype.h>
-#include <QDebug>
-
-#include <assert.h>
-
-// NOTE: the storing of "resource" here is now completely useless (since everything is under GenericDataLocation),
-// except for remainingResourceList() which is used for the compat signal databaseChanged(...)
-// We could possibly replace this with a subdir->old_resource mapping (applications -> apps, kservices5 -> services, etc.)
-// Alternatively, we could use an enum in the signal...
-
-static inline QString key(const QString &path, const QByteArray &resource)
-{
-    return QString::fromLatin1(resource) + QLatin1Char('|') + path;
-}
-
-void KCTimeDict::addCTime(const QString &path, const QByteArray &resource, quint32 ctime)
-{
-    Q_ASSERT(ctime != 0);
-    assert(!path.isEmpty());
-    m_hash.insert(key(path, resource), ctime);
-}
-
-quint32 KCTimeDict::ctime(const QString &path, const QByteArray &resource) const
-{
-    return m_hash.value(key(path, resource), 0);
-}
-
-void KCTimeDict::remove(const QString &path, const QByteArray &resource)
-{
-    m_hash.remove(key(path, resource));
-}
-
-void KCTimeDict::dump() const
-{
-    qDebug() << m_hash.keys();
-}
-
-QStringList KCTimeDict::remainingResourceList() const
-{
-    QSet<QString> resources;
-    Hash::const_iterator it = m_hash.constBegin();
-    const Hash::const_iterator end = m_hash.constEnd();
-    for (; it != end; ++it) {
-        const QString key = it.key();
-        const QString res = key.left(key.indexOf('|'));
-        resources.insert(res);
-    }
-    return resources.toList();
-}
-
-void KCTimeDict::load(QDataStream &str)
-{
-    QString key;
-    quint32 ctime;
-    while (true) {
-        KSycocaUtilsPrivate::read(str, key);
-        str >> ctime;
-        if (key.isEmpty()) {
-            break;
-        }
-        m_hash.insert(key, ctime);
-    }
-}
-
-void KCTimeDict::save(QDataStream &str) const
-{
-    Hash::const_iterator it = m_hash.constBegin();
-    const Hash::const_iterator end = m_hash.constEnd();
-    for (; it != end; ++it) {
-        str << it.key() << it.value();
-    }
-    str << QString() << quint32(0);
-}
-
-///////////
-
-KCTimeFactory::KCTimeFactory(KSycoca *db)
-    : KSycocaFactory(KST_CTimeInfo, db), m_ctimeDict()
-{
-    if (!sycoca()->isBuilding()) {
-        QDataStream *str = stream();
-        (*str) >> m_dictOffset;
-    } else {
-        m_dictOffset = 0;
-    }
-}
-
-KCTimeFactory::~KCTimeFactory()
-{
-}
-
-void
-KCTimeFactory::saveHeader(QDataStream &str)
-{
-    KSycocaFactory::saveHeader(str);
-
-    str << m_dictOffset;
-}
-
-void KCTimeFactory::save(QDataStream &str)
-{
-    KSycocaFactory::save(str);
-
-    m_dictOffset = str.device()->pos();
-    m_ctimeDict.save(str);
-    const int endOfFactoryData = str.device()->pos();
-    saveHeader(str);
-    str.device()->seek(endOfFactoryData);
-}
-
-KCTimeDict KCTimeFactory::loadDict() const
-{
-    KCTimeDict dict;
-    QDataStream *str = stream();
-    assert(str);
-    str->device()->seek(m_dictOffset);
-    dict.load(*str);
-    return dict;
-}
diff --git a/src/kbuildsycoca/kctimefactory.h b/src/kbuildsycoca/kctimefactory.h
deleted file mode 100644
index a6d2afc..0000000
--- a/src/kbuildsycoca/kctimefactory.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License version 2as published by the Free Software Foundation.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_KCTIME_FACTORY_H
-#define KDED_KCTIME_FACTORY_H
-
-#include <ksycocafactory_p.h>
-#include <QtCore/QHash>
-
-/**
- * Simple dict for assocating a timestamp with each file in ksycoca
- */
-class KCTimeDict
-{
-public:
-    void addCTime(const QString &path, const QByteArray &resource, quint32 ctime);
-    quint32 ctime(const QString &path, const QByteArray &resource) const;
-    void remove(const QString &path, const QByteArray &resource);
-    void dump() const;
-    bool isEmpty() const
-    {
-        return m_hash.isEmpty();
-    }
-    QStringList remainingResourceList() const;
-
-    void load(QDataStream &str);
-    void save(QDataStream &str) const;
-private:
-    typedef QHash<QString, quint32> Hash;
-    Hash m_hash;
-};
-
-/**
- * Internal factory for storing the timestamp of each file in ksycoca
- * @internal
- */
-class KCTimeFactory : public KSycocaFactory
-{
-    K_SYCOCAFACTORY(KST_CTimeInfo)
-public:
-    /**
-     * Create factory
-     */
-    KCTimeFactory(KSycoca *db);
-
-    virtual ~KCTimeFactory();
-
-    /**
-     * Write out header information
-     */
-    virtual void saveHeader(QDataStream &str);
-
-    /**
-     * Write out data
-     */
-    virtual void save(QDataStream &str);
-
-    KSycocaEntry *createEntry(const QString &) const
-    {
-        return 0;
-    }
-    KSycocaEntry *createEntry(int) const
-    {
-        return 0;
-    }
-
-    // Loads the dict and returns it; does not set m_ctimeDict;
-    // this is only used in incremental mode for loading the old timestamps.
-    KCTimeDict loadDict() const;
-
-    // The API for inserting/looking up entries is in KCTimeDict.
-    KCTimeDict *dict()
-    {
-        return &m_ctimeDict;
-    }
-
-private:
-    KCTimeDict m_ctimeDict;
-    int m_dictOffset;
-};
-
-#endif
diff --git a/src/kbuildsycoca/kmimeassociations.cpp b/src/kbuildsycoca/kmimeassociations.cpp
deleted file mode 100644
index 90632b1..0000000
--- a/src/kbuildsycoca/kmimeassociations.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright 2008  David Faure  <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2 of the License or ( at
- *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
- *  act as a proxy as in section 14 of the GPLv3 ), any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- */
-
-#include "kmimeassociations.h"
-#include <kservice.h>
-#include <kservicefactory_p.h>
-#include <kconfiggroup.h>
-#include <kconfig.h>
-#include <QDebug>
-#include <qstandardpaths.h>
-#include <qmimedatabase.h>
-
-KMimeAssociations::KMimeAssociations(KOfferHash &offerHash, KServiceFactory *serviceFactory)
-    : m_offerHash(offerHash), m_serviceFactory(serviceFactory)
-{
-}
-
-/*
-
-The goal of this class is to parse mimeapps.list files, which are used to
-let users configure the application-mimetype associations.
-
-Example file:
-
-[Added Associations]
-text/plain=kate.desktop;
-
-[Removed Associations]
-text/plain=gnome-gedit.desktop;gnu-emacs.desktop;
-
-*/
-
-bool KMimeAssociations::parseAllMimeAppsList()
-{
-    const QString MIMEAPPS_LIST=QStringLiteral("mimeapps.list");
-    // Using the "merged view" from KConfig is not enough since we -add- at every level, we don't replace.
-    const QStringList mimeappsFiles = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, MIMEAPPS_LIST)
-                                    + QStandardPaths::locateAll(QStandardPaths::ApplicationsLocation, MIMEAPPS_LIST);
-    if (mimeappsFiles.isEmpty()) {
-        return false;
-    }
-
-    int basePreference = 1000; // start high :)
-    QListIterator<QString> mimeappsIter(mimeappsFiles);
-    mimeappsIter.toBack();
-    while (mimeappsIter.hasPrevious()) { // global first, then local.
-        const QString mimeappsFile = mimeappsIter.previous();
-        //qDebug() << "Parsing" << mimeappsFile;
-        parseMimeAppsList(mimeappsFile, basePreference);
-        basePreference += 50;
-    }
-    return true;
-}
-
-void KMimeAssociations::parseMimeAppsList(const QString &file, int basePreference)
-{
-    KConfig profile(file, KConfig::SimpleConfig);
-    parseAddedAssociations(KConfigGroup(&profile, "Added Associations"), file, basePreference);
-    parseRemovedAssociations(KConfigGroup(&profile, "Removed Associations"), file);
-
-    // KDE extension for parts and plugins, see settings/filetypes/mimetypedata.cpp
-    parseAddedAssociations(KConfigGroup(&profile, "Added KDE Service Associations"), file, basePreference);
-    parseRemovedAssociations(KConfigGroup(&profile, "Removed KDE Service Associations"), file);
-}
-
-void KMimeAssociations::parseAddedAssociations(const KConfigGroup &group, const QString &file, int basePreference)
-{
-    Q_UNUSED(file) // except in debug statements
-    QMimeDatabase db;
-    Q_FOREACH (const QString &mimeName, group.keyList()) {
-        const QStringList services = group.readXdgListEntry(mimeName);
-        const QString resolvedMimeName = db.mimeTypeForName(mimeName).name();
-        if (resolvedMimeName.isEmpty()) {
-            //qDebug() << file << "specifies unknown mimeType" << mimeName << "in" << group.name();
-        } else {
-            int pref = basePreference;
-            Q_FOREACH (const QString &service, services) {
-                KService::Ptr pService = m_serviceFactory->findServiceByStorageId(service);
-                if (!pService) {
-                    //qDebug() << file << "specifies unknown service" << service << "in" << group.name();
-                } else {
-                    //qDebug() << "adding mime" << resolvedMimeName << "to service" << pService->entryPath() << "pref=" << pref;
-                    m_offerHash.addServiceOffer(resolvedMimeName, KServiceOffer(pService, pref, 0, pService->allowAsDefault()));
-                    --pref;
-                }
-            }
-        }
-    }
-}
-
-void KMimeAssociations::parseRemovedAssociations(const KConfigGroup &group, const QString &file)
-{
-    Q_UNUSED(file) // except in debug statements
-    Q_FOREACH (const QString &mime, group.keyList()) {
-        const QStringList services = group.readXdgListEntry(mime);
-        Q_FOREACH (const QString &service, services) {
-            KService::Ptr pService =  m_serviceFactory->findServiceByStorageId(service);
-            if (!pService) {
-                //qDebug() << file << "specifies unknown service" << service << "in" << group.name();
-            } else {
-                //qDebug() << "removing mime" << mime << "from service" << pService.data() << pService->entryPath();
-                m_offerHash.removeServiceOffer(mime, pService);
-            }
-        }
-    }
-}
-
-void KOfferHash::addServiceOffer(const QString &serviceType, const KServiceOffer &offer)
-{
-    KService::Ptr service = offer.service();
-    //qDebug() << "Adding" << service->entryPath() << "to" << serviceType << offer.preference();
-    ServiceTypeOffersData &data = m_serviceTypeData[serviceType]; // find or create
-    QList<KServiceOffer> &offers = data.offers;
-    QSet<KService::Ptr> &offerSet = data.offerSet;
-    if (!offerSet.contains(service)) {
-        offers.append(offer);
-        offerSet.insert(service);
-    } else {
-        //qDebug() << service->entryPath() << "already in" << serviceType;
-        // This happens when mimeapps.list mentions a service (to make it preferred)
-        // Update initialPreference to qMax(existing offer, new offer)
-        QMutableListIterator<KServiceOffer> sfit(data.offers);
-        while (sfit.hasNext()) {
-            if (sfit.next().service() == service) { // we can compare KService::Ptrs because they are from the memory hash
-                sfit.value().setPreference(qMax(sfit.value().preference(), offer.preference()));
-            }
-        }
-    }
-}
-
-void KOfferHash::removeServiceOffer(const QString &serviceType, KService::Ptr service)
-{
-    ServiceTypeOffersData &data = m_serviceTypeData[serviceType]; // find or create
-    data.removedOffers.insert(service);
-    data.offerSet.remove(service);
-    QMutableListIterator<KServiceOffer> sfit(data.offers);
-    while (sfit.hasNext()) {
-        if (sfit.next().service()->storageId() == service->storageId()) {
-            sfit.remove();
-        }
-    }
-}
-
-bool KOfferHash::hasRemovedOffer(const QString &serviceType, KService::Ptr service) const
-{
-    QHash<QString, ServiceTypeOffersData>::const_iterator it = m_serviceTypeData.find(serviceType);
-    if (it != m_serviceTypeData.end()) {
-        return (*it).removedOffers.contains(service);
-    }
-    return false;
-}
diff --git a/src/kbuildsycoca/kmimeassociations.h b/src/kbuildsycoca/kmimeassociations.h
deleted file mode 100644
index 662635c..0000000
--- a/src/kbuildsycoca/kmimeassociations.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright 2008  David Faure  <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2 of the License or ( at
- *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
- *  act as a proxy as in section 14 of the GPLv3 ), any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- */
-
-#ifndef KDED_KMIMEASSOCIATIONS_H
-#define KDED_KMIMEASSOCIATIONS_H
-
-#include <QSet>
-#include <QStringList>
-#include <QHash>
-#include <kserviceoffer.h>
-class KConfigGroup;
-class KServiceFactory;
-
-struct ServiceTypeOffersData {
-    QList<KServiceOffer> offers; // service + initial preference + allow as default
-    QSet<KService::Ptr> offerSet; // for quick contains() check
-    QSet<KService::Ptr> removedOffers; // remember removed offers explicitly
-};
-
-class KOfferHash
-{
-public:
-    KOfferHash() {}
-    QList<KServiceOffer> offersFor(const QString &serviceType) const
-    {
-        QHash<QString, ServiceTypeOffersData>::const_iterator it = m_serviceTypeData.find(serviceType);
-        if (it != m_serviceTypeData.end()) {
-            return (*it).offers;
-        }
-        return QList<KServiceOffer>();
-    }
-    void addServiceOffer(const QString &serviceType, const KServiceOffer &offer);
-    void removeServiceOffer(const QString &serviceType, KService::Ptr service);
-    bool hasRemovedOffer(const QString &serviceType, KService::Ptr service) const;
-
-private:
-    KOfferHash(const KOfferHash &); // forbidden
-    QHash<QString, ServiceTypeOffersData> m_serviceTypeData;
-};
-
-/**
- * Parse mimeapps.list files and:
- * - modify mimetype associations in the relevant services (using KServiceFactory)
- * - remember preferrence order specified by user
- */
-class KMimeAssociations
-{
-public:
-    explicit KMimeAssociations(KOfferHash &offerHash, KServiceFactory *serviceFactory);
-
-    // Read mimeapps.list files
-    bool parseAllMimeAppsList();
-
-    void parseMimeAppsList(const QString &file, int basePreference);
-
-private:
-    void parseAddedAssociations(const KConfigGroup &group, const QString &file, int basePreference);
-    void parseRemovedAssociations(const KConfigGroup &group, const QString &file);
-
-    KOfferHash &m_offerHash;
-    KServiceFactory *m_serviceFactory;
-};
-
-#endif /* KMIMEASSOCIATIONS_H */
diff --git a/src/kbuildsycoca/ksycocaresourcelist.h b/src/kbuildsycoca/ksycocaresourcelist.h
deleted file mode 100644
index ee60efb..0000000
--- a/src/kbuildsycoca/ksycocaresourcelist.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 1999 David Faure <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-#ifndef KSYCOCARESOURCELIST_H
-#define KSYCOCARESOURCELIST_H
-
-#include <QtCore/QLinkedList>
-#include <QtCore/QString>
-
-struct KSycocaResource {
-    QByteArray resource;
-    QString subdir;
-    QString extension;
-};
-
-class KSycocaResourceList : public QLinkedList<KSycocaResource>
-{
-public:
-    KSycocaResourceList() { }
-
-    // resource is just used in the databaseChanged signal
-    // subdir is always under QStandardPaths::GenericDataLocation. E.g. mime, kservices5, etc.
-    void add(const QByteArray &resource, const QString &subdir, const QString &filter)
-    {
-        KSycocaResource res;
-        res.resource = resource;
-        res.subdir = subdir;
-        res.extension = filter.mid(1);
-        append(res);
-    }
-};
-
-#endif
diff --git a/src/kbuildsycoca/vfolder_menu.cpp b/src/kbuildsycoca/vfolder_menu.cpp
deleted file mode 100644
index ae2f9d7..0000000
--- a/src/kbuildsycoca/vfolder_menu.cpp
+++ /dev/null
@@ -1,1436 +0,0 @@
-/*  This file is part of the KDE libraries
- *  Copyright (C) 2003 Waldo Bastian <bastian@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- **/
-
-#include "vfolder_menu.h"
-#include "kbuildservicefactory.h"
-#include "kbuildsycocainterface.h"
-
-#include <kservice.h>
-
-#include <QDebug>
-#include <QtCore/QMap>
-#include <QtCore/QFile>
-#include <QtCore/QDir>
-#include <QtCore/QRegExp>
-#include <QtCore/QDirIterator>
-#include <QStandardPaths>
-
-static void foldNode(QDomElement &docElem, QDomElement &e, QMap<QString, QDomElement> &dupeList, QString s = QString()) //krazy:exclude=passbyvalue
-{
-    if (s.isEmpty()) {
-        s = e.text();
-    }
-    QMap<QString, QDomElement>::iterator it = dupeList.find(s);
-    if (it != dupeList.end()) {
-        qDebug() << e.tagName() << "and" << s << "requires combining!";
-
-        docElem.removeChild(*it);
-        dupeList.erase(it);
-    }
-    dupeList.insert(s, e);
-}
-
-static void replaceNode(QDomElement &docElem, QDomNode &n, const QStringList &list, const QString &tag)
-{
-    for (QStringList::ConstIterator it = list.begin();
-            it != list.end(); ++it) {
-        QDomElement e = docElem.ownerDocument().createElement(tag);
-        QDomText txt = docElem.ownerDocument().createTextNode(*it);
-        e.appendChild(txt);
-        docElem.insertAfter(e, n);
-    }
-
-    QDomNode next = n.nextSibling();
-    docElem.removeChild(n);
-    n = next;
-//   qDebug() << "Next tag = " << n.toElement().tagName();
-}
-
-void VFolderMenu::registerFile(const QString &file)
-{
-    int i = file.lastIndexOf('/');
-    if (i < 0) {
-        return;
-    }
-
-    QString dir = file.left(i + 1); // Include trailing '/'
-    registerDirectory(dir);
-}
-
-void VFolderMenu::registerDirectory(const QString &directory)
-{
-    m_allDirectories.append(directory);
-}
-
-QStringList VFolderMenu::allDirectories()
-{
-    if (m_allDirectories.isEmpty()) {
-        return m_allDirectories;
-    }
-    m_allDirectories.sort();
-
-    QStringList::Iterator it = m_allDirectories.begin();
-    QString previous = *it++;
-    for (; it != m_allDirectories.end();) {
-#ifndef Q_OS_WIN
-        if ((*it).startsWith(previous))
-#else
-        if ((*it).startsWith(previous, Qt::CaseInsensitive))
-#endif
-        {
-            it = m_allDirectories.erase(it);
-        } else {
-            previous = *it;
-            ++it;
-        }
-    }
-    return m_allDirectories;
-}
-
-static void
-track(const QString &menuId, const QString &menuName, const QHash<QString, KService::Ptr> &includeList, const QHash<QString, KService::Ptr> &excludeList, const QHash<QString, KService::Ptr> &itemList, const QString &comment)
-{
-    if (itemList.contains(menuId)) {
-        printf("%s: %s INCL %d EXCL %d\n", qPrintable(menuName), qPrintable(comment), includeList.contains(menuId) ? 1 : 0, excludeList.contains(menuId) ? 1 : 0);
-    }
-}
-
-void
-VFolderMenu::includeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
-{
-    foreach (const KService::Ptr &p, items2) {
-        items1.insert(p->menuId(), p);
-    }
-}
-
-void
-VFolderMenu::matchItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
-{
-    foreach (const KService::Ptr &p, items1) {
-        QString id = p->menuId();
-        if (!items2.contains(id)) {
-            items1.remove(id);
-        }
-    }
-}
-
-void
-VFolderMenu::excludeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
-{
-    foreach (const KService::Ptr &p, items2) {
-        items1.remove(p->menuId());
-    }
-}
-
-VFolderMenu::SubMenu *
-VFolderMenu::takeSubMenu(SubMenu *parentMenu, const QString &menuName)
-{
-    const int i = menuName.indexOf('/');
-    const QString s1 = i > 0 ? menuName.left(i) : menuName;
-    const QString s2 = menuName.mid(i + 1);
-
-    // Look up menu
-    for (QList<SubMenu *>::Iterator it = parentMenu->subMenus.begin(); it != parentMenu->subMenus.end(); ++it) {
-        SubMenu *menu = *it;
-        if (menu->name == s1) {
-            if (i == -1) {
-                // Take it out
-                parentMenu->subMenus.erase(it);
-                return menu;
-            } else {
-                return takeSubMenu(menu, s2);
-            }
-        }
-    }
-    return 0; // Not found
-}
-
-void
-VFolderMenu::mergeMenu(SubMenu *menu1, SubMenu *menu2, bool reversePriority)
-{
-    if (m_track) {
-        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->items, QString("Before MenuMerge w. %1 (incl)").arg(menu2->name));
-        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->excludeItems, QString("Before MenuMerge w. %1 (excl)").arg(menu2->name));
-    }
-    if (reversePriority) {
-        // Merge menu1 with menu2, menu1 takes precedent
-        excludeItems(menu2->items, menu1->excludeItems);
-        includeItems(menu1->items, menu2->items);
-        excludeItems(menu2->excludeItems, menu1->items);
-        includeItems(menu1->excludeItems, menu2->excludeItems);
-    } else {
-        // Merge menu1 with menu2, menu2 takes precedent
-        excludeItems(menu1->items, menu2->excludeItems);
-        includeItems(menu1->items, menu2->items);
-        includeItems(menu1->excludeItems, menu2->excludeItems);
-        menu1->isDeleted = menu2->isDeleted;
-    }
-    while (!menu2->subMenus.isEmpty()) {
-        SubMenu *subMenu = menu2->subMenus.takeFirst();
-        insertSubMenu(menu1, subMenu->name, subMenu, reversePriority);
-    }
-
-    if (reversePriority) {
-        // Merge menu1 with menu2, menu1 takes precedent
-        if (menu1->directoryFile.isEmpty()) {
-            menu1->directoryFile = menu2->directoryFile;
-        }
-        if (menu1->defaultLayoutNode.isNull()) {
-            menu1->defaultLayoutNode = menu2->defaultLayoutNode;
-        }
-        if (menu1->layoutNode.isNull()) {
-            menu1->layoutNode = menu2->layoutNode;
-        }
-    } else {
-        // Merge menu1 with menu2, menu2 takes precedent
-        if (!menu2->directoryFile.isEmpty()) {
-            menu1->directoryFile = menu2->directoryFile;
-        }
-        if (!menu2->defaultLayoutNode.isNull()) {
-            menu1->defaultLayoutNode = menu2->defaultLayoutNode;
-        }
-        if (!menu2->layoutNode.isNull()) {
-            menu1->layoutNode = menu2->layoutNode;
-        }
-    }
-
-    if (m_track) {
-        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->items, QString("After MenuMerge w. %1 (incl)").arg(menu2->name));
-        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->excludeItems, QString("After MenuMerge w. %1 (excl)").arg(menu2->name));
-    }
-
-    delete menu2;
-}
-
-void
-VFolderMenu::insertSubMenu(SubMenu *parentMenu, const QString &menuName, SubMenu *newMenu, bool reversePriority)
-{
-    const int i = menuName.indexOf('/');
-    const QString s1 = menuName.left(i);
-    const QString s2 = menuName.mid(i + 1);
-
-    // Look up menu
-    foreach (SubMenu *menu, parentMenu->subMenus) {
-        if (menu->name == s1) {
-            if (i == -1) {
-                mergeMenu(menu, newMenu, reversePriority);
-                return;
-            } else {
-                insertSubMenu(menu, s2, newMenu, reversePriority);
-                return;
-            }
-        }
-    }
-    if (i == -1) {
-        // Add it here
-        newMenu->name = menuName;
-        parentMenu->subMenus.append(newMenu);
-    } else {
-        SubMenu *menu = new SubMenu;
-        menu->name = s1;
-        parentMenu->subMenus.append(menu);
-        insertSubMenu(menu, s2, newMenu);
-    }
-}
-
-void
-VFolderMenu::insertService(SubMenu *parentMenu, const QString &name, KService::Ptr newService)
-{
-    const int i = name.indexOf('/');
-
-    if (i == -1) {
-        // Add it here
-        parentMenu->items.insert(newService->menuId(), newService);
-        return;
-    }
-
-    QString s1 = name.left(i);
-    QString s2 = name.mid(i + 1);
-
-    // Look up menu
-    foreach (SubMenu *menu, parentMenu->subMenus) {
-        if (menu->name == s1) {
-            insertService(menu, s2, newService);
-            return;
-        }
-    }
-
-    SubMenu *menu = new SubMenu;
-    menu->name = s1;
-    parentMenu->subMenus.append(menu);
-    insertService(menu, s2, newService);
-}
-
-VFolderMenu::VFolderMenu(KBuildServiceFactory *serviceFactory, KBuildSycocaInterface *kbuildsycocaInterface)
-    : m_appsInfo(0)
-    , m_rootMenu(0)
-    , m_currentMenu(0)
-    , m_track(false)
-    , m_serviceFactory(serviceFactory)
-    , m_kbuildsycocaInterface(kbuildsycocaInterface)
-{
-    m_usedAppsDict.reserve(797);
-    initDirs();
-}
-
-VFolderMenu::~VFolderMenu()
-{
-    delete m_rootMenu;
-    delete m_appsInfo;
-}
-
-#define FOR_ALL_APPLICATIONS(it) \
-    foreach (AppsInfo *info, m_appsInfoStack) \
-    { \
-        QHashIterator<QString,KService::Ptr> it = info->applications; \
-        while (it.hasNext()) \
-        { \
-            it.next();
-#define FOR_ALL_APPLICATIONS_END } }
-
-#define FOR_CATEGORY(category, it) \
-    foreach (AppsInfo *info, m_appsInfoStack) \
-    { \
-        const KService::List list = info->dictCategories.value(category); \
-        for(KService::List::ConstIterator it = list.constBegin(); \
-                it != list.constEnd(); ++it) \
-        {
-#define FOR_CATEGORY_END } }
-
-KService::Ptr
-VFolderMenu::findApplication(const QString &relPath)
-{
-    foreach (AppsInfo *info, m_appsInfoStack) {
-        if (info->applications.contains(relPath)) {
-            KService::Ptr s = info->applications[relPath];
-            if (s) {
-                return s;
-            }
-        }
-    }
-    return KService::Ptr();
-}
-
-void
-VFolderMenu::addApplication(const QString &id, KService::Ptr service)
-{
-    service->setMenuId(id);
-    m_appsInfo->applications.insert(id, service); // replaces, if already there
-    m_serviceFactory->addEntry(KSycocaEntry::Ptr(service));
-}
-
-void
-VFolderMenu::buildApplicationIndex(bool unusedOnly)
-{
-    foreach (AppsInfo *info, m_appsInfoList) {
-        info->dictCategories.clear();
-        QMutableHashIterator<QString, KService::Ptr> it = info->applications;
-        while (it.hasNext()) {
-            KService::Ptr s = it.next().value();
-            if (unusedOnly && m_usedAppsDict.contains(s->menuId())) {
-                // Remove and skip this one
-                it.remove();
-                continue;
-            }
-
-            Q_FOREACH (const QString &cat, s->categories()) {
-                info->dictCategories[cat].append(s); // find or insert entry in hash
-            }
-        }
-    }
-}
-
-void
-VFolderMenu::createAppsInfo()
-{
-    if (m_appsInfo) {
-        return;
-    }
-
-    m_appsInfo = new AppsInfo;
-    m_appsInfoStack.prepend(m_appsInfo);
-    m_appsInfoList.append(m_appsInfo);
-    m_currentMenu->apps_info = m_appsInfo;
-}
-
-void
-VFolderMenu::loadAppsInfo()
-{
-    m_appsInfo = m_currentMenu->apps_info;
-    if (!m_appsInfo) {
-        return;    // No appsInfo for this menu
-    }
-
-    if (m_appsInfoStack.count() && m_appsInfoStack.first() == m_appsInfo) {
-        return;    // Already added (By createAppsInfo?)
-    }
-
-    m_appsInfoStack.prepend(m_appsInfo); // Add
-}
-
-void
-VFolderMenu::unloadAppsInfo()
-{
-    m_appsInfo = m_currentMenu->apps_info;
-    if (!m_appsInfo) {
-        return;    // No appsInfo for this menu
-    }
-
-    if (m_appsInfoStack.first() != m_appsInfo) {
-        return; // Already removed (huh?)
-    }
-
-    m_appsInfoStack.removeAll(m_appsInfo); // Remove
-    m_appsInfo = 0;
-}
-
-QString
-VFolderMenu::absoluteDir(const QString &_dir, const QString &baseDir, bool keepRelativeToCfg)
-{
-    QString dir = _dir;
-    if (QDir::isRelativePath(dir)) {
-        dir = baseDir + dir;
-    }
-
-    bool relative = QDir::isRelativePath(dir);
-    if (relative && !keepRelativeToCfg) {
-        relative = false;
-        dir = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + dir, QStandardPaths::LocateDirectory);
-    }
-
-    if (!relative) {
-        QString resolved = QDir(dir).canonicalPath();
-        if (!resolved.isEmpty()) {
-            dir = resolved;
-        }
-    }
-
-    if (!dir.endsWith('/')) {
-        dir += '/';
-    }
-
-    return dir;
-}
-
-static void tagBaseDir(QDomDocument &doc, const QString &tag, const QString &dir)
-{
-    QDomNodeList mergeFileList = doc.elementsByTagName(tag);
-    for (int i = 0; i < mergeFileList.count(); i++) {
-        QDomAttr attr = doc.createAttribute(QStringLiteral("__BaseDir"));
-        attr.setValue(dir);
-        mergeFileList.item(i).toElement().setAttributeNode(attr);
-    }
-}
-
-static void tagBasePath(QDomDocument &doc, const QString &tag, const QString &path)
-{
-    QDomNodeList mergeFileList = doc.elementsByTagName(tag);
-    for (int i = 0; i < mergeFileList.count(); i++) {
-        QDomAttr attr = doc.createAttribute(QStringLiteral("__BasePath"));
-        attr.setValue(path);
-        mergeFileList.item(i).toElement().setAttributeNode(attr);
-    }
-}
-
-QDomDocument
-VFolderMenu::loadDoc()
-{
-    QDomDocument doc;
-    if (m_docInfo.path.isEmpty()) {
-        return doc;
-    }
-    QFile file(m_docInfo.path);
-    if (!file.open(QIODevice::ReadOnly)) {
-        qWarning() << "Could not open " << m_docInfo.path;
-        return doc;
-    }
-    QString errorMsg;
-    int errorRow;
-    int errorCol;
-    if (!doc.setContent(&file, &errorMsg, &errorRow, &errorCol)) {
-        qWarning() << "Parse error in " << m_docInfo.path << ", line " << errorRow << ", col " << errorCol << ": " << errorMsg;
-        file.close();
-        return doc;
-    }
-    file.close();
-
-    tagBaseDir(doc, QStringLiteral("MergeFile"), m_docInfo.baseDir);
-    tagBasePath(doc, QStringLiteral("MergeFile"), m_docInfo.path);
-    tagBaseDir(doc, QStringLiteral("MergeDir"), m_docInfo.baseDir);
-    tagBaseDir(doc, QStringLiteral("DirectoryDir"), m_docInfo.baseDir);
-    tagBaseDir(doc, QStringLiteral("AppDir"), m_docInfo.baseDir);
-    tagBaseDir(doc, QStringLiteral("LegacyDir"), m_docInfo.baseDir);
-
-    return doc;
-}
-
-void
-VFolderMenu::mergeFile(QDomElement &parent, const QDomNode &mergeHere)
-{
-    //qDebug() << m_docInfo.path;
-    QDomDocument doc = loadDoc();
-
-    QDomElement docElem = doc.documentElement();
-    QDomNode n = docElem.firstChild();
-    QDomNode last = mergeHere;
-    while (!n.isNull()) {
-        QDomElement e = n.toElement(); // try to convert the node to an element.
-        QDomNode next = n.nextSibling();
-
-        if (e.isNull()) {
-            // Skip
-        }
-        // The spec says we must ignore any Name nodes
-        else if (e.tagName() != "Name") {
-            parent.insertAfter(n, last);
-            last = n;
-        }
-
-        docElem.removeChild(n);
-        n = next;
-    }
-}
-
-void
-VFolderMenu::mergeMenus(QDomElement &docElem, QString &name)
-{
-    QMap<QString, QDomElement> menuNodes;
-    QMap<QString, QDomElement> directoryNodes;
-    QMap<QString, QDomElement> appDirNodes;
-    QMap<QString, QDomElement> directoryDirNodes;
-    QMap<QString, QDomElement> legacyDirNodes;
-    QDomElement defaultLayoutNode;
-    QDomElement layoutNode;
-
-    QDomNode n = docElem.firstChild();
-    while (!n.isNull()) {
-        QDomElement e = n.toElement(); // try to convert the node to an element.
-        if (e.isNull()) {
-// qDebug() << "Empty node";
-        } else if (e.tagName() == QLatin1String("DefaultAppDirs")) {
-            // Replace with m_defaultAppDirs
-            replaceNode(docElem, n, m_defaultAppDirs, "AppDir");
-            continue;
-        } else if (e.tagName() == QLatin1String("DefaultDirectoryDirs")) {
-            // Replace with m_defaultDirectoryDirs
-            replaceNode(docElem, n, m_defaultDirectoryDirs, "DirectoryDir");
-            continue;
-        } else if (e.tagName() == QLatin1String("DefaultMergeDirs")) {
-            // Replace with m_defaultMergeDirs
-            replaceNode(docElem, n, m_defaultMergeDirs, "MergeDir");
-            continue;
-        } else if (e.tagName() == QLatin1String("AppDir")) {
-            // Filter out dupes
-            foldNode(docElem, e, appDirNodes);
-        } else if (e.tagName() == QLatin1String("DirectoryDir")) {
-            // Filter out dupes
-            foldNode(docElem, e, directoryDirNodes);
-        } else if (e.tagName() == QLatin1String("LegacyDir")) {
-            // Filter out dupes
-            foldNode(docElem, e, legacyDirNodes);
-        } else if (e.tagName() == QLatin1String("Directory")) {
-            // Filter out dupes
-            foldNode(docElem, e, directoryNodes);
-        } else if (e.tagName() == QLatin1String("Move")) {
-            // Filter out dupes
-            QString orig;
-            QDomNode n2 = e.firstChild();
-            while (!n2.isNull()) {
-                QDomElement e2 = n2.toElement(); // try to convert the node to an element.
-                if (e2.tagName() == QLatin1String("Old")) {
-                    orig = e2.text();
-                    break;
-                }
-                n2 = n2.nextSibling();
-            }
-            foldNode(docElem, e, appDirNodes, orig);
-        } else if (e.tagName() == QLatin1String("Menu")) {
-            QString name;
-            mergeMenus(e, name);
-            QMap<QString, QDomElement>::iterator it = menuNodes.find(name);
-            if (it != menuNodes.end()) {
-                QDomElement docElem2 = *it;
-                QDomNode n2 = docElem2.firstChild();
-                QDomNode first = e.firstChild();
-                while (!n2.isNull()) {
-                    QDomElement e2 = n2.toElement(); // try to convert the node to an element.
-                    QDomNode n3 = n2.nextSibling();
-                    e.insertBefore(n2, first);
-                    docElem2.removeChild(n2);
-                    n2 = n3;
-                }
-                // We still have duplicated Name entries
-                // but we don't care about that
-
-                docElem.removeChild(docElem2);
-                menuNodes.erase(it);
-            }
-            menuNodes.insert(name, e);
-        } else if (e.tagName() == QLatin1String("MergeFile")) {
-            if ((e.attribute(QStringLiteral("type")) == QLatin1String("parent"))) {
-                // Ignore e.text(), as per the standard. We'll just look up the parent (more global) xml file.
-                pushDocInfoParent(e.attribute(QStringLiteral("__BasePath")), e.attribute(QStringLiteral("__BaseDir")));
-            } else {
-                pushDocInfo(e.text(), e.attribute(QStringLiteral("__BaseDir")));
-            }
-
-            if (!m_docInfo.path.isEmpty()) {
-                mergeFile(docElem, n);
-            }
-            popDocInfo();
-
-            QDomNode last = n;
-            n = n.nextSibling();
-            docElem.removeChild(last); // Remove the MergeFile node
-            continue;
-        } else if (e.tagName() == QLatin1String("MergeDir")) {
-            QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")), true);
-            Q_ASSERT(dir.endsWith('/'));
-
-            const bool relative = QDir::isRelativePath(dir);
-            const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + dir, QStandardPaths::LocateDirectory);
-            Q_FOREACH (const QString &menuDir, dirs) {
-                registerDirectory(menuDir);
-            }
-
-            QStringList fileList;
-            Q_FOREACH (const QString &menuDir, dirs) {
-                const QStringList fileNames = QDir(menuDir).entryList(QStringList() << QStringLiteral("*.menu"));
-                Q_FOREACH (const QString &file, fileNames) {
-                    const QString fileToAdd = relative ? dir + file : menuDir + file;
-                    if (!fileList.contains(fileToAdd)) {
-                        fileList.append(fileToAdd);
-                    }
-                }
-            }
-
-            Q_FOREACH (const QString &file, fileList) {
-                pushDocInfo(file);
-                mergeFile(docElem, n);
-                popDocInfo();
-            }
-
-            QDomNode last = n;
-            n = n.nextSibling();
-            docElem.removeChild(last); // Remove the MergeDir node
-
-            continue;
-        } else if (e.tagName() == QLatin1String("Name")) {
-            name = e.text();
-        } else if (e.tagName() == QLatin1String("DefaultLayout")) {
-            if (!defaultLayoutNode.isNull()) {
-                docElem.removeChild(defaultLayoutNode);
-            }
-            defaultLayoutNode = e;
-        } else if (e.tagName() == QLatin1String("Layout")) {
-            if (!layoutNode.isNull()) {
-                docElem.removeChild(layoutNode);
-            }
-            layoutNode = e;
-        }
-        n = n.nextSibling();
-    }
-}
-
-static QString makeRelative(const QString &dir)
-{
-    const QString canonical = QDir(dir).canonicalPath();
-    Q_FOREACH (const QString &base, QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, "menus", QStandardPaths::LocateDirectory)) {
-        if (canonical.startsWith(base)) {
-            return canonical.mid(base.length() + 1);
-        }
-    }
-    return dir;
-}
-
-void
-VFolderMenu::pushDocInfo(const QString &fileName, const QString &baseDir)
-{
-    m_docInfoStack.push(m_docInfo);
-    if (!baseDir.isEmpty()) {
-        if (!QDir::isRelativePath(baseDir)) {
-            m_docInfo.baseDir = makeRelative(baseDir);
-        } else {
-            m_docInfo.baseDir = baseDir;
-        }
-    }
-
-    QString baseName = fileName;
-    if (!QDir::isRelativePath(baseName)) {
-        registerFile(baseName);
-    } else {
-        baseName = m_docInfo.baseDir + baseName;
-    }
-
-    m_docInfo.path = locateMenuFile(fileName);
-    if (m_docInfo.path.isEmpty()) {
-        m_docInfo.baseDir.clear();
-        m_docInfo.baseName.clear();
-        qDebug() << "Menu" << fileName << "not found.";
-        return;
-    }
-    int i;
-    i = baseName.lastIndexOf('/');
-    if (i > 0) {
-        m_docInfo.baseDir = baseName.left(i + 1);
-        m_docInfo.baseName = baseName.mid(i + 1, baseName.length() - i - 6);
-    } else {
-        m_docInfo.baseDir.clear();
-        m_docInfo.baseName = baseName.left(baseName.length() - 5);
-    }
-}
-
-void
-VFolderMenu::pushDocInfoParent(const QString &basePath, const QString &baseDir)
-{
-    m_docInfoStack.push(m_docInfo);
-
-    m_docInfo.baseDir = baseDir;
-
-    QString fileName = basePath.mid(basePath.lastIndexOf('/') + 1);
-    m_docInfo.baseName = fileName.left(fileName.length() - 5);   // without ".menu"
-    QString baseName = QDir::cleanPath(m_docInfo.baseDir + fileName);
-
-    QStringList result = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
-
-    // Remove anything "more local" than basePath.
-    while (!result.isEmpty() && (result.at(0) != basePath)) {
-        result.removeFirst();
-    }
-
-    if (result.count() <= 1) {
-        m_docInfo.path.clear(); // No parent found
-        return;
-    }
-    // Now result.at(0) == basePath, take the next one, i.e. the one in the parent dir.
-    m_docInfo.path = result.at(1);
-}
-
-void
-VFolderMenu::popDocInfo()
-{
-    m_docInfo = m_docInfoStack.pop();
-}
-
-QString
-VFolderMenu::locateMenuFile(const QString &fileName)
-{
-    if (!QDir::isRelativePath(fileName)) {
-        if (QFile::exists(fileName)) {
-            return fileName;
-        }
-        return QString();
-    }
-
-    QString result;
-
-    QString xdgMenuPrefix = QString::fromLocal8Bit(qgetenv("XDG_MENU_PREFIX"));
-    if (!xdgMenuPrefix.isEmpty()) {
-        QFileInfo fileInfo(fileName);
-
-        QString fileNameOnly = fileInfo.fileName();
-        if (!fileNameOnly.startsWith(xdgMenuPrefix)) {
-            fileNameOnly = xdgMenuPrefix + fileNameOnly;
-        }
-
-        QString baseName = QDir::cleanPath(m_docInfo.baseDir +
-                                           fileInfo.path() + '/' + fileNameOnly);
-        result = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
-    }
-
-    if (result.isEmpty()) {
-        QString baseName = QDir::cleanPath(m_docInfo.baseDir + fileName);
-        result = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
-    }
-
-    return result;
-}
-
-QString
-VFolderMenu::locateDirectoryFile(const QString &fileName)
-{
-    if (fileName.isEmpty()) {
-        return QString();
-    }
-
-    if (!QDir::isRelativePath(fileName)) {
-        if (QFile::exists(fileName)) {
-            return fileName;
-        }
-        return QString();
-    }
-
-    // First location in the list wins
-    for (QStringList::ConstIterator it = m_directoryDirs.constBegin();
-            it != m_directoryDirs.constEnd();
-            ++it) {
-        QString tmp = (*it) + fileName;
-        if (QFile::exists(tmp)) {
-            return tmp;
-        }
-    }
-
-    return QString();
-}
-
-void
-VFolderMenu::initDirs()
-{
-    m_defaultAppDirs = QStandardPaths::standardLocations(QStandardPaths::ApplicationsLocation);
-    m_defaultDirectoryDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, "desktop-directories", QStandardPaths::LocateDirectory);
-}
-
-void
-VFolderMenu::loadMenu(const QString &fileName)
-{
-    m_defaultMergeDirs.clear();
-
-    if (!fileName.endsWith(QLatin1String(".menu"))) {
-        return;
-    }
-
-    pushDocInfo(fileName);
-    m_defaultMergeDirs << m_docInfo.baseName + QStringLiteral("-merged/");
-    m_doc = loadDoc();
-    popDocInfo();
-
-    if (m_doc.isNull()) {
-        if (m_docInfo.path.isEmpty()) {
-            qCritical() << fileName << " not found in " << m_allDirectories << endl;
-        } else {
-            qWarning() << "Load error (" << m_docInfo.path << ")";
-        }
-        return;
-    }
-
-    QDomElement e = m_doc.documentElement();
-    QString name;
-    mergeMenus(e, name);
-}
-
-void
-VFolderMenu::processCondition(QDomElement &domElem, QHash<QString, KService::Ptr> &items)
-{
-    if (domElem.tagName() == QLatin1String("And")) {
-        QDomNode n = domElem.firstChild();
-        // Look for the first child element
-        while (!n.isNull()) { // loop in case of comments
-            QDomElement e = n.toElement();
-            n = n.nextSibling();
-            if (!e.isNull()) {
-                processCondition(e, items);
-                break; // we only want the first one
-            }
-        }
-
-        QHash<QString, KService::Ptr> andItems;
-        while (!n.isNull()) {
-            QDomElement e = n.toElement();
-            if (e.tagName() == QLatin1String("Not")) {
-                // Special handling for "and not"
-                QDomNode n2 = e.firstChild();
-                while (!n2.isNull()) {
-                    QDomElement e2 = n2.toElement();
-                    andItems.clear();
-                    processCondition(e2, andItems);
-                    excludeItems(items, andItems);
-                    n2 = n2.nextSibling();
-                }
-            } else {
-                andItems.clear();
-                processCondition(e, andItems);
-                matchItems(items, andItems);
-            }
-            n = n.nextSibling();
-        }
-    } else if (domElem.tagName() == QLatin1String("Or")) {
-        QDomNode n = domElem.firstChild();
-        // Look for the first child element
-        while (!n.isNull()) { // loop in case of comments
-            QDomElement e = n.toElement();
-            n = n.nextSibling();
-            if (!e.isNull()) {
-                processCondition(e, items);
-                break; // we only want the first one
-            }
-        }
-
-        QHash<QString, KService::Ptr> orItems;
-        while (!n.isNull()) {
-            QDomElement e = n.toElement();
-            if (!e.isNull()) {
-                orItems.clear();
-                processCondition(e, orItems);
-                includeItems(items, orItems);
-            }
-            n = n.nextSibling();
-        }
-    } else if (domElem.tagName() == QLatin1String("Not")) {
-        FOR_ALL_APPLICATIONS(it) {
-            KService::Ptr s = it.value();
-            items.insert(s->menuId(), s);
-        }
-        FOR_ALL_APPLICATIONS_END
-
-        QHash<QString, KService::Ptr> notItems;
-        QDomNode n = domElem.firstChild();
-        while (!n.isNull()) {
-            QDomElement e = n.toElement();
-            if (!e.isNull()) {
-                notItems.clear();
-                processCondition(e, notItems);
-                excludeItems(items, notItems);
-            }
-            n = n.nextSibling();
-        }
-    } else if (domElem.tagName() == QLatin1String("Category")) {
-        FOR_CATEGORY(domElem.text(), it) {
-            KService::Ptr s = *it;
-            items.insert(s->menuId(), s);
-        }
-        FOR_CATEGORY_END
-    } else if (domElem.tagName() == QLatin1String("All")) {
-        FOR_ALL_APPLICATIONS(it) {
-            KService::Ptr s = it.value();
-            items.insert(s->menuId(), s);
-        }
-        FOR_ALL_APPLICATIONS_END
-    } else if (domElem.tagName() == QLatin1String("Filename")) {
-        const QString filename = domElem.text();
-        //qDebug() << "Adding file" << filename;
-        KService::Ptr s = findApplication(filename);
-        if (s) {
-            items.insert(filename, s);
-        }
-    }
-}
-
-void
-VFolderMenu::loadApplications(const QString &dir, const QString &prefix)
-{
-    //qDebug() << "Looking up applications under" << dir;
-
-    QDirIterator it(dir);
-    while (it.hasNext()) {
-        it.next();
-        const QFileInfo fi = it.fileInfo();
-        const QString fn = fi.fileName();
-        if (fi.isDir() && !fi.isBundle()) {
-            if (fn == QLatin1String(".") || fn == QLatin1String("..")) {
-                continue;
-            }
-            loadApplications(fi.filePath(), prefix + fn + '-');
-            continue;
-        }
-        if (fi.isFile()) {
-            if (!fn.endsWith(QLatin1String(".desktop"))) {
-                continue;
-            }
-            KService::Ptr service = m_kbuildsycocaInterface->createService(fi.absoluteFilePath());
-            if (service) {
-                addApplication(prefix + fn, service);
-            }
-        }
-    }
-}
-
-void
-VFolderMenu::processLegacyDir(const QString &dir, const QString &relDir, const QString &prefix)
-{
-    //qDebug().nospace() << "processLegacyDir(" << dir << ", " << relDir << ", " << prefix << ")";
-
-    QHash<QString, KService::Ptr> items;
-    QDirIterator it(dir);
-    while (it.hasNext()) {
-        it.next();
-        const QFileInfo fi = it.fileInfo();
-        const QString fn = fi.fileName();
-        if (fi.isDir()) {
-            if (fn == QLatin1String(".") || fn == QLatin1String("..")) {
-                continue;
-            }
-            SubMenu *parentMenu = m_currentMenu;
-
-            m_currentMenu = new SubMenu;
-            m_currentMenu->name = fn;
-            m_currentMenu->directoryFile = fi.absoluteFilePath() + QStringLiteral("/.directory");
-
-            parentMenu->subMenus.append(m_currentMenu);
-
-            processLegacyDir(fi.filePath(), relDir + fn + '/', prefix);
-            m_currentMenu = parentMenu;
-            continue;
-        }
-        if (fi.isFile() /*&& !fi.isSymLink() ?? */) {
-            if (!fn.endsWith(QLatin1String(".desktop"))) {
-                continue;
-            }
-            KService::Ptr service = m_kbuildsycocaInterface->createService(fi.absoluteFilePath());
-            if (service) {
-                const QString id = prefix + fn;
-
-                // TODO: Add legacy category
-                addApplication(id, service);
-                items.insert(service->menuId(), service);
-
-                if (service->categories().isEmpty()) {
-                    m_currentMenu->items.insert(id, service);
-                }
-            }
-        }
-    }
-    markUsedApplications(items);
-}
-
-void
-VFolderMenu::processMenu(QDomElement &docElem, int pass)
-{
-    SubMenu *parentMenu = m_currentMenu;
-    int oldDirectoryDirsCount = m_directoryDirs.count();
-
-    QString name;
-    QString directoryFile;
-    bool onlyUnallocated = false;
-    bool isDeleted = false;
-    QDomElement defaultLayoutNode;
-    QDomElement layoutNode;
-
-    QDomElement query;
-    QDomNode n = docElem.firstChild();
-    while (!n.isNull()) {
-        QDomElement e = n.toElement(); // try to convert the node to an element.
-        if (e.tagName() == QLatin1String("Name")) {
-            name = e.text();
-        } else if (e.tagName() == QLatin1String("Directory")) {
-            directoryFile = e.text();
-        } else if (e.tagName() == QLatin1String("DirectoryDir")) {
-            QString dir = absoluteDir(e.text(), e.attribute("__BaseDir"));
-
-            m_directoryDirs.prepend(dir);
-        } else if (e.tagName() == QLatin1String("OnlyUnallocated")) {
-            onlyUnallocated = true;
-        } else if (e.tagName() == QLatin1String("NotOnlyUnallocated")) {
-            onlyUnallocated = false;
-        } else if (e.tagName() == QLatin1String("Deleted")) {
-            isDeleted = true;
-        } else if (e.tagName() == QLatin1String("NotDeleted")) {
-            isDeleted = false;
-        } else if (e.tagName() == QLatin1String("DefaultLayout")) {
-            defaultLayoutNode = e;
-        } else if (e.tagName() == QLatin1String("Layout")) {
-            layoutNode = e;
-        }
-        n = n.nextSibling();
-    }
-
-    // Setup current menu entry
-    if (pass == 0) {
-        m_currentMenu = 0;
-        // Look up menu
-        if (parentMenu) {
-            foreach (SubMenu *menu, parentMenu->subMenus) {
-                if (menu->name == name) {
-                    m_currentMenu = menu;
-                    break;
-                }
-            }
-        }
-
-        if (!m_currentMenu) { // Not found?
-            // Create menu
-            m_currentMenu = new SubMenu;
-            m_currentMenu->name = name;
-
-            if (parentMenu) {
-                parentMenu->subMenus.append(m_currentMenu);
-            } else {
-                m_rootMenu = m_currentMenu;
-            }
-        }
-        if (directoryFile.isEmpty()) {
-            //qDebug() << "Menu" << name << "does not specify a directory file.";
-        }
-
-        // Override previous directoryFile iff available
-        QString tmp = locateDirectoryFile(directoryFile);
-        if (! tmp.isEmpty()) {
-            m_currentMenu->directoryFile = tmp;
-        }
-        m_currentMenu->isDeleted = isDeleted;
-
-        m_currentMenu->defaultLayoutNode = defaultLayoutNode;
-        m_currentMenu->layoutNode = layoutNode;
-    } else {
-        // Look up menu
-        if (parentMenu) {
-            foreach (SubMenu *menu, parentMenu->subMenus) {
-                if (menu->name == name) {
-                    m_currentMenu = menu;
-                    break;
-                }
-            }
-        } else {
-            m_currentMenu = m_rootMenu;
-        }
-    }
-
-    // Process AppDir and LegacyDir
-    if (pass == 0) {
-        QDomElement query;
-        QDomNode n = docElem.firstChild();
-        while (!n.isNull()) {
-            QDomElement e = n.toElement(); // try to convert the node to an element.
-            if (e.tagName() == QLatin1String("AppDir")) {
-                createAppsInfo();
-                QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")));
-
-                registerDirectory(dir);
-
-                loadApplications(dir, QString());
-            } else if (e.tagName() == QLatin1String("LegacyDir")) {
-                createAppsInfo();
-                QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")));
-
-                QString prefix = e.attributes().namedItem(QStringLiteral("prefix")).toAttr().value();
-
-                SubMenu *oldMenu = m_currentMenu;
-                m_currentMenu = new SubMenu;
-
-                registerDirectory(dir);
-
-                processLegacyDir(dir, QString(), prefix);
-
-                m_legacyNodes.insert(dir, m_currentMenu);
-                m_currentMenu = oldMenu;
-            }
-            n = n.nextSibling();
-        }
-    }
-
-    loadAppsInfo(); // Update the scope wrt the list of applications
-
-    if (((pass == 1) && !onlyUnallocated) || ((pass == 2) && onlyUnallocated)) {
-        n = docElem.firstChild();
-
-        while (!n.isNull()) {
-            QDomElement e = n.toElement(); // try to convert the node to an element.
-            if (e.tagName() == QLatin1String("Include")) {
-                QHash<QString, KService::Ptr> items;
-
-                QDomNode n2 = e.firstChild();
-                while (!n2.isNull()) {
-                    QDomElement e2 = n2.toElement();
-                    items.clear();
-                    processCondition(e2, items);
-                    if (m_track) {
-                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "Before <Include>");
-                    }
-                    includeItems(m_currentMenu->items, items);
-                    excludeItems(m_currentMenu->excludeItems, items);
-                    markUsedApplications(items);
-
-                    if (m_track) {
-                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "After <Include>");
-                    }
-
-                    n2 = n2.nextSibling();
-                }
-            }
-
-            else if (e.tagName() == QLatin1String("Exclude")) {
-                QHash<QString, KService::Ptr> items;
-
-                QDomNode n2 = e.firstChild();
-                while (!n2.isNull()) {
-                    QDomElement e2 = n2.toElement();
-                    items.clear();
-                    processCondition(e2, items);
-                    if (m_track) {
-                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "Before <Exclude>");
-                    }
-                    excludeItems(m_currentMenu->items, items);
-                    includeItems(m_currentMenu->excludeItems, items);
-                    if (m_track) {
-                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "After <Exclude>");
-                    }
-                    n2 = n2.nextSibling();
-                }
-            }
-
-            n = n.nextSibling();
-        }
-    }
-
-    n = docElem.firstChild();
-    while (!n.isNull()) {
-        QDomElement e = n.toElement(); // try to convert the node to an element.
-        if (e.tagName() == QLatin1String("Menu")) {
-            processMenu(e, pass);
-        }
-// We insert legacy dir in pass 0, this way the order in the .menu-file determines
-// which .directory file gets used, but the menu-entries of legacy-menus will always
-// have the lowest priority.
-//      else if (((pass == 1) && !onlyUnallocated) || ((pass == 2) && onlyUnallocated))
-        else if (pass == 0) {
-            if (e.tagName() == QLatin1String("LegacyDir")) {
-                // Add legacy nodes to Menu structure
-                QString dir = absoluteDir(e.text(), e.attribute("__BaseDir"));
-                SubMenu *legacyMenu = m_legacyNodes[dir];
-                if (legacyMenu) {
-                    mergeMenu(m_currentMenu, legacyMenu);
-                }
-            }
-        }
-        n = n.nextSibling();
-    }
-
-    if (pass == 2) {
-        n = docElem.firstChild();
-        while (!n.isNull()) {
-            QDomElement e = n.toElement(); // try to convert the node to an element.
-            if (e.tagName() == QLatin1String("Move")) {
-                QString orig;
-                QString dest;
-                QDomNode n2 = e.firstChild();
-                while (!n2.isNull()) {
-                    QDomElement e2 = n2.toElement(); // try to convert the node to an element.
-                    if (e2.tagName() == QLatin1String("Old")) {
-                        orig = e2.text();
-                    }
-                    if (e2.tagName() == QLatin1String("New")) {
-                        dest = e2.text();
-                    }
-                    n2 = n2.nextSibling();
-                }
-                //qDebug() << "Moving" << orig << "to" << dest;
-                if (!orig.isEmpty() && !dest.isEmpty()) {
-                    SubMenu *menu = takeSubMenu(m_currentMenu, orig);
-                    if (menu) {
-                        insertSubMenu(m_currentMenu, dest, menu, true); // Destination has priority
-                    }
-                }
-            }
-            n = n.nextSibling();
-        }
-
-    }
-
-    unloadAppsInfo(); // Update the scope wrt the list of applications
-
-    while (m_directoryDirs.count() > oldDirectoryDirsCount) {
-        m_directoryDirs.pop_front();
-    }
-
-    m_currentMenu = parentMenu;
-}
-
-static QString parseAttribute(const QDomElement &e)
-{
-    QString option;
-
-    const QString SHOW_EMPTY=QStringLiteral("show_empty");
-    if (e.hasAttribute(SHOW_EMPTY)) {
-        QString str = e.attribute(SHOW_EMPTY);
-        if (str == QLatin1String("true")) {
-            option = "ME ";
-        } else if (str == QLatin1String("false")) {
-            option = "NME ";
-        } else {
-            //qDebug()<<" Error in parsing show_empty attribute :"<<str;
-        }
-    }
-    const QString INLINE=QStringLiteral("inline");
-    if (e.hasAttribute(INLINE)) {
-        QString str = e.attribute(INLINE);
-        if (str == QLatin1String("true")) {
-            option += "I ";
-        } else if (str == QLatin1String("false")) {
-            option += "NI ";
-        } else {
-            qDebug() << " Error in parsing inline attribute :" << str;
-        }
-    }
-    if (e.hasAttribute(QStringLiteral("inline_limit"))) {
-        bool ok;
-        int value = e.attribute(QStringLiteral("inline_limit")).toInt(&ok);
-        if (ok) {
-            option += QStringLiteral("IL[%1] ").arg(value);
-        }
-    }
-    if (e.hasAttribute(QStringLiteral("inline_header"))) {
-        QString str = e.attribute(QStringLiteral("inline_header"));
-        if (str == QLatin1String("true")) {
-            option += QStringLiteral("IH ");
-        } else if (str == QLatin1String("false")) {
-            option += QStringLiteral("NIH ");
-        } else {
-            qDebug() << " Error in parsing of inline_header attribute :" << str;
-        }
-
-    }
-    if (e.hasAttribute("inline_alias") && e.attribute("inline_alias") == QLatin1String("true")) {
-        QString str = e.attribute("inline_alias");
-        if (str == QLatin1String("true")) {
-            option += "IA";
-        } else if (str == QLatin1String("false")) {
-            option += "NIA";
-        } else {
-            qDebug() << " Error in parsing inline_alias attribute :" << str;
-        }
-    }
-    if (!option.isEmpty()) {
-        option = option.prepend(QStringLiteral(":O"));
-    }
-    return option;
-
-}
-
-static QStringList parseLayoutNode(const QDomElement &docElem)
-{
-    QStringList layout;
-
-    QString optionDefaultLayout;
-    if (docElem.tagName() == QLatin1String("DefaultLayout")) {
-        optionDefaultLayout =  parseAttribute(docElem);
-    }
-    if (!optionDefaultLayout.isEmpty()) {
-        layout.append(optionDefaultLayout);
-    }
-
-    bool mergeTagExists = false;
-    QDomNode n = docElem.firstChild();
-    while (!n.isNull()) {
-        QDomElement e = n.toElement(); // try to convert the node to an element.
-        if (e.tagName() == QLatin1String("Separator")) {
-            layout.append(":S");
-        } else if (e.tagName() == QLatin1String("Filename")) {
-            layout.append(e.text());
-        } else if (e.tagName() == QLatin1String("Menuname")) {
-            layout.append('/' + e.text());
-            QString option = parseAttribute(e);
-            if (!option.isEmpty()) {
-                layout.append(option);
-            }
-        } else if (e.tagName() == QLatin1String("Merge")) {
-            QString type = e.attributeNode(QStringLiteral("type")).value();
-            if (type == QLatin1String("files")) {
-                layout.append(QStringLiteral(":F"));
-            } else if (type == QLatin1String("menus")) {
-                layout.append(QStringLiteral(":M"));
-            } else if (type == QLatin1String("all")) {
-                layout.append(QStringLiteral(":A"));
-            }
-            mergeTagExists = true;
-        }
-
-        n = n.nextSibling();
-    }
-
-    if (!mergeTagExists) {
-        layout.append(QStringLiteral(":M"));
-        layout.append(QStringLiteral(":F"));
-        qWarning() << "The menu spec file contains a Layout or DefaultLayout tag without the mandatory Merge tag inside. Please fix your file.";
-    }
-    return layout;
-}
-
-void
-VFolderMenu::layoutMenu(VFolderMenu::SubMenu *menu, QStringList defaultLayout) //krazy:exclude=passbyvalue
-{
-    if (!menu->defaultLayoutNode.isNull()) {
-        defaultLayout = parseLayoutNode(menu->defaultLayoutNode);
-    }
-
-    if (menu->layoutNode.isNull()) {
-        menu->layoutList = defaultLayout;
-    } else {
-        menu->layoutList = parseLayoutNode(menu->layoutNode);
-        if (menu->layoutList.isEmpty()) {
-            menu->layoutList = defaultLayout;
-        }
-    }
-
-    foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus) {
-        layoutMenu(subMenu, defaultLayout);
-    }
-}
-
-void
-VFolderMenu::markUsedApplications(const QHash<QString, KService::Ptr> &items)
-{
-    foreach (const KService::Ptr &p, items) {
-        m_usedAppsDict.insert(p->menuId());
-    }
-}
-
-VFolderMenu::SubMenu *VFolderMenu::parseMenu(const QString &file)
-{
-    m_appsInfo = 0;
-
-    const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QLatin1String("menus"), QStandardPaths::LocateDirectory);
-    for (QStringList::ConstIterator it = dirs.begin();
-            it != dirs.end(); ++it) {
-        registerDirectory(*it);
-    }
-
-    loadMenu(file);
-
-    delete m_rootMenu;
-    m_rootMenu = m_currentMenu = 0;
-
-    QDomElement docElem = m_doc.documentElement();
-
-    for (int pass = 0; pass <= 2; pass++) {
-        // pass 0: load application desktop files
-        // pass 1: the normal processing
-        // pass 2: process <OnlyUnallocated> to put unused files into "Lost & Found".
-        processMenu(docElem, pass);
-
-        switch (pass) {
-        case 0:
-            // Fill the dictCategories for each AppsInfo in m_appsInfoList,
-            // in preparation for processMenu pass 1.
-            buildApplicationIndex(false);
-            break;
-        case 1:
-            // Fill the dictCategories for each AppsInfo in m_appsInfoList,
-            // with only the unused apps, in preparation for processMenu pass 2.
-            buildApplicationIndex(true /* unusedOnly */);
-            break;
-        case 2: {
-            QStringList defaultLayout;
-            defaultLayout << QStringLiteral(":M"); // Sub-Menus
-            defaultLayout << QStringLiteral(":F"); // Individual entries
-            layoutMenu(m_rootMenu, defaultLayout);
-            break;
-        }
-        default:
-            break;
-        }
-    }
-
-    return m_rootMenu;
-}
-
-void
-VFolderMenu::setTrackId(const QString &id)
-{
-    m_track = !id.isEmpty();
-    m_trackId = id;
-}
-
diff --git a/src/kbuildsycoca/vfolder_menu.h b/src/kbuildsycoca/vfolder_menu.h
deleted file mode 100644
index f4aac24..0000000
--- a/src/kbuildsycoca/vfolder_menu.h
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
-   This file is part of the KDE libraries
-   Copyright (c) 2003 Waldo Bastian <bastian@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License version 2 as published by the Free Software Foundation.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KDED_VFOLDER_MENU_H
-#define KDED_VFOLDER_MENU_H
-
-#include <QtCore/QObject>
-#include <QtXml/QDomDocument>
-#include <QtCore/QStringList>
-#include <QtCore/QHash>
-#include <QtCore/QSet>
-#include <QtCore/QStack>
-
-#include <kservice.h>
-
-class KBuildSycocaInterface;
-class KBuildServiceFactory;
-
-class VFolderMenu : public QObject
-{
-    Q_OBJECT
-public:
-    class AppsInfo;
-    class SubMenu
-    {
-    public:
-        SubMenu() : isDeleted(false), apps_info(0)
-        {
-            items.reserve(43);
-        }
-        ~SubMenu()
-        {
-            qDeleteAll(subMenus);
-        }
-
-    public:
-        QString name;
-        QString directoryFile;
-        QList<SubMenu *> subMenus;
-        QHash<QString, KService::Ptr> items;
-        QHash<QString, KService::Ptr> excludeItems; // Needed when merging due to Move.
-        QDomElement defaultLayoutNode;
-        QDomElement layoutNode;
-        bool isDeleted;
-        QStringList layoutList;
-        AppsInfo *apps_info;
-    };
-
-    VFolderMenu(KBuildServiceFactory *serviceFactory, KBuildSycocaInterface *kbuildsycocaInterface);
-    ~VFolderMenu();
-
-    /**
-     * Parses VFolder menu definition and generates a menu layout.
-     * The newService signals is used as callback to load
-     * a specific service description.
-     *
-     * @param file Menu file to load
-     */
-    SubMenu *parseMenu(const QString &file);
-
-    /**
-     * Returns a list of all directories involved in the last call to
-     * parseMenu().
-     *
-     * A change in any of these directories or in any of their child-
-     * directories can result in changes to the menu.
-     */
-    QStringList allDirectories();
-
-    /**
-     * Debug function to enable tracking of what happens with a specific
-     * menu item id
-     */
-    void setTrackId(const QString &id);
-
-public:
-    struct MenuItem {
-        enum Type { MI_Service, MI_SubMenu, MI_Separator };
-        Type type;
-        KService::Ptr service;
-        SubMenu  *submenu;
-    };
-
-public:
-    QStringList m_allDirectories; // A list of all the directories that we touch
-
-    QStringList m_defaultAppDirs;
-    QStringList m_defaultDirectoryDirs;
-    QStringList m_defaultMergeDirs;
-
-    QStringList m_directoryDirs; // Current set of applicable <DirectoryDir> dirs
-    QHash<QString, SubMenu *> m_legacyNodes; // Dictionary that stores Menu nodes
-    // associated with legacy tree.
-
-    class DocInfo
-    {
-    public:
-        QString baseDir; // Relative base dir of current menu file
-        QString baseName; // Filename of current menu file without ".menu"
-        QString path; // Full path of current menu file including ".menu"
-    };
-
-    DocInfo m_docInfo; // DocInfo for current doc
-    QStack<VFolderMenu::DocInfo> m_docInfoStack;
-
-    class AppsInfo
-    {
-    public:
-        AppsInfo()
-        {
-            dictCategories.reserve(53);
-            applications.reserve(997);
-            appRelPaths.reserve(997);
-        }
-
-        ~AppsInfo()
-        {
-        }
-
-        QHash<QString, KService::List> dictCategories; // category -> apps
-        QHash<QString, KService::Ptr> applications; // rel path -> service
-        QHash<KService::Ptr, QString> appRelPaths; // service -> rel path
-    };
-
-    AppsInfo *m_appsInfo; // AppsInfo for current menu
-    QList<AppsInfo *> m_appsInfoStack; // All applicable AppsInfo for current menu
-    QList<AppsInfo *> m_appsInfoList; // List of all AppsInfo objects.
-    QSet<QString /*menuId*/> m_usedAppsDict; // all applications that have been allocated
-
-    QDomDocument m_doc;
-    SubMenu *m_rootMenu;
-    SubMenu *m_currentMenu;
-    bool m_track;
-    QString m_trackId;
-
-private:
-    /**
-     * Lookup application by relative path
-     */
-    KService::Ptr findApplication(const QString &relPath);
-
-    /**
-     * Lookup applications by category
-     */
-    QList<KService::List *> findCategory(const QString &category);
-
-    /**
-     * Add new application
-     */
-    void addApplication(const QString &id, KService::Ptr service);
-
-    /**
-     * Build application indices
-     */
-    void buildApplicationIndex(bool unusedOnly);
-
-    /**
-     * Create a AppsInfo frame for current menu
-     */
-    void createAppsInfo();
-
-    /**
-     * Load additional AppsInfo frame for current menu
-     */
-    void loadAppsInfo();
-
-    /**
-     * Unload additional AppsInfo frame for current menu
-     */
-    void unloadAppsInfo();
-
-    QDomDocument loadDoc();
-    void mergeMenus(QDomElement &docElem, QString &name);
-    void mergeFile(QDomElement &docElem, const QDomNode &mergeHere);
-    void loadMenu(const QString &filename);
-
-    /**
-     * Merge the items2 set into the items1 set
-     */
-    void includeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
-
-    /**
-     * Remove all items from the items1 set that aren't also in the items2 set
-     */
-    void matchItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
-
-    /**
-     * Remove all items in the items2 set from the items1 set
-     */
-    void excludeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
-
-    /**
-     * Search the parentMenu tree for the menu menuName and takes it
-     * out.
-     *
-     * This function returns a pointer to the menu if it was found
-     * or 0 if it was not found.
-     */
-    SubMenu *takeSubMenu(SubMenu *parentMenu, const QString &menuName);
-
-    /**
-     * Insert the menu newMenu with name menuName into the parentMenu.
-     * If such menu already exist the result is merged, if any additional
-     * submenus are required they are created.
-     * If reversePriority is false, newMenu has priority over the existing
-     * menu during merging.
-     * If reversePriority is true, the existing menu has priority over newMenu
-     * during merging.
-     */
-    void insertSubMenu(VFolderMenu::SubMenu *parentMenu, const QString &menuName, VFolderMenu::SubMenu *newMenu, bool reversePriority = false);
-
-    /**
-     * Merge menu2 and its submenus into menu1 and its submenus
-     * If reversePriority is false, menu2 has priority over menu1
-     * If reversePriority is true, menu1 has priority over menu2
-     */
-    void mergeMenu(SubMenu *menu1, SubMenu *menu2, bool reversePriority = false);
-
-    /**
-     * Inserts service into the menu using name relative to parentMenu
-     * Any missing sub-menus are created.
-     */
-    void insertService(SubMenu *parentMenu, const QString &name, KService::Ptr newService);
-
-    /**
-     * Register the directory that @p file is in.
-     * @see allDirectories()
-     */
-    void registerFile(const QString &file);
-
-    /**
-     * Fill m_usedAppsDict with all applications from @p items
-     */
-    void markUsedApplications(const QHash<QString, KService::Ptr> &items);
-
-    /**
-     * Register @p directory
-     * @see allDirectories()
-     */
-    void registerDirectory(const QString &directory);
-
-    void processLegacyDir(const QString &dir, const QString &relDir, const QString &prefix);
-    void processMenu(QDomElement &docElem, int pass);
-    void layoutMenu(VFolderMenu::SubMenu *menu, QStringList defaultLayout);
-    void processCondition(QDomElement &docElem, QHash<QString, KService::Ptr> &items);
-
-    void initDirs();
-
-    void pushDocInfo(const QString &fileName, const QString &baseDir = QString());
-    void pushDocInfoParent(const QString &basePath, const QString &baseDir);
-    void popDocInfo();
-
-    QString absoluteDir(const QString &_dir, const QString &baseDir, bool keepRelativeToCfg = false);
-    QString locateMenuFile(const QString &fileName);
-    QString locateDirectoryFile(const QString &fileName);
-    void loadApplications(const QString &, const QString &);
-
-private:
-    KBuildServiceFactory *m_serviceFactory;
-    KBuildSycocaInterface *m_kbuildsycocaInterface;
-};
-
-#endif
diff --git a/src/services/kmimetypefactory_p.h b/src/services/kmimetypefactory_p.h
index 299c970..ab372fc 100644
--- a/src/services/kmimetypefactory_p.h
+++ b/src/services/kmimetypefactory_p.h
@@ -36,7 +36,7 @@ class KSycoca;
  * This is only used to point to the "service offers" in ksycoca for each mimetype.
  * @see KMimeType
  */
-class KSERVICE_EXPORT KMimeTypeFactory : public KSycocaFactory
+class KMimeTypeFactory : public KSycocaFactory
 {
     K_SYCOCAFACTORY(KST_KMimeTypeFactory)
 public:
diff --git a/src/services/kplugininfo.cpp b/src/services/kplugininfo.cpp
index 56eb192..93dcb8f 100644
--- a/src/services/kplugininfo.cpp
+++ b/src/services/kplugininfo.cpp
@@ -382,8 +382,10 @@ QList<KPluginInfo> KPluginInfo::fromServices(const KService::List &services, con
     for (KService::List::ConstIterator it = services.begin();
             it != services.end(); ++it) {
         KPluginInfo info(*it);
-        info.setConfig(config);
-        infolist += info;
+        if (info.isValid()) {
+            info.setConfig(config);
+            infolist += info;
+        }
     }
     return infolist;
 }
diff --git a/src/services/kservicefactory_p.h b/src/services/kservicefactory_p.h
index 35dcf9a..2747487 100644
--- a/src/services/kservicefactory_p.h
+++ b/src/services/kservicefactory_p.h
@@ -36,7 +36,7 @@ class KSycocaDict;
  * It loads the services from parsing directories (e.g. prefix/share/applications/)
  * but can also create service from data streams or single config files
  *
- * Exported for kbuildsycoca, but not installed.
+ * Exported for unit tests
  */
 class KSERVICE_EXPORT KServiceFactory : public KSycocaFactory
 {
diff --git a/src/services/kservicegroupfactory_p.h b/src/services/kservicegroupfactory_p.h
index 09ffd18..0314b7d 100644
--- a/src/services/kservicegroupfactory_p.h
+++ b/src/services/kservicegroupfactory_p.h
@@ -35,7 +35,7 @@ class KSycocaDict;
  *
  * Exported for kbuildsycoca, but not installed.
  */
-class KSERVICE_EXPORT KServiceGroupFactory : public KSycocaFactory
+class KServiceGroupFactory : public KSycocaFactory
 {
     K_SYCOCAFACTORY(KST_KServiceGroupFactory)
 public:
diff --git a/src/services/kservicetypefactory_p.h b/src/services/kservicetypefactory_p.h
index 520f7f8..2a2dc5e 100644
--- a/src/services/kservicetypefactory_p.h
+++ b/src/services/kservicetypefactory_p.h
@@ -37,10 +37,8 @@ class KServiceType;
  * It loads the service types from parsing directories (e.g. servicetypes/)
  * but can also create service types from data streams or single config files
  * @see KServiceType
- *
- * Exported for kbuildsycoca, but not installed.
  */
-class KSERVICE_EXPORT KServiceTypeFactory : public KSycocaFactory
+class KServiceTypeFactory : public KSycocaFactory
 {
     K_SYCOCAFACTORY(KST_KServiceTypeFactory)
 public:
diff --git a/src/sycoca/kbuildmimetypefactory.cpp b/src/sycoca/kbuildmimetypefactory.cpp
new file mode 100644
index 0000000..5d32b35
--- /dev/null
+++ b/src/sycoca/kbuildmimetypefactory.cpp
@@ -0,0 +1,112 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 1999-2007 David Faure <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kbuildmimetypefactory_p.h"
+#include "ksycoca.h"
+#include "ksycocadict_p.h"
+#include "ksycocaresourcelist_p.h"
+
+#include <assert.h>
+#include <QDebug>
+#include <QtCore/QHash>
+#include <qstandardpaths.h>
+
+KBuildMimeTypeFactory::KBuildMimeTypeFactory(KSycoca *db)
+    : KMimeTypeFactory(db)
+{
+    m_resourceList = new KSycocaResourceList;
+    // We want all xml files under xdgdata/mime - but not mime/packages/*.xml
+    m_resourceList->add("xdgdata-mime", "mime", "*.xml");
+}
+
+KBuildMimeTypeFactory::~KBuildMimeTypeFactory()
+{
+    delete m_resourceList;
+}
+
+KSycocaEntry::List KBuildMimeTypeFactory::allEntries() const
+{
+    assert(sycoca()->isBuilding());
+    KSycocaEntry::List lst;
+    KSycocaEntryDict::Iterator itmime = m_entryDict->begin();
+    const KSycocaEntryDict::Iterator endmime = m_entryDict->end();
+    for (; itmime != endmime; ++itmime) {
+        lst.append(*itmime);
+    }
+    return lst;
+}
+
+KSycocaEntry *KBuildMimeTypeFactory::createEntry(const QString &file) const
+{
+    // file=text/plain.xml  ->  name=plain.xml dirName=text
+    Q_ASSERT(!file.startsWith("mime/"));
+
+    const int pos = file.lastIndexOf('/');
+    if (pos == -1) { // huh?
+        return 0;
+    }
+    const QString dirName = file.left(pos);
+    if (dirName == "packages") { // special subdir
+        return 0;
+    }
+
+    const int dot = file.lastIndexOf('.');
+    if (dot == -1) { // huh?
+        return 0;
+    }
+    const QString name = file.left(dot);
+
+    //qDebug() << "Creating mimetype" << name << "from file" << file;
+
+    MimeTypeEntry *e = new MimeTypeEntry(file, name);
+    return e;
+}
+
+void KBuildMimeTypeFactory::saveHeader(QDataStream &str)
+{
+    KSycocaFactory::saveHeader(str);
+}
+
+void KBuildMimeTypeFactory::save(QDataStream &str)
+{
+    KSycocaFactory::save(str);
+
+    str << qint32(0);
+
+    const int endOfFactoryData = str.device()->pos();
+
+    // Update header (pass #3)
+    saveHeader(str);
+
+    // Seek to end.
+    str.device()->seek(endOfFactoryData);
+}
+
+void KBuildMimeTypeFactory::createFakeMimeType(const QString &name)
+{
+    const QString file = name; // hack
+    KSycocaEntry::Ptr entry = m_entryDict->value(file);
+    if (!entry) {
+        MimeTypeEntry *e = new MimeTypeEntry(file, name);
+        entry = e;
+    }
+
+    Q_ASSERT(entry && entry->isValid());
+    addEntry(entry);
+}
diff --git a/src/sycoca/kbuildmimetypefactory_p.h b/src/sycoca/kbuildmimetypefactory_p.h
new file mode 100644
index 0000000..15f5e20
--- /dev/null
+++ b/src/sycoca/kbuildmimetypefactory_p.h
@@ -0,0 +1,69 @@
+/* This file is part of the KDE project
+   Copyright 1999-2007 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KBUILD_MIME_TYPE_FACTORY_H
+#define KBUILD_MIME_TYPE_FACTORY_H
+
+#include <kmimetypefactory_p.h>
+#include <QtCore/QStringList>
+
+/**
+ * Mime-type factory for building ksycoca
+ * @internal
+ */
+class KBuildMimeTypeFactory : public KMimeTypeFactory
+{
+public:
+    /**
+     * Create factory
+     */
+    KBuildMimeTypeFactory(KSycoca *db);
+
+    virtual ~KBuildMimeTypeFactory();
+
+    KSycocaEntry::List allEntries() const Q_DECL_OVERRIDE;
+
+    /**
+     * Construct a KMimeType from a config file.
+     */
+    KSycocaEntry *createEntry(const QString &file) const Q_DECL_OVERRIDE;
+
+    MimeTypeEntry *createEntry(int) const Q_DECL_OVERRIDE
+    {
+        assert(0);
+        return 0L;
+    }
+
+    void createFakeMimeType(const QString &name);
+
+    /**
+     * Write out mime type specific index files.
+     */
+    void save(QDataStream &str) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out header information
+     *
+     * Don't forget to call the parent first when you override
+     * this function.
+     */
+    void saveHeader(QDataStream &str) Q_DECL_OVERRIDE;
+};
+
+#endif
diff --git a/src/sycoca/kbuildservicefactory.cpp b/src/sycoca/kbuildservicefactory.cpp
new file mode 100644
index 0000000..bebb769
--- /dev/null
+++ b/src/sycoca/kbuildservicefactory.cpp
@@ -0,0 +1,422 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999, 2007 David Faure <faure@kde.org>
+ *                1999 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "kbuildservicefactory_p.h"
+#include "kbuildservicegroupfactory_p.h"
+#include "kbuildmimetypefactory_p.h"
+#include "kservicetypefactory_p.h"
+#include "ksycoca.h"
+#include "ksycocadict_p.h"
+#include "ksycocaresourcelist_p.h"
+#include "kdesktopfile.h"
+#include <kservicetype.h>
+
+#include <QDebug>
+#include <QDir>
+#include <qmimedatabase.h>
+
+#include <assert.h>
+#include <kmimetypefactory_p.h>
+#include <qstandardpaths.h>
+
+KBuildServiceFactory::KBuildServiceFactory(KServiceTypeFactory *serviceTypeFactory,
+        KBuildMimeTypeFactory *mimeTypeFactory,
+        KBuildServiceGroupFactory *serviceGroupFactory) :
+    KServiceFactory(serviceTypeFactory->sycoca()),
+    m_nameMemoryHash(),
+    m_relNameMemoryHash(),
+    m_menuIdMemoryHash(),
+    m_dupeDict(),
+    m_serviceTypeFactory(serviceTypeFactory),
+    m_mimeTypeFactory(mimeTypeFactory),
+    m_serviceGroupFactory(serviceGroupFactory)
+{
+    m_resourceList = new KSycocaResourceList();
+    // We directly care about services desktop files.
+    // All the application desktop files are parsed on demand from the vfolder menu code.
+    m_resourceList->add("services", "kservices5", "*.desktop");
+
+    m_nameDict = new KSycocaDict();
+    m_relNameDict = new KSycocaDict();
+    m_menuIdDict = new KSycocaDict();
+}
+
+KBuildServiceFactory::~KBuildServiceFactory()
+{
+    delete m_resourceList;
+}
+
+KService::Ptr KBuildServiceFactory::findServiceByDesktopName(const QString &name)
+{
+    return m_nameMemoryHash.value(name);
+}
+
+KService::Ptr KBuildServiceFactory::findServiceByDesktopPath(const QString &name)
+{
+    return m_relNameMemoryHash.value(name);
+}
+
+KService::Ptr KBuildServiceFactory::findServiceByMenuId(const QString &menuId)
+{
+    return m_menuIdMemoryHash.value(menuId);
+}
+
+KSycocaEntry *KBuildServiceFactory::createEntry(const QString &file) const
+{
+    Q_ASSERT(!file.startsWith("kservices5/")); // we add this ourselves, below
+
+    QString name = file;
+    int pos = name.lastIndexOf('/');
+    if (pos != -1) {
+        name = name.mid(pos + 1);
+    }
+    // Is it a .desktop file?
+    if (name.endsWith(QLatin1String(".desktop"))) {
+
+        //qDebug() << file;
+
+        KService *serv;
+        if (QDir::isAbsolutePath(file)) { // vfolder sends us full paths for applications
+            serv = new KService(file);
+        } else { // we get relative paths for services
+            KDesktopFile desktopFile(QStandardPaths::GenericDataLocation, "kservices5/" + file);
+            // Note that the second arg below MUST be 'file', unchanged.
+            // If the entry path doesn't match the 'file' parameter to createEntry, reusing old entries
+            // (via time dict, which uses the entry path as key) cannot work.
+            serv = new KService(&desktopFile, file);
+        }
+
+        //qDebug() << "Creating KService from" << file << "entryPath=" << serv->entryPath();
+        // Note that the menuId will be set by the vfolder_menu.cpp code just after
+        // createEntry returns.
+
+        if (serv->isValid() && !serv->isDeleted()) {
+            //qDebug() << "Creating KService from" << file << "entryPath=" << serv->entryPath() << "storageId=" << serv->storageId();
+            return serv;
+        } else {
+            if (!serv->isDeleted()) {
+                qWarning() << "Invalid Service : " << file;
+            }
+            delete serv;
+            return 0;
+        }
+    } // TODO else if a Windows application,  new KService(name, exec, icon)
+    return 0;
+}
+
+void KBuildServiceFactory::saveHeader(QDataStream &str)
+{
+    KSycocaFactory::saveHeader(str);
+
+    str << qint32(m_nameDictOffset);
+    str << qint32(m_relNameDictOffset);
+    str << qint32(m_offerListOffset);
+    str << qint32(m_menuIdDictOffset);
+}
+
+void KBuildServiceFactory::save(QDataStream &str)
+{
+    KSycocaFactory::save(str);
+
+    m_nameDictOffset = str.device()->pos();
+    m_nameDict->save(str);
+
+    m_relNameDictOffset = str.device()->pos();
+    m_relNameDict->save(str);
+
+    saveOfferList(str);
+
+    m_menuIdDictOffset = str.device()->pos();
+    m_menuIdDict->save(str);
+
+    int endOfFactoryData = str.device()->pos();
+
+    // Update header (pass #3)
+    saveHeader(str);
+
+    // Seek to end.
+    str.device()->seek(endOfFactoryData);
+}
+
+void KBuildServiceFactory::collectInheritedServices()
+{
+    // For each mimetype, go up the parent-mimetype chains and collect offers.
+    // For "removed associations" to work, we can't just grab everything from all parents.
+    // We need to process parents before children, hence the recursive call in
+    // collectInheritedServices(mime) and the QSet to process a given parent only once.
+    QSet<QString> visitedMimes;
+    const QStringList allMimeTypes = m_mimeTypeFactory->allMimeTypes();
+    Q_FOREACH (const QString &mimeType, allMimeTypes) {
+        collectInheritedServices(mimeType, visitedMimes);
+    }
+}
+
+void KBuildServiceFactory::collectInheritedServices(const QString &mimeTypeName, QSet<QString> &visitedMimes)
+{
+    if (visitedMimes.contains(mimeTypeName)) {
+        return;
+    }
+    visitedMimes.insert(mimeTypeName);
+
+    // With multiple inheritance, the "mimeTypeInheritanceLevel" isn't exactly
+    // correct (it should only be increased when going up a level, not when iterating
+    // through the multiple parents at a given level). I don't think we care, though.
+    int mimeTypeInheritanceLevel = 0;
+
+    QMimeDatabase db;
+    QMimeType qmime = db.mimeTypeForName(mimeTypeName);
+    Q_FOREACH (const QString &parentMimeType, qmime.parentMimeTypes()) {
+
+        collectInheritedServices(parentMimeType, visitedMimes);
+
+        ++mimeTypeInheritanceLevel;
+        const QList<KServiceOffer> &offers = m_offerHash.offersFor(parentMimeType);
+        QList<KServiceOffer>::const_iterator itserv = offers.begin();
+        const QList<KServiceOffer>::const_iterator endserv = offers.end();
+        for (; itserv != endserv; ++itserv) {
+            if (!m_offerHash.hasRemovedOffer(mimeTypeName, (*itserv).service())) {
+                KServiceOffer offer(*itserv);
+                offer.setMimeTypeInheritanceLevel(mimeTypeInheritanceLevel);
+                //qDebug() << "INHERITANCE: Adding service" << (*itserv).service()->entryPath() << "to" << mimeTypeName << "mimeTypeInheritanceLevel=" << mimeTypeInheritanceLevel;
+                m_offerHash.addServiceOffer(mimeTypeName, offer);
+            }
+        }
+    }
+}
+
+void KBuildServiceFactory::postProcessServices()
+{
+    // By doing all this here rather than in addEntry (and removing when replacing
+    // with local override), we only do it for the final applications.
+    // Note that this also affects resolution of the by-desktop-name lookup,
+    // as name resolution is only performed *after* all the duplicates (based on
+    // storage ID) have been removed.
+
+    // For every service...
+    KSycocaEntryDict::Iterator itserv = m_entryDict->begin();
+    const KSycocaEntryDict::Iterator endserv = m_entryDict->end();
+    for (; itserv != endserv; ++itserv) {
+
+        KSycocaEntry::Ptr entry = *itserv;
+        KService::Ptr service(static_cast<KService*>(entry.data()));
+
+        if (!service->isDeleted()) {
+            const QString parent = service->parentApp();
+            if (!parent.isEmpty()) {
+                m_serviceGroupFactory->addNewChild(parent, KSycocaEntry::Ptr(service));
+            }
+        }
+
+        const QString name = service->desktopEntryName();
+        KService::Ptr dup = m_nameMemoryHash.value(name);
+        if (dup) {
+            // The rule is that searching for the desktop name "foo" should find
+            // the desktop file with the storage id "foo.desktop" before it
+            // finds "bar/foo.desktop" (or "bar-foo.desktop").
+            // "bar/foo.desktop" and "baz/foo.desktop" are arbitrarily ordered
+            // (in practice, the one later in the alphabet wins).
+            if (dup->storageId().endsWith(service->storageId())) {
+                // allow dup to be overridden
+                m_nameDict->remove(name);
+                dup = 0;
+            }
+        }
+        if (!dup) {
+            m_nameDict->add(name, entry);
+            m_nameMemoryHash.insert(name, service);
+        }
+
+        const QString relName = service->entryPath();
+        //qDebug() << "adding service" << service.data() << "isApp=" << service->isApplication() << "menuId=" << service->menuId() << "name=" << name << "relName=" << relName;
+        m_relNameDict->add(relName, entry);
+        m_relNameMemoryHash.insert(relName, service); // for KMimeAssociations
+
+        const QString menuId = service->menuId();
+        if (!menuId.isEmpty()) { // empty for services, non-empty for applications
+            m_menuIdDict->add(menuId, entry);
+            m_menuIdMemoryHash.insert(menuId, service); // for KMimeAssociations
+        }
+    }
+    populateServiceTypes();
+}
+
+void KBuildServiceFactory::populateServiceTypes()
+{
+    QMimeDatabase db;
+    // For every service...
+    KSycocaEntryDict::Iterator itserv = m_entryDict->begin();
+    const KSycocaEntryDict::Iterator endserv = m_entryDict->end();
+    for (; itserv != endserv; ++itserv) {
+
+        KService::Ptr service(static_cast<KService*>((*itserv).data()));
+        QVector<KService::ServiceTypeAndPreference> serviceTypeList = service->_k_accessServiceTypes();
+        //bool hasAllAll = false;
+        //bool hasAllFiles = false;
+
+        // Add this service to all its servicetypes (and their parents) and to all its mimetypes
+        for (int i = 0; i < serviceTypeList.count() /*don't cache it, it can change during iteration!*/; ++i) {
+            const QString stName = serviceTypeList[i].serviceType;
+            // It could be a servicetype or a mimetype.
+            KServiceType::Ptr serviceType = m_serviceTypeFactory->findServiceTypeByName(stName);
+            if (serviceType) {
+                const int preference = serviceTypeList[i].preference;
+                const QString parent = serviceType->parentServiceType();
+                if (!parent.isEmpty()) {
+                    serviceTypeList.append(KService::ServiceTypeAndPreference(preference, parent));
+                }
+
+                //qDebug() << "Adding service" << service->entryPath() << "to" << serviceType->name() << "pref=" << preference;
+                m_offerHash.addServiceOffer(stName, KServiceOffer(service, preference, 0, service->allowAsDefault()));
+            } else {
+                KServiceOffer offer(service, serviceTypeList[i].preference, 0, service->allowAsDefault());
+                QMimeType mime = db.mimeTypeForName(stName);
+                if (!mime.isValid()) {
+                    if (stName.startsWith(QLatin1String("x-scheme-handler/"))) {
+                        // Create those on demand
+                        m_mimeTypeFactory->createFakeMimeType(stName);
+                        m_offerHash.addServiceOffer(stName, offer);
+                    } else {
+                        //qDebug() << service->entryPath() << "specifies undefined mimetype/servicetype" << stName;
+                        // technically we could call addServiceOffer here, 'mime' isn't used. But it
+                        // would be useless, since the loops for writing out the offers iterate
+                        // over all known servicetypes and mimetypes. Unknown -> never written out.
+                        continue;
+                    }
+                } else {
+                    bool shouldAdd = true;
+                    foreach (const QString &otherType, service->serviceTypes()) {
+                        // Skip derived types if the base class is listed (#321706)
+                        if (stName != otherType && mime.inherits(otherType)) {
+                            // But don't skip aliases (they got resolved into mime->name() already, but don't let two aliases cancel out)
+                            if (db.mimeTypeForName(otherType).name() != mime.name()) {
+                                //qDebug() << "Skipping" << mime->name() << "because of" << otherType << "(canonical" << KMimeTypeRepository::self()->canonicalName(otherType) << ") while parsing" << service->entryPath();
+                                shouldAdd = false;
+                            }
+                        }
+                    }
+                    if (shouldAdd) {
+                        //qDebug() << "Adding service" << service->entryPath() << "to" << mime->name();
+                        m_offerHash.addServiceOffer(mime.name(), offer); // mime->name so that we resolve aliases
+                    }
+                }
+            }
+        }
+    }
+
+    // Read user preferences (added/removed associations) and add/remove serviceoffers to m_offerHash
+    KMimeAssociations mimeAssociations(m_offerHash, this);
+    mimeAssociations.parseAllMimeAppsList();
+
+    // Now for each mimetype, collect services from parent mimetypes
+    collectInheritedServices();
+
+    // Now collect the offsets into the (future) offer list
+    // The loops look very much like the ones in saveOfferList obviously.
+    int offersOffset = 0;
+    const int offerEntrySize = sizeof(qint32) * 4;   // four qint32s, see saveOfferList.
+
+    // TODO: idea: we could iterate over m_offerHash, and look up the servicetype or mimetype.
+    // Would that be faster than iterating over all servicetypes and mimetypes?
+
+    KSycocaEntryDict::const_iterator itstf = m_serviceTypeFactory->entryDict()->constBegin();
+    const KSycocaEntryDict::const_iterator endstf = m_serviceTypeFactory->entryDict()->constEnd();
+    for (; itstf != endstf; ++itstf) {
+        KServiceType::Ptr entry(static_cast<KServiceType*>((*itstf).data()));
+        const int numOffers = m_offerHash.offersFor(entry->name()).count();
+        if (numOffers) {
+            entry->setServiceOffersOffset(offersOffset);
+            offersOffset += offerEntrySize * numOffers;
+        }
+    }
+    KSycocaEntryDict::const_iterator itmtf = m_mimeTypeFactory->entryDict()->constBegin();
+    const KSycocaEntryDict::const_iterator endmtf = m_mimeTypeFactory->entryDict()->constEnd();
+    for (; itmtf != endmtf; ++itmtf) {
+        KMimeTypeFactory::MimeTypeEntry::Ptr entry(static_cast<KMimeTypeFactory::MimeTypeEntry*>((*itmtf).data()));
+        const int numOffers = m_offerHash.offersFor(entry->name()).count();
+        if (numOffers) {
+            //qDebug() << entry->name() << "offset=" << offersOffset;
+            entry->setServiceOffersOffset(offersOffset);
+            offersOffset += offerEntrySize * numOffers;
+        }
+    }
+}
+
+void KBuildServiceFactory::saveOfferList(QDataStream &str)
+{
+    m_offerListOffset = str.device()->pos();
+
+    // For each entry in servicetypeFactory
+    KSycocaEntryDict::const_iterator itstf = m_serviceTypeFactory->entryDict()->constBegin();
+    const KSycocaEntryDict::const_iterator endstf = m_serviceTypeFactory->entryDict()->constEnd();
+    for (; itstf != endstf; ++itstf) {
+        // export associated services
+        const KServiceType::Ptr entry(static_cast<KServiceType*>((*itstf).data()));
+        Q_ASSERT(entry);
+
+        QList<KServiceOffer> offers = m_offerHash.offersFor(entry->name());
+        qStableSort(offers);   // by initial preference
+
+        for (QList<KServiceOffer>::const_iterator it2 = offers.constBegin();
+                it2 != offers.constEnd(); ++it2) {
+            //qDebug() << "servicetype offers list:" << entry->name() << "->" << (*it2).service()->entryPath();
+
+            str << qint32(entry->offset());
+            str << qint32((*it2).service()->offset());
+            str << qint32((*it2).preference());
+            str << qint32(0); // mimeTypeInheritanceLevel
+            // update offerEntrySize in populateServiceTypes if you add/remove something here
+        }
+    }
+
+    // For each entry in mimeTypeFactory
+    KSycocaEntryDict::const_iterator itmtf = m_mimeTypeFactory->entryDict()->constBegin();
+    const KSycocaEntryDict::const_iterator endmtf = m_mimeTypeFactory->entryDict()->constEnd();
+    for (; itmtf != endmtf; ++itmtf) {
+        // export associated services
+        const KMimeTypeFactory::MimeTypeEntry::Ptr entry(static_cast<KMimeTypeFactory::MimeTypeEntry*>((*itmtf).data()));
+        Q_ASSERT(entry);
+        QList<KServiceOffer> offers = m_offerHash.offersFor(entry->name());
+        qStableSort(offers);   // by initial preference
+
+        for (QList<KServiceOffer>::const_iterator it2 = offers.constBegin();
+                it2 != offers.constEnd(); ++it2) {
+            //qDebug() << "mimetype offers list:" << entry->name() << "->" << (*it2).service()->entryPath() << "pref" << (*it2).preference();
+            Q_ASSERT((*it2).service()->offset() != 0);
+            str << qint32(entry->offset());
+            str << qint32((*it2).service()->offset());
+            str << qint32((*it2).preference());
+            str << qint32((*it2).mimeTypeInheritanceLevel());
+            // update offerEntrySize in populateServiceTypes if you add/remove something here
+        }
+    }
+
+    str << qint32(0);               // End of list marker (0)
+}
+
+void KBuildServiceFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
+{
+    Q_ASSERT(newEntry);
+    if (m_dupeDict.contains(newEntry)) {
+        return;
+    }
+
+    const KService::Ptr service(static_cast<KService*>(newEntry.data()));
+    m_dupeDict.insert(newEntry);
+    KSycocaFactory::addEntry(newEntry);
+}
diff --git a/src/sycoca/kbuildservicefactory_p.h b/src/sycoca/kbuildservicefactory_p.h
new file mode 100644
index 0000000..d1086f8
--- /dev/null
+++ b/src/sycoca/kbuildservicefactory_p.h
@@ -0,0 +1,105 @@
+/* This file is part of the KDE project
+   Copyright (C) 1999, 2007 David Faure <faure@kde.org>
+                 1999 Waldo Bastian <bastian@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KBUILD_SERVICE_FACTORY_H
+#define KBUILD_SERVICE_FACTORY_H
+
+#include <QtCore/QStringList>
+
+#include "kmimeassociations_p.h"
+#include <kservicefactory_p.h>
+// We export the services to the service group factory!
+class KBuildServiceGroupFactory;
+class KBuildMimeTypeFactory;
+class KServiceTypeFactory;
+
+/**
+ * Service factory for building ksycoca
+ * @internal
+ */
+class KBuildServiceFactory : public KServiceFactory
+{
+public:
+    /**
+     * Create factory
+     */
+    KBuildServiceFactory(KServiceTypeFactory *serviceTypeFactory,
+                         KBuildMimeTypeFactory *mimeTypeFactory,
+                         KBuildServiceGroupFactory *serviceGroupFactory);
+
+    virtual ~KBuildServiceFactory();
+
+    /// Reimplemented from KServiceFactory
+    KService::Ptr findServiceByDesktopName(const QString &name) Q_DECL_OVERRIDE;
+    /// Reimplemented from KServiceFactory
+    KService::Ptr findServiceByDesktopPath(const QString &name) Q_DECL_OVERRIDE;
+    /// Reimplemented from KServiceFactory
+    KService::Ptr findServiceByMenuId(const QString &menuId) Q_DECL_OVERRIDE;
+
+    /**
+     * Construct a KService from a config file.
+     */
+    KSycocaEntry *createEntry(const QString &file) const Q_DECL_OVERRIDE;
+
+    KService *createEntry(int) const Q_DECL_OVERRIDE
+    {
+        assert(0);
+        return 0;
+    }
+
+    /**
+     * Add a new entry.
+     */
+    void addEntry(const KSycocaEntry::Ptr &newEntry) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out service specific index files.
+     */
+    void save(QDataStream &str) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out header information
+     *
+     * Don't forget to call the parent first when you override
+     * this function.
+     */
+    void saveHeader(QDataStream &str) Q_DECL_OVERRIDE;
+
+    void postProcessServices();
+
+private:
+    void populateServiceTypes();
+    void saveOfferList(QDataStream &str);
+    void collectInheritedServices();
+    void collectInheritedServices(const QString &mime, QSet<QString> &visitedMimes);
+
+    QHash<QString, KService::Ptr> m_nameMemoryHash; // m_nameDict is not useable while building ksycoca
+    QHash<QString, KService::Ptr> m_relNameMemoryHash; // m_relNameDict is not useable while building ksycoca
+    QHash<QString, KService::Ptr> m_menuIdMemoryHash; // m_menuIdDict is not useable while building ksycoca
+    QSet<KSycocaEntry::Ptr> m_dupeDict;
+
+    KOfferHash m_offerHash;
+
+    KServiceTypeFactory *m_serviceTypeFactory;
+    KBuildMimeTypeFactory *m_mimeTypeFactory;
+    KBuildServiceGroupFactory *m_serviceGroupFactory;
+};
+
+#endif
diff --git a/src/sycoca/kbuildservicegroupfactory.cpp b/src/sycoca/kbuildservicegroupfactory.cpp
new file mode 100644
index 0000000..6ac0fc4
--- /dev/null
+++ b/src/sycoca/kbuildservicegroupfactory.cpp
@@ -0,0 +1,174 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "kbuildservicegroupfactory_p.h"
+#include "ksycoca.h"
+#include "ksycocadict_p.h"
+#include "ksycocaresourcelist_p.h"
+#include <kservicegroup_p.h>
+
+#include <QDebug>
+#include <assert.h>
+#include <QtCore/QHash>
+
+KBuildServiceGroupFactory::KBuildServiceGroupFactory(KSycoca *db)
+    : KServiceGroupFactory(db)
+{
+    m_resourceList = new KSycocaResourceList;
+//   m_resourceList->add( "apps", "*.directory" );
+
+    m_baseGroupDict = new KSycocaDict();
+}
+
+KBuildServiceGroupFactory::~KBuildServiceGroupFactory()
+{
+    delete m_resourceList;
+}
+
+KServiceGroup *KBuildServiceGroupFactory::createEntry(const QString &) const
+{
+    // Unused
+    qWarning() << "called!";
+    return 0;
+}
+
+void KBuildServiceGroupFactory::addNewEntryTo(const QString &menuName, const KService::Ptr &newEntry)
+{
+    KSycocaEntry::Ptr ptr = m_entryDict->value(menuName);
+    KServiceGroup::Ptr entry;
+    if (ptr && ptr->isType(KST_KServiceGroup)) {
+        entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
+    }
+
+    if (!entry) {
+        qWarning() << "( " << menuName << ", " << newEntry->name() << " ): menu does not exists!";
+        return;
+    }
+    entry->addEntry(KSycocaEntry::Ptr(newEntry));
+}
+
+KServiceGroup::Ptr
+KBuildServiceGroupFactory::addNew(const QString &menuName, const QString &file, KServiceGroup::Ptr entry, bool isDeleted)
+{
+    KSycocaEntry::Ptr ptr = m_entryDict->value(menuName);
+    if (ptr) {
+        qWarning() << "( " << menuName << ", " << file << " ): menu already exists!";
+        return KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
+    }
+
+    // Create new group entry
+    if (!entry) {
+        entry = new KServiceGroup(file, menuName);
+    }
+
+    entry->d_func()->m_childCount = -1; // Recalculate
+
+    addEntry(KSycocaEntry::Ptr(entry));
+
+    if (menuName != "/") {
+        // Make sure parent dir exists.
+        QString parent = menuName.left(menuName.length() - 1);
+        int i = parent.lastIndexOf('/');
+        if (i > 0) {
+            parent = parent.left(i + 1);
+        } else {
+            parent = '/';
+        }
+
+        KServiceGroup::Ptr parentEntry;
+        ptr = m_entryDict->value(parent);
+        if (ptr && ptr->isType(KST_KServiceGroup)) {
+            parentEntry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
+        }
+        if (!parentEntry) {
+            qWarning() << "( " << menuName << ", " << file << " ): parent menu does not exist!";
+        } else {
+            if (!isDeleted && !entry->isDeleted()) {
+                parentEntry->addEntry(KSycocaEntry::Ptr(entry));
+            }
+        }
+    }
+    return entry;
+}
+
+void
+KBuildServiceGroupFactory::addNewChild(const QString &parent, const KSycocaEntry::Ptr &newEntry)
+{
+    QString name = "#parent#" + parent;
+
+    KServiceGroup::Ptr entry;
+    KSycocaEntry::Ptr ptr = m_entryDict->value(name);
+    if (ptr && ptr->isType(KST_KServiceGroup)) {
+        entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(ptr.data()));
+    }
+
+    if (!entry) {
+        entry = new KServiceGroup(name);
+        addEntry(KSycocaEntry::Ptr(entry));
+    }
+    if (newEntry) {
+        entry->addEntry(newEntry);
+    }
+}
+
+void
+KBuildServiceGroupFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
+{
+    KSycocaFactory::addEntry(newEntry);
+
+    KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(newEntry.data()));
+    serviceGroup->d_func()->m_serviceList.clear();
+
+    if (!serviceGroup->baseGroupName().isEmpty()) {
+        m_baseGroupDict->add(serviceGroup->baseGroupName(), newEntry);
+    }
+}
+
+void
+KBuildServiceGroupFactory::saveHeader(QDataStream &str)
+{
+    KSycocaFactory::saveHeader(str);
+
+    str << qint32(m_baseGroupDictOffset);
+}
+
+void
+KBuildServiceGroupFactory::save(QDataStream &str)
+{
+    KSycocaFactory::save(str);
+
+    m_baseGroupDictOffset = str.device()->pos();
+    m_baseGroupDict->save(str);
+
+    int endOfFactoryData = str.device()->pos();
+
+    // Update header (pass #3)
+    saveHeader(str);
+
+    // Seek to end.
+    str.device()->seek(endOfFactoryData);
+}
+
+KServiceGroup::Ptr KBuildServiceGroupFactory::findGroupByDesktopPath(const QString &_name, bool deep)
+{
+    assert(sycoca()->isBuilding());
+    Q_UNUSED(deep); // ?
+    // We're building a database - the service type must be in memory
+    KSycocaEntry::Ptr group = m_entryDict->value(_name);
+    return KServiceGroup::Ptr(static_cast<KServiceGroup*>(group.data()));
+}
diff --git a/src/sycoca/kbuildservicegroupfactory_p.h b/src/sycoca/kbuildservicegroupfactory_p.h
new file mode 100644
index 0000000..01c1230
--- /dev/null
+++ b/src/sycoca/kbuildservicegroupfactory_p.h
@@ -0,0 +1,92 @@
+/* This file is part of the KDE project
+   Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KBUILD_SERVICE_GROUP_FACTORY_H
+#define KBUILD_SERVICE_GROUP_FACTORY_H
+
+#include <kservice.h>
+#include <kservicegroupfactory_p.h>
+#include <QtCore/QStringList>
+
+/**
+ * Service group factory for building ksycoca
+ * @internal
+ */
+class KBuildServiceGroupFactory : public KServiceGroupFactory
+{
+public:
+    /**
+     * Create factory
+     */
+    KBuildServiceGroupFactory(KSycoca *db);
+
+    virtual ~KBuildServiceGroupFactory();
+
+    /**
+     * Create new entry.
+     */
+    KServiceGroup *createEntry(const QString &) const Q_DECL_OVERRIDE;
+
+    KServiceGroup *createEntry(int) const Q_DECL_OVERRIDE
+    {
+        assert(0);
+        return 0L;
+    }
+
+    /**
+     * Adds the entry @p newEntry to the menu @p menuName
+     */
+    void addNewEntryTo(const QString &menuName, const KService::Ptr &newEntry);
+
+    /**
+     * Adds the entry @p newEntry to the "parent group" @p parent, creating
+     * the group if necassery.
+     * A "parent group" is a group of services that all have the same
+     * "X-KDE-ParentApp".
+     */
+    void addNewChild(const QString &parent, const KSycocaEntry::Ptr &newEntry);
+
+    /**
+     * Add new menu @p menuName defined by @p file
+     * When @p entry is non-null it is re-used, otherwise a new group is created.
+     * A pointer to the group is returned.
+     */
+    KServiceGroup::Ptr addNew(const QString &menuName, const QString &file, KServiceGroup::Ptr entry, bool isDeleted);
+
+    /**
+     * Find a group ( by desktop path, e.g. "Applications/Editors")
+     */
+    KServiceGroup::Ptr findGroupByDesktopPath(const QString &_name, bool deep = true) Q_DECL_OVERRIDE;
+
+    /**
+     * Add a new menu entry
+     */
+    void addEntry(const KSycocaEntry::Ptr &newEntry) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out servicegroup  specific index files.
+     */
+    void save(QDataStream &str) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out header information
+     */
+    void saveHeader(QDataStream &str) Q_DECL_OVERRIDE;
+};
+
+#endif
diff --git a/src/sycoca/kbuildservicetypefactory.cpp b/src/sycoca/kbuildservicetypefactory.cpp
new file mode 100644
index 0000000..2610c8d
--- /dev/null
+++ b/src/sycoca/kbuildservicetypefactory.cpp
@@ -0,0 +1,143 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999 David Faure   <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "kbuildservicetypefactory_p.h"
+#include "ksycoca.h"
+#include "ksycocadict_p.h"
+#include "ksycocaresourcelist_p.h"
+
+#include <QDebug>
+#include <assert.h>
+#include <kdesktopfile.h>
+#include <kconfiggroup.h>
+#include <QtCore/QHash>
+#include <qstandardpaths.h>
+
+KBuildServiceTypeFactory::KBuildServiceTypeFactory(KSycoca *db)
+    : KServiceTypeFactory(db)
+{
+    m_resourceList = new KSycocaResourceList;
+    m_resourceList->add("servicetypes", "kservicetypes5", "*.desktop");
+}
+
+KBuildServiceTypeFactory::~KBuildServiceTypeFactory()
+{
+    delete m_resourceList;
+}
+
+KServiceType::Ptr KBuildServiceTypeFactory::findServiceTypeByName(const QString &_name)
+{
+    assert(sycoca()->isBuilding());
+    // We're building a database - the service type must be in memory
+    KSycocaEntry::Ptr servType = m_entryDict->value(_name);
+    return KServiceType::Ptr(static_cast<KServiceType*>(servType.data()));
+}
+
+KSycocaEntry *KBuildServiceTypeFactory::createEntry(const QString &file) const
+{
+    QString name = file;
+    int pos = name.lastIndexOf('/');
+    if (pos != -1) {
+        name = name.mid(pos + 1);
+    }
+
+    if (name.isEmpty()) {
+        return 0;
+    }
+
+    KDesktopFile desktopFile(QStandardPaths::GenericDataLocation, "kservicetypes5/" + file);
+    const KConfigGroup desktopGroup = desktopFile.desktopGroup();
+
+    if (desktopGroup.readEntry("Hidden", false) == true) {
+        return 0;
+    }
+
+    const QString type = desktopGroup.readEntry("Type");
+    if (type != QLatin1String("ServiceType")) {
+        qWarning() << "The service type config file " << desktopFile.fileName() << " has Type=" << type << " instead of Type=ServiceType";
+        return 0;
+    }
+
+    const QString serviceType = desktopGroup.readEntry("X-KDE-ServiceType");
+
+    if (serviceType.isEmpty()) {
+        qWarning() << "The service type config file " << desktopFile.fileName() << " does not contain a ServiceType=... entry";
+        return 0;
+    }
+
+    KServiceType *e = new KServiceType(&desktopFile);
+
+    if (e->isDeleted()) {
+        delete e;
+        return 0;
+    }
+
+    if (!(e->isValid())) {
+        qWarning() << "Invalid ServiceType : " << file;
+        delete e;
+        return 0;
+    }
+
+    return e;
+}
+
+void
+KBuildServiceTypeFactory::saveHeader(QDataStream &str)
+{
+    KSycocaFactory::saveHeader(str);
+    str << qint32(m_propertyTypeDict.count());
+    for (QMap<QString, int>::ConstIterator it = m_propertyTypeDict.constBegin(); it != m_propertyTypeDict.constEnd(); ++it) {
+        str << it.key() << qint32(it.value());
+    }
+}
+
+void
+KBuildServiceTypeFactory::save(QDataStream &str)
+{
+    KSycocaFactory::save(str);
+#if 0 // not needed since don't have any additional index anymore
+    int endOfFactoryData = str.device()->pos();
+
+    // Update header (pass #3)
+    saveHeader(str);
+
+    // Seek to end.
+    str.device()->seek(endOfFactoryData);
+#endif
+}
+
+void
+KBuildServiceTypeFactory::addEntry(const KSycocaEntry::Ptr &newEntry)
+{
+    KSycocaFactory::addEntry(newEntry);
+
+    KServiceType::Ptr serviceType(static_cast<KServiceType*>(newEntry.data()));
+
+    const QMap<QString, QVariant::Type> &pd = serviceType->propertyDefs();
+    QMap<QString, QVariant::Type>::ConstIterator pit = pd.begin();
+    for (; pit != pd.end(); ++pit) {
+        const QString property = pit.key();
+        QMap<QString, int>::iterator dictit = m_propertyTypeDict.find(property);
+        if (dictit == m_propertyTypeDict.end()) {
+            m_propertyTypeDict.insert(property, pit.value());
+        } else if (*dictit != static_cast<int>(pit.value())) {
+            qWarning() << "Property '" << property << "' is defined multiple times (" << serviceType->name() << ")";
+        }
+    }
+}
+
diff --git a/src/sycoca/kbuildservicetypefactory_p.h b/src/sycoca/kbuildservicetypefactory_p.h
new file mode 100644
index 0000000..347e753
--- /dev/null
+++ b/src/sycoca/kbuildservicetypefactory_p.h
@@ -0,0 +1,76 @@
+/* This file is part of the KDE project
+   Copyright (C) 1999 David Faure <faure@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KBUILD_SERVICE_TYPE_FACTORY_H
+#define KBUILD_SERVICE_TYPE_FACTORY_H
+
+#include <kservicetypefactory_p.h>
+#include <QtCore/QStringList>
+
+/**
+ * Service-type factory for building ksycoca
+ * @internal
+ */
+class KBuildServiceTypeFactory : public KServiceTypeFactory
+{
+public:
+    /**
+     * Create factory
+     */
+    KBuildServiceTypeFactory(KSycoca *db);
+
+    virtual ~KBuildServiceTypeFactory();
+
+    /**
+     * Find a service type in the database file
+     * @return a pointer to the servicetype in the memory dict (don't free!)
+     */
+    KServiceType::Ptr findServiceTypeByName(const QString &_name) Q_DECL_OVERRIDE;
+
+    /**
+     * Construct a KServiceType from a config file.
+     */
+    KSycocaEntry *createEntry(const QString &file) const Q_DECL_OVERRIDE;
+
+    KServiceType *createEntry(int) const Q_DECL_OVERRIDE
+    {
+        assert(0);
+        return 0L;
+    }
+
+    /**
+     * Add entry
+     */
+    void addEntry(const KSycocaEntry::Ptr &newEntry) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out service type specific index files.
+     */
+    void save(QDataStream &str) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out header information
+     *
+     * Don't forget to call the parent first when you override
+     * this function.
+     */
+    void saveHeader(QDataStream &str) Q_DECL_OVERRIDE;
+};
+
+#endif
diff --git a/src/sycoca/kbuildsycoca.cpp b/src/sycoca/kbuildsycoca.cpp
new file mode 100644
index 0000000..60a6066
--- /dev/null
+++ b/src/sycoca/kbuildsycoca.cpp
@@ -0,0 +1,645 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999 David Faure <faure@kde.org>
+ *  Copyright (C) 2002-2003 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "kbuildsycoca_p.h"
+#include "ksycoca_p.h"
+#include "ksycocaresourcelist_p.h"
+#include "vfolder_menu_p.h"
+
+#include <kservicegroup.h>
+#include <kservice.h>
+#include "kbuildservicetypefactory_p.h"
+#include "kbuildmimetypefactory_p.h"
+#include "kbuildservicefactory_p.h"
+#include "kbuildservicegroupfactory_p.h"
+#include "kctimefactory_p.h"
+#include <QtCore/QDataStream>
+#include <QtCore/QDir>
+#include <QtCore/QEventLoop>
+#include <QtCore/QFile>
+#include <QtCore/QLocale>
+#include <QtCore/QTimer>
+#include <QtCore/QDebug>
+#include <QDirIterator>
+#include <QDateTime>
+#include <qsavefile.h>
+
+#include <kmemfile_p.h>
+
+#include <qplatformdefs.h>
+#include <time.h>
+#include <memory> // auto_ptr
+#include <qstandardpaths.h>
+#include <QLockFile>
+
+static const char *s_cSycocaPath = 0;
+
+KBuildSycocaInterface::~KBuildSycocaInterface() {}
+
+KBuildSycoca::KBuildSycoca(bool globalDatabase)
+    : KSycoca(true),
+      m_allEntries(0),
+      m_serviceFactory(0),
+      m_buildServiceGroupFactory(0),
+      m_currentFactory(0),
+      m_ctimeFactory(0),
+      m_ctimeDict(0),
+      m_currentEntryDict(0),
+      m_serviceGroupEntryDict(0),
+      m_vfolder(0),
+      m_newTimestamp(0),
+      m_globalDatabase(globalDatabase),
+      m_menuTest(false),
+      m_changed(false)
+{
+}
+
+KBuildSycoca::~KBuildSycoca()
+{
+    // Delete the factories while we exist, so that the virtual isBuilding() still works
+    qDeleteAll(*factories());
+    factories()->clear();
+}
+
+KSycocaEntry::Ptr KBuildSycoca::createEntry(const QString &file, bool addToFactory)
+{
+    quint32 timeStamp = m_ctimeFactory->dict()->ctime(file, m_resource);
+    if (!timeStamp) {
+        timeStamp = calcResourceHash(m_resourceSubdir, file);
+    }
+    KSycocaEntry::Ptr entry;
+    if (m_allEntries) {
+        Q_ASSERT(m_ctimeDict);
+        quint32 oldTimestamp = m_ctimeDict->ctime(file, m_resource);
+        if (file.contains("fake")) {
+            qDebug() << "m_ctimeDict->ctime(" << file << ") = " << oldTimestamp << "compared with" << timeStamp;
+        }
+
+        if (timeStamp && (timeStamp == oldTimestamp)) {
+            // Re-use old entry
+            if (m_currentFactory == m_buildServiceGroupFactory) { // Strip .directory from service-group entries
+                entry = m_currentEntryDict->value(file.left(file.length() - 10));
+            } else {
+                entry = m_currentEntryDict->value(file);
+            }
+            // remove from m_ctimeDict; if m_ctimeDict is not empty
+            // after all files have been processed, it means
+            // some files were removed since last time
+            if (file.contains("fake")) {
+                qDebug() << "reusing (and removing) old entry for:" << file << "entry=" << entry;
+            }
+            m_ctimeDict->remove(file, m_resource);
+        } else if (oldTimestamp) {
+            m_changed = true;
+            m_ctimeDict->remove(file, m_resource);
+            qDebug() << "modified:" << file;
+        } else {
+            m_changed = true;
+            qDebug() << "new:" << file;
+        }
+    }
+    m_ctimeFactory->dict()->addCTime(file, m_resource, timeStamp);
+    if (!entry) {
+        // Create a new entry
+        entry = m_currentFactory->createEntry(file);
+    }
+    if (entry && entry->isValid()) {
+        if (addToFactory) {
+            m_currentFactory->addEntry(entry);
+        } else {
+            m_tempStorage.append(entry);
+        }
+        return entry;
+    }
+    return KSycocaEntry::Ptr();
+}
+
+KService::Ptr KBuildSycoca::createService(const QString &path)
+{
+    KSycocaEntry::Ptr entry = createEntry(path, false);
+    return KService::Ptr(static_cast<KService*>(entry.data()));
+}
+
+// returns false if the database is up to date, true if it needs to be saved
+bool KBuildSycoca::build()
+{
+    typedef QLinkedList<KBSEntryDict *> KBSEntryDictList;
+    KBSEntryDictList entryDictList;
+    KBSEntryDict *serviceEntryDict = 0;
+
+    // Convert for each factory the entryList to a Dict.
+    int i = 0;
+    // For each factory
+    for (KSycocaFactoryList::Iterator factory = factories()->begin();
+            factory != factories()->end();
+            ++factory) {
+        KBSEntryDict *entryDict = new KBSEntryDict;
+        if (m_allEntries) {
+            const KSycocaEntry::List list = (*m_allEntries)[i++];
+            Q_FOREACH (const KSycocaEntry::Ptr &entry, list) {
+                //if (entry->entryPath().contains("fake"))
+                //    qDebug() << "inserting into entryDict:" << entry->entryPath() << entry;
+                entryDict->insert(entry->entryPath(), entry);
+            }
+        }
+        if ((*factory) == m_serviceFactory) {
+            serviceEntryDict = entryDict;
+        } else if ((*factory) == m_buildServiceGroupFactory) {
+            m_serviceGroupEntryDict = entryDict;
+        }
+        entryDictList.append(entryDict);
+    }
+
+    QMap<QString, QByteArray> allResourcesSubDirs; // dirs, kstandarddirs-resource-name
+    // For each factory
+    for (KSycocaFactoryList::Iterator factory = factories()->begin();
+            factory != factories()->end();
+            ++factory) {
+        // For each resource the factory deals with
+        const KSycocaResourceList *list = (*factory)->resourceList();
+        if (!list) {
+            continue;
+        }
+        Q_FOREACH (const KSycocaResource &res, *list) {
+            // With this we would get dirs, but not a unique list of relative files (for global+local merging to work)
+            //const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, res.subdir, QStandardPaths::LocateDirectory);
+            //allResourcesSubDirs[res.resource] += dirs;
+            allResourcesSubDirs.insert(res.subdir, res.resource);
+        }
+    }
+
+    m_ctimeFactory = new KCTimeFactory(this); // This is a build factory too, don't delete!!
+    bool uptodate = true;
+    for (QMap<QString, QByteArray>::ConstIterator it1 = allResourcesSubDirs.constBegin();
+            it1 != allResourcesSubDirs.constEnd();
+            ++it1) {
+        m_changed = false;
+        m_resourceSubdir = it1.key();
+        m_resource = it1.value();
+
+        QStringList relFiles;
+        const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, m_resourceSubdir, QStandardPaths::LocateDirectory);
+        Q_FOREACH (const QString &dir, dirs) {
+            QDirIterator it(dir, QDirIterator::Subdirectories);
+            while (it.hasNext()) {
+                const QString filePath = it.next();
+                Q_ASSERT(filePath.startsWith(dir)); // due to the line below...
+                const QString relPath = filePath.mid(dir.length() + 1);
+                if (!relFiles.contains(relPath)) {
+                    relFiles.append(relPath);
+                }
+            }
+        }
+        // Now find all factories that use this resource....
+        // For each factory
+        KBSEntryDictList::const_iterator ed_it = entryDictList.begin();
+        const KBSEntryDictList::const_iterator ed_end = entryDictList.end();
+        KSycocaFactoryList::const_iterator it = factories()->constBegin();
+        const KSycocaFactoryList::const_iterator end = factories()->constEnd();
+        for (; it != end; ++it, ++ed_it) {
+            m_currentFactory = (*it);
+            // m_ctimeInfo gets created after the initial loop, so it has no entryDict.
+            m_currentEntryDict = ed_it == ed_end ? 0 : *ed_it;
+            // For each resource the factory deals with
+            const KSycocaResourceList *list = m_currentFactory->resourceList();
+            if (!list) {
+                continue;
+            }
+
+            for (KSycocaResourceList::ConstIterator it2 = list->constBegin();
+                    it2 != list->constEnd();
+                    ++it2) {
+                KSycocaResource res = (*it2);
+                if (res.resource != (*it1)) {
+                    continue;
+                }
+
+                // For each file in the resource
+                for (QStringList::ConstIterator it3 = relFiles.constBegin();
+                        it3 != relFiles.constEnd();
+                        ++it3) {
+                    // Check if file matches filter
+                    if ((*it3).endsWith(res.extension)) {
+                        QString entryPath = (*it3);
+                        createEntry(entryPath, true);
+                    }
+                }
+            }
+        }
+        if (m_changed || !m_allEntries) {
+            uptodate = false;
+            //qDebug() << "CHANGED:" << resource;
+            m_changedResources.append(m_resource);
+        }
+    }
+
+    bool result = !uptodate || (m_ctimeDict && !m_ctimeDict->isEmpty());
+    if (m_ctimeDict && !m_ctimeDict->isEmpty()) {
+        //qDebug() << "Still in time dict:";
+        //m_ctimeDict->dump();
+        // ## It seems entries filtered out by vfolder are still in there,
+        // so we end up always saving ksycoca, i.e. this method never returns false
+
+        // Get the list of resources from which some files were deleted
+        const QStringList resources = m_ctimeDict->remainingResourceList();
+        qDebug() << "Still in the time dict (i.e. deleted files)" << resources;
+        m_changedResources += resources;
+    }
+
+    if (result || m_menuTest) {
+        m_resource = "apps";
+        m_resourceSubdir = QStringLiteral("applications");
+        m_currentFactory = m_serviceFactory;
+        m_currentEntryDict = serviceEntryDict;
+        m_changed = false;
+
+        m_vfolder = new VFolderMenu(m_serviceFactory, this);
+        if (!m_trackId.isEmpty()) {
+            m_vfolder->setTrackId(m_trackId);
+        }
+
+        VFolderMenu::SubMenu *kdeMenu = m_vfolder->parseMenu(QStringLiteral("applications.menu"));
+
+        KServiceGroup::Ptr entry = m_buildServiceGroupFactory->addNew(QStringLiteral("/"), kdeMenu->directoryFile, KServiceGroup::Ptr(), false);
+        entry->setLayoutInfo(kdeMenu->layoutList);
+        createMenu(QString(), QString(), kdeMenu);
+
+        m_allResourceDirs = factoryResourceDirs();
+        m_allResourceDirs += m_vfolder->allDirectories();
+
+        if (m_changed || !m_allEntries) {
+            uptodate = false;
+            //qDebug() << "CHANGED:" << m_resource;
+            m_changedResources.append(m_resource);
+        }
+        if (m_menuTest) {
+            result = false;
+        }
+    }
+
+    qDeleteAll(entryDictList);
+    return result;
+}
+
+void KBuildSycoca::createMenu(const QString &caption_, const QString &name_, VFolderMenu::SubMenu *menu)
+{
+    QString caption = caption_;
+    QString name = name_;
+    foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus) {
+        QString subName = name + subMenu->name + '/';
+
+        QString directoryFile = subMenu->directoryFile;
+        if (directoryFile.isEmpty()) {
+            directoryFile = subName + QStringLiteral(".directory");
+        }
+        quint32 timeStamp = m_ctimeFactory->dict()->ctime(directoryFile, m_resource);
+        if (!timeStamp) {
+            timeStamp = calcResourceHash(m_resourceSubdir, directoryFile);
+        }
+
+        KServiceGroup::Ptr entry;
+        if (m_allEntries) {
+            const quint32 oldTimestamp = m_ctimeDict->ctime(directoryFile, m_resource);
+
+            if (timeStamp && (timeStamp == oldTimestamp)) {
+                KSycocaEntry::Ptr group = m_serviceGroupEntryDict->value(subName);
+                if (group) {
+                    entry = KServiceGroup::Ptr(static_cast<KServiceGroup*>(group.data()));
+                    if (entry->directoryEntryPath() != directoryFile) {
+                        entry = 0;    // Can't reuse this one!
+                    }
+                }
+            }
+        }
+        if (timeStamp) { // bug? (see calcResourceHash). There might not be a .directory file...
+            m_ctimeFactory->dict()->addCTime(directoryFile, m_resource, timeStamp);
+        }
+
+        entry = m_buildServiceGroupFactory->addNew(subName, subMenu->directoryFile, entry, subMenu->isDeleted);
+        entry->setLayoutInfo(subMenu->layoutList);
+        if (!(m_menuTest && entry->noDisplay())) {
+            createMenu(caption + entry->caption() + '/', subName, subMenu);
+        }
+    }
+    if (caption.isEmpty()) {
+        caption += '/';
+    }
+    if (name.isEmpty()) {
+        name += '/';
+    }
+    foreach (const KService::Ptr &p, menu->items) {
+        if (m_menuTest) {
+            if (!menu->isDeleted && !p->noDisplay())
+                printf("%s\t%s\t%s\n", qPrintable(caption), qPrintable(p->menuId()),
+                       qPrintable(QStandardPaths::locate(QStandardPaths::ApplicationsLocation, p->entryPath())));
+        } else {
+            m_buildServiceGroupFactory->addNewEntryTo(name, p);
+        }
+    }
+}
+
+bool KBuildSycoca::recreate(bool incremental)
+{
+    QFileInfo fi(KSycoca::absoluteFilePath(m_globalDatabase ? KSycoca::GlobalDatabase : KSycoca::LocalDatabase));
+    if (!QDir().mkpath(fi.absolutePath())) {
+        qWarning() << "Couldn't create" << fi.absolutePath();
+        return false;
+    }
+    QString path(fi.absoluteFilePath());
+
+    QLockFile lockFile(path + ".lock");
+    if (!lockFile.tryLock()) {
+        qDebug() <<  "Waiting for already running" << KBUILDSYCOCA_EXENAME << "to finish.";
+        if (!lockFile.lock()) {
+            return false;
+        }
+        if (!needsRebuild()) {
+            //qDebug() << "Up-to-date, skipping.";
+            return true;
+        }
+    }
+
+    QByteArray qSycocaPath = QFile::encodeName(path);
+    s_cSycocaPath = qSycocaPath.data();
+
+    m_allEntries = 0;
+    m_ctimeDict = 0;
+    if (incremental && checkGlobalHeader()) {
+        qDebug() << "Reusing existing ksycoca";
+        KSycoca *oldSycoca = KSycoca::self();
+        m_allEntries = new KSycocaEntryListList;
+        m_ctimeDict = new KCTimeDict;
+
+        // Must be in same order as in KBuildSycoca::recreate()!
+        m_allEntries->append(KServiceTypeFactory::self()->allEntries());
+        m_allEntries->append(KMimeTypeFactory::self()->allEntries());
+        m_allEntries->append(KServiceGroupFactory::self()->allEntries());
+        m_allEntries->append(KServiceFactory::self()->allEntries());
+
+        KCTimeFactory *ctimeInfo = new KCTimeFactory(oldSycoca);
+        *m_ctimeDict = ctimeInfo->loadDict();
+    }
+    s_cSycocaPath = 0;
+
+    QSaveFile database(path);
+    bool openedOK = database.open(QIODevice::WriteOnly);
+
+    if (!openedOK && database.error() == QFile::WriteError && QFile::exists(path)) {
+        QFile::remove(path);
+        openedOK = database.open(QIODevice::WriteOnly);
+    }
+    if (!openedOK) {
+        fprintf(stderr, KBUILDSYCOCA_EXENAME ": ERROR creating database '%s'! %s\n",
+                path.toLocal8Bit().data(), database.errorString().toLocal8Bit().data());
+        return false;
+    }
+
+    QDataStream *str = new QDataStream(&database);
+    str->setVersion(QDataStream::Qt_5_3);
+
+    m_newTimestamp = QDateTime::currentMSecsSinceEpoch();
+    qDebug().nospace() << "Recreating ksycoca file (" << path << ", version " << KSycoca::version() << ")";
+
+    // It is very important to build the servicetype one first
+    KBuildServiceTypeFactory *stf = new KBuildServiceTypeFactory(this);
+    KBuildMimeTypeFactory *mimeTypeFactory = new KBuildMimeTypeFactory(this);
+    m_buildServiceGroupFactory = new KBuildServiceGroupFactory(this);
+    m_serviceFactory = new KBuildServiceFactory(stf, mimeTypeFactory, m_buildServiceGroupFactory);
+
+    if (build()) { // Parse dirs
+        save(str); // Save database
+        if (str->status() != QDataStream::Ok) { // Probably unnecessary now in Qt5, since QSaveFile detects write errors
+            database.cancelWriting();    // Error
+        }
+        delete str;
+        str = 0;
+
+        //if we are currently via sudo, preserve the original owner
+        //as $HOME may also be that of another user rather than /root
+#ifdef Q_OS_UNIX
+        if (qEnvironmentVariableIsSet("SUDO_UID")) {
+            const int uid = QString(qgetenv("SUDO_UID")).toInt();
+            const int gid = QString(qgetenv("SUDO_GID")).toInt();
+            if (uid && gid) {
+                fchown(database.handle(), uid, gid);
+            }
+        }
+#endif
+
+        if (!database.commit()) {
+            fprintf(stderr, KBUILDSYCOCA_EXENAME ": ERROR writing database '%s'!\n", database.fileName().toLocal8Bit().data());
+            fprintf(stderr, KBUILDSYCOCA_EXENAME ": Disk full?\n");
+            return false;
+        }
+    } else {
+        delete str;
+        str = 0;
+        database.cancelWriting();
+        if (m_menuTest) {
+            return true;
+        }
+        qDebug() << "Database is up to date";
+    }
+
+    if (!m_globalDatabase) {
+        // update the timestamp file
+        QString stamppath = path + QStringLiteral("stamp");
+        QFile ksycocastamp(stamppath);
+        ksycocastamp.open(QIODevice::WriteOnly);
+        QDataStream str(&ksycocastamp);
+        str.setVersion(QDataStream::Qt_5_3);
+        str << m_newTimestamp;
+        str << existingResourceDirs();
+        if (m_vfolder) {
+            str << m_vfolder->allDirectories();    // Extra resource dirs
+        }
+    } else {
+        // These directories may have been created with 0700 permission
+        // better delete them if they are empty
+        QString appsDir = QStandardPaths::writableLocation(QStandardPaths::ApplicationsLocation);
+        QDir().remove(appsDir);
+        // was doing the same with servicetypes, but I don't think any of these gets created-by-mistake anymore.
+    }
+    if (d->m_sycocaStrategy == KSycocaPrivate::StrategyMemFile) {
+        KMemFile::fileContentsChanged(path);
+    }
+
+    delete m_ctimeDict;
+    delete m_allEntries;
+    delete m_vfolder;
+
+    return true;
+}
+
+void KBuildSycoca::save(QDataStream *str)
+{
+    // Write header (#pass 1)
+    str->device()->seek(0);
+
+    (*str) << qint32(KSycoca::version());
+    //KSycocaFactory * servicetypeFactory = 0;
+    //KBuildMimeTypeFactory * mimeTypeFactory = 0;
+    KBuildServiceFactory *serviceFactory = 0;
+    for (KSycocaFactoryList::Iterator factory = factories()->begin();
+            factory != factories()->end();
+            ++factory) {
+        qint32 aId;
+        qint32 aOffset;
+        aId = (*factory)->factoryId();
+        //if ( aId == KST_KServiceTypeFactory )
+        //   servicetypeFactory = *factory;
+        //else if ( aId == KST_KMimeTypeFactory )
+        //   mimeTypeFactory = static_cast<KBuildMimeTypeFactory *>( *factory );
+        if (aId == KST_KServiceFactory) {
+            serviceFactory = static_cast<KBuildServiceFactory *>(*factory);
+        }
+        aOffset = (*factory)->offset(); // not set yet, so always 0
+        (*str) << aId;
+        (*str) << aOffset;
+    }
+    (*str) << qint32(0); // No more factories.
+    // Write XDG_DATA_DIRS
+    (*str) << QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).join(QString(QLatin1Char(':')));
+    (*str) << m_newTimestamp;
+    (*str) << QLocale().bcp47Name();
+    // This makes it possible to trigger a ksycoca update for all users (KIOSK feature)
+    (*str) << calcResourceHash(QStringLiteral("kservices5"), QStringLiteral("update_ksycoca"));
+    (*str) << m_allResourceDirs;
+
+    // Calculate per-servicetype/mimetype data
+    if (serviceFactory) serviceFactory->postProcessServices();
+
+    // Here so that it's the last debug message
+    qDebug() << "Saving";
+
+    // Write factory data....
+    for (KSycocaFactoryList::Iterator factory = factories()->begin();
+            factory != factories()->end();
+            ++factory) {
+        (*factory)->save(*str);
+        if (str->status() != QDataStream::Ok) { // ######## TODO: does this detect write errors, e.g. disk full?
+            return;    // error
+        }
+    }
+
+    int endOfData = str->device()->pos();
+
+    // Write header (#pass 2)
+    str->device()->seek(0);
+
+    (*str) << qint32(KSycoca::version());
+    for (KSycocaFactoryList::Iterator factory = factories()->begin();
+            factory != factories()->end(); ++factory) {
+        qint32 aId;
+        qint32 aOffset;
+        aId = (*factory)->factoryId();
+        aOffset = (*factory)->offset();
+        (*str) << aId;
+        (*str) << aOffset;
+    }
+    (*str) << qint32(0); // No more factories.
+
+    // Jump to end of database
+    str->device()->seek(endOfData);
+}
+
+QStringList KBuildSycoca::factoryResourceDirs()
+{
+    static QStringList *dirs = NULL;
+    if (dirs != NULL) {
+        return *dirs;
+    }
+    dirs = new QStringList;
+    // these are all resource dirs cached by ksycoca
+    *dirs += KServiceTypeFactory::resourceDirs();
+    *dirs += KMimeTypeFactory::resourceDirs();
+    *dirs += KServiceFactory::resourceDirs();
+
+    return *dirs;
+}
+
+QStringList KBuildSycoca::existingResourceDirs()
+{
+    static QStringList *dirs = NULL;
+    if (dirs != NULL) {
+        return *dirs;
+    }
+    dirs = new QStringList(factoryResourceDirs());
+
+    for (QStringList::Iterator it = dirs->begin();
+            it != dirs->end();) {
+        QFileInfo inf(*it);
+        if (!inf.exists() || !inf.isReadable()) {
+            it = dirs->erase(it);
+        } else {
+            ++it;
+        }
+    }
+    return *dirs;
+}
+
+static quint32 updateHash(const QString &file, quint32 hash)
+{
+    QFileInfo fi(file);
+    if (fi.isReadable() && fi.isFile()) {
+        // This was using buff.st_ctime (in Waldo's initial commit to kstandarddirs.cpp in 2001), but that looks wrong?
+        // Surely we want to catch manual editing, while a chmod doesn't matter much?
+        hash += fi.lastModified().toTime_t();
+    }
+    return hash;
+}
+
+quint32 KBuildSycoca::calcResourceHash(const QString &resourceSubDir, const QString &filename)
+{
+    quint32 hash = 0;
+    if (!QDir::isRelativePath(filename)) {
+        return updateHash(filename, hash);
+    }
+    const QStringList files = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, resourceSubDir + QLatin1Char('/') + filename);
+    Q_FOREACH (const QString &file, files) {
+        hash = updateHash(file, hash);
+    }
+    if (hash == 0 && !filename.endsWith(QLatin1String("update_ksycoca"))
+            && !filename.endsWith(QLatin1String(".directory")) // bug? needs investigation from someone who understands the VFolder spec
+       ) {
+        qWarning() << "File not found or not readable:" << filename << "found:" << files;
+        Q_ASSERT(hash != 0);
+    }
+    return hash;
+}
+
+bool KBuildSycoca::checkGlobalHeader()
+{
+    const QString current_language = QLocale().bcp47Name();
+    const quint32 current_update_sig = KBuildSycoca::calcResourceHash(QStringLiteral("kservices5"), QStringLiteral("update_ksycoca"));
+    const QString current_prefixes = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).join(QString(QLatin1Char(':')));
+
+    const KSycocaHeader header = KSycoca::self()->readSycocaHeader();
+    Q_ASSERT(!header.prefixes.split(':').contains(QDir::homePath()));
+
+    return (current_update_sig == header.updateSignature) &&
+            (current_language == header.language) &&
+            (current_prefixes == header.prefixes) &&
+            (header.timeStamp != 0);
+}
+
+const char *KBuildSycoca::sycocaPath()
+{
+    return s_cSycocaPath;
+}
diff --git a/src/sycoca/kbuildsycoca_p.h b/src/sycoca/kbuildsycoca_p.h
new file mode 100644
index 0000000..da23a63
--- /dev/null
+++ b/src/sycoca/kbuildsycoca_p.h
@@ -0,0 +1,155 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999 David Faure <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+#ifndef KBUILDSYCOCA_H
+#define KBUILDSYCOCA_H
+
+#include "kbuildsycocainterface_p.h"
+
+#include <kservice.h>
+#include <ksycoca.h>
+
+#include "vfolder_menu_p.h"
+
+class KBuildServiceGroupFactory;
+class QDataStream;
+class KCTimeFactory;
+class KCTimeDict;
+
+/**
+ * @internal
+ * Exported for kbuildsycoca, but not installed.
+ */
+class KSERVICE_EXPORT KBuildSycoca : public KSycoca, public KBuildSycocaInterface
+{
+    Q_OBJECT
+public:
+    KBuildSycoca(bool globalDatabase = false);
+    virtual ~KBuildSycoca();
+
+    /**
+     * Recreate the database file.
+     * @return true if it was indeed recreated (by us or possibly by someone else), false on error
+     */
+    bool recreate(bool incremental = true);
+
+    void setTrackId(const QString &id)
+    {
+        m_trackId = id;
+    }
+
+    void setMenuTest(bool b)
+    {
+        m_menuTest = b;
+    }
+
+    QStringList changedResources() const
+    {
+        return m_changedResources;
+    }
+
+    static QStringList factoryResourceDirs();
+    static QStringList existingResourceDirs();
+
+    /**
+     * Returns a number that identifies the current version of the file @p filename,
+     * which is located under GenericDataLocation (including local overrides).
+     *
+     * When a change is made to the file this number will change.
+     */
+    static quint32 calcResourceHash(const QString &subdir, const QString &filename);
+
+    /**
+     * Compare our current settings (language, prefixes...) with the ones from the existing ksycoca global header.
+     * @return true if they match (= we can reuse this ksycoca), false otherwise (full build)
+     */
+    bool checkGlobalHeader();
+
+    /**
+     * @brief path to the sycoca file, for the crash handler in kbuildsycoca
+     */
+    static const char *sycocaPath();
+
+private:
+    /**
+     * Add single entry to the sycoca database.
+     * Either from a previous database or regenerated from file.
+     */
+    KSycocaEntry::Ptr createEntry(const QString &file, bool addToFactory);
+
+    /**
+     * Implementation of KBuildSycocaInterface
+     * Create service and return it. The caller must add it to the servicefactory.
+     */
+    KService::Ptr createService(const QString &path) Q_DECL_OVERRIDE;
+
+    /**
+     * Convert a VFolderMenu::SubMenu to KServiceGroups.
+     */
+    void createMenu(const QString &caption, const QString &name, VFolderMenu::SubMenu *menu);
+
+    /**
+     * Build the whole system cache, from .desktop files
+     */
+    bool build();
+
+    /**
+     * Save the ksycoca file
+     */
+    void save(QDataStream *str);
+
+    /**
+     * Clear the factories
+     */
+    void clear();
+
+    /**
+     * @internal
+     * @return true if building (i.e. if a KBuildSycoca);
+     */
+    bool isBuilding() Q_DECL_OVERRIDE
+    {
+        return true;
+    }
+
+    QStringList m_changedResources;
+    QStringList m_allResourceDirs;
+    QString m_trackId;
+
+    QByteArray m_resource; // e.g. "services" (old resource name, now only used for the signal, see kctimefactory.cpp)
+    QString m_resourceSubdir; // e.g. "kservices5" (xdgdata subdir)
+
+    KSycocaEntry::List m_tempStorage;
+    typedef QList<KSycocaEntry::List> KSycocaEntryListList;
+    KSycocaEntryListList *m_allEntries; // entries from existing ksycoca
+    KBuildServiceFactory *m_serviceFactory;
+    KBuildServiceGroupFactory *m_buildServiceGroupFactory;
+    KSycocaFactory *m_currentFactory;
+    KCTimeFactory *m_ctimeFactory;
+    KCTimeDict *m_ctimeDict; // old timestamps
+    typedef QHash<QString, KSycocaEntry::Ptr> KBSEntryDict;
+    KBSEntryDict *m_currentEntryDict;
+    KBSEntryDict *m_serviceGroupEntryDict;
+    VFolderMenu *m_vfolder;
+    qint64 m_newTimestamp;
+
+    bool m_globalDatabase;
+    bool m_menuTest;
+    bool m_changed;
+};
+
+#endif
diff --git a/src/sycoca/kbuildsycocainterface_p.h b/src/sycoca/kbuildsycocainterface_p.h
new file mode 100644
index 0000000..337f8d0
--- /dev/null
+++ b/src/sycoca/kbuildsycocainterface_p.h
@@ -0,0 +1,32 @@
+/* This file is part of the KDE libraries
+    Copyright (c) 2009 David Faure <faure@kde.org>
+
+    This library is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License or ( at
+    your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+    act as a proxy as in section 14 of the GPLv3 ), any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+#ifndef KBUILDSYCOCAINTERFACE_H
+#define KBUILDSYCOCAINTERFACE_H
+
+#include <kservice.h>
+
+class KBuildSycocaInterface
+{
+public:
+    virtual ~KBuildSycocaInterface();
+    virtual KService::Ptr createService(const QString &path) = 0;
+};
+
+#endif /* KBUILDSYCOCAINTERFACE_H */
diff --git a/src/sycoca/kctimefactory.cpp b/src/sycoca/kctimefactory.cpp
new file mode 100644
index 0000000..a8c7846
--- /dev/null
+++ b/src/sycoca/kctimefactory.cpp
@@ -0,0 +1,140 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "kctimefactory_p.h"
+#include <ksycoca.h>
+#include <ksycocautils_p.h>
+#include <ksycocatype.h>
+#include <QDebug>
+
+#include <assert.h>
+
+// NOTE: the storing of "resource" here is now completely useless (since everything is under GenericDataLocation),
+// except for remainingResourceList() which is used for the compat signal databaseChanged(...)
+// We could possibly replace this with a subdir->old_resource mapping (applications -> apps, kservices5 -> services, etc.)
+// Alternatively, we could use an enum in the signal...
+
+static inline QString key(const QString &path, const QByteArray &resource)
+{
+    return QString::fromLatin1(resource) + QLatin1Char('|') + path;
+}
+
+void KCTimeDict::addCTime(const QString &path, const QByteArray &resource, quint32 ctime)
+{
+    Q_ASSERT(ctime != 0);
+    assert(!path.isEmpty());
+    m_hash.insert(key(path, resource), ctime);
+}
+
+quint32 KCTimeDict::ctime(const QString &path, const QByteArray &resource) const
+{
+    return m_hash.value(key(path, resource), 0);
+}
+
+void KCTimeDict::remove(const QString &path, const QByteArray &resource)
+{
+    m_hash.remove(key(path, resource));
+}
+
+void KCTimeDict::dump() const
+{
+    qDebug() << m_hash.keys();
+}
+
+QStringList KCTimeDict::remainingResourceList() const
+{
+    QSet<QString> resources;
+    Hash::const_iterator it = m_hash.constBegin();
+    const Hash::const_iterator end = m_hash.constEnd();
+    for (; it != end; ++it) {
+        const QString key = it.key();
+        const QString res = key.left(key.indexOf('|'));
+        resources.insert(res);
+    }
+    return resources.toList();
+}
+
+void KCTimeDict::load(QDataStream &str)
+{
+    QString key;
+    quint32 ctime;
+    while (true) {
+        KSycocaUtilsPrivate::read(str, key);
+        str >> ctime;
+        if (key.isEmpty()) {
+            break;
+        }
+        m_hash.insert(key, ctime);
+    }
+}
+
+void KCTimeDict::save(QDataStream &str) const
+{
+    Hash::const_iterator it = m_hash.constBegin();
+    const Hash::const_iterator end = m_hash.constEnd();
+    for (; it != end; ++it) {
+        str << it.key() << it.value();
+    }
+    str << QString() << quint32(0);
+}
+
+///////////
+
+KCTimeFactory::KCTimeFactory(KSycoca *db)
+    : KSycocaFactory(KST_CTimeInfo, db), m_ctimeDict()
+{
+    if (!sycoca()->isBuilding()) {
+        QDataStream *str = stream();
+        (*str) >> m_dictOffset;
+    } else {
+        m_dictOffset = 0;
+    }
+}
+
+KCTimeFactory::~KCTimeFactory()
+{
+}
+
+void
+KCTimeFactory::saveHeader(QDataStream &str)
+{
+    KSycocaFactory::saveHeader(str);
+
+    str << m_dictOffset;
+}
+
+void KCTimeFactory::save(QDataStream &str)
+{
+    KSycocaFactory::save(str);
+
+    m_dictOffset = str.device()->pos();
+    m_ctimeDict.save(str);
+    const int endOfFactoryData = str.device()->pos();
+    saveHeader(str);
+    str.device()->seek(endOfFactoryData);
+}
+
+KCTimeDict KCTimeFactory::loadDict() const
+{
+    KCTimeDict dict;
+    QDataStream *str = stream();
+    assert(str);
+    str->device()->seek(m_dictOffset);
+    dict.load(*str);
+    return dict;
+}
diff --git a/src/sycoca/kctimefactory_p.h b/src/sycoca/kctimefactory_p.h
new file mode 100644
index 0000000..24ae8e5
--- /dev/null
+++ b/src/sycoca/kctimefactory_p.h
@@ -0,0 +1,97 @@
+/* This file is part of the KDE project
+   Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KCTIME_FACTORY_H
+#define KCTIME_FACTORY_H
+
+#include <ksycocafactory_p.h>
+#include <QtCore/QHash>
+
+/**
+ * Simple dict for assocating a timestamp with each file in ksycoca
+ */
+class KCTimeDict
+{
+public:
+    void addCTime(const QString &path, const QByteArray &resource, quint32 ctime);
+    quint32 ctime(const QString &path, const QByteArray &resource) const;
+    void remove(const QString &path, const QByteArray &resource);
+    void dump() const;
+    bool isEmpty() const
+    {
+        return m_hash.isEmpty();
+    }
+    QStringList remainingResourceList() const;
+
+    void load(QDataStream &str);
+    void save(QDataStream &str) const;
+private:
+    typedef QHash<QString, quint32> Hash;
+    Hash m_hash;
+};
+
+/**
+ * Internal factory for storing the timestamp of each file in ksycoca
+ * @internal
+ */
+class KCTimeFactory : public KSycocaFactory
+{
+    K_SYCOCAFACTORY(KST_CTimeInfo)
+public:
+    /**
+     * Create factory
+     */
+    KCTimeFactory(KSycoca *db);
+
+    virtual ~KCTimeFactory();
+
+    /**
+     * Write out header information
+     */
+    void saveHeader(QDataStream &str) Q_DECL_OVERRIDE;
+
+    /**
+     * Write out data
+     */
+    void save(QDataStream &str) Q_DECL_OVERRIDE;
+
+    KSycocaEntry *createEntry(const QString &) const Q_DECL_OVERRIDE
+    {
+        return 0;
+    }
+    KSycocaEntry *createEntry(int) const Q_DECL_OVERRIDE
+    {
+        return 0;
+    }
+
+    // Loads the dict and returns it; does not set m_ctimeDict;
+    // this is only used in incremental mode for loading the old timestamps.
+    KCTimeDict loadDict() const;
+
+    // The API for inserting/looking up entries is in KCTimeDict.
+    KCTimeDict *dict()
+    {
+        return &m_ctimeDict;
+    }
+
+private:
+    KCTimeDict m_ctimeDict;
+    int m_dictOffset;
+};
+
+#endif
diff --git a/src/sycoca/kmemfile_p.h b/src/sycoca/kmemfile_p.h
index 2aa9cb1..f9a9d17 100644
--- a/src/sycoca/kmemfile_p.h
+++ b/src/sycoca/kmemfile_p.h
@@ -36,7 +36,7 @@
  * is automatically destroyed when the last process closed KMemFile.
  */
 
-class KSERVICE_EXPORT KMemFile : public QIODevice
+class KMemFile : public QIODevice
 {
 public:
     /**
diff --git a/src/sycoca/kmimeassociations.cpp b/src/sycoca/kmimeassociations.cpp
new file mode 100644
index 0000000..c4aad1f
--- /dev/null
+++ b/src/sycoca/kmimeassociations.cpp
@@ -0,0 +1,168 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2008  David Faure  <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kmimeassociations_p.h"
+#include <kservice.h>
+#include <kservicefactory_p.h>
+#include <kconfiggroup.h>
+#include <kconfig.h>
+#include <QDebug>
+#include <qstandardpaths.h>
+#include <qmimedatabase.h>
+
+KMimeAssociations::KMimeAssociations(KOfferHash &offerHash, KServiceFactory *serviceFactory)
+    : m_offerHash(offerHash), m_serviceFactory(serviceFactory)
+{
+}
+
+/*
+
+The goal of this class is to parse mimeapps.list files, which are used to
+let users configure the application-mimetype associations.
+
+Example file:
+
+[Added Associations]
+text/plain=kate.desktop;
+
+[Removed Associations]
+text/plain=gnome-gedit.desktop;gnu-emacs.desktop;
+
+*/
+
+bool KMimeAssociations::parseAllMimeAppsList()
+{
+    const QString MIMEAPPS_LIST=QStringLiteral("mimeapps.list");
+    // Using the "merged view" from KConfig is not enough since we -add- at every level, we don't replace.
+    const QStringList mimeappsFiles = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, MIMEAPPS_LIST)
+                                    + QStandardPaths::locateAll(QStandardPaths::ApplicationsLocation, MIMEAPPS_LIST);
+    if (mimeappsFiles.isEmpty()) {
+        return false;
+    }
+
+    int basePreference = 1000; // start high :)
+    QListIterator<QString> mimeappsIter(mimeappsFiles);
+    mimeappsIter.toBack();
+    while (mimeappsIter.hasPrevious()) { // global first, then local.
+        const QString mimeappsFile = mimeappsIter.previous();
+        //qDebug() << "Parsing" << mimeappsFile;
+        parseMimeAppsList(mimeappsFile, basePreference);
+        basePreference += 50;
+    }
+    return true;
+}
+
+void KMimeAssociations::parseMimeAppsList(const QString &file, int basePreference)
+{
+    KConfig profile(file, KConfig::SimpleConfig);
+    parseAddedAssociations(KConfigGroup(&profile, "Added Associations"), file, basePreference);
+    parseRemovedAssociations(KConfigGroup(&profile, "Removed Associations"), file);
+
+    // KDE extension for parts and plugins, see settings/filetypes/mimetypedata.cpp
+    parseAddedAssociations(KConfigGroup(&profile, "Added KDE Service Associations"), file, basePreference);
+    parseRemovedAssociations(KConfigGroup(&profile, "Removed KDE Service Associations"), file);
+}
+
+void KMimeAssociations::parseAddedAssociations(const KConfigGroup &group, const QString &file, int basePreference)
+{
+    Q_UNUSED(file) // except in debug statements
+    QMimeDatabase db;
+    Q_FOREACH (const QString &mimeName, group.keyList()) {
+        const QStringList services = group.readXdgListEntry(mimeName);
+        const QString resolvedMimeName = db.mimeTypeForName(mimeName).name();
+        if (resolvedMimeName.isEmpty()) {
+            //qDebug() << file << "specifies unknown mimeType" << mimeName << "in" << group.name();
+        } else {
+            int pref = basePreference;
+            Q_FOREACH (const QString &service, services) {
+                KService::Ptr pService = m_serviceFactory->findServiceByStorageId(service);
+                if (!pService) {
+                    //qDebug() << file << "specifies unknown service" << service << "in" << group.name();
+                } else {
+                    //qDebug() << "adding mime" << resolvedMimeName << "to service" << pService->entryPath() << "pref=" << pref;
+                    m_offerHash.addServiceOffer(resolvedMimeName, KServiceOffer(pService, pref, 0, pService->allowAsDefault()));
+                    --pref;
+                }
+            }
+        }
+    }
+}
+
+void KMimeAssociations::parseRemovedAssociations(const KConfigGroup &group, const QString &file)
+{
+    Q_UNUSED(file) // except in debug statements
+    Q_FOREACH (const QString &mime, group.keyList()) {
+        const QStringList services = group.readXdgListEntry(mime);
+        Q_FOREACH (const QString &service, services) {
+            KService::Ptr pService =  m_serviceFactory->findServiceByStorageId(service);
+            if (!pService) {
+                //qDebug() << file << "specifies unknown service" << service << "in" << group.name();
+            } else {
+                //qDebug() << "removing mime" << mime << "from service" << pService.data() << pService->entryPath();
+                m_offerHash.removeServiceOffer(mime, pService);
+            }
+        }
+    }
+}
+
+void KOfferHash::addServiceOffer(const QString &serviceType, const KServiceOffer &offer)
+{
+    KService::Ptr service = offer.service();
+    //qDebug() << "Adding" << service->entryPath() << "to" << serviceType << offer.preference();
+    ServiceTypeOffersData &data = m_serviceTypeData[serviceType]; // find or create
+    QList<KServiceOffer> &offers = data.offers;
+    QSet<KService::Ptr> &offerSet = data.offerSet;
+    if (!offerSet.contains(service)) {
+        offers.append(offer);
+        offerSet.insert(service);
+    } else {
+        //qDebug() << service->entryPath() << "already in" << serviceType;
+        // This happens when mimeapps.list mentions a service (to make it preferred)
+        // Update initialPreference to qMax(existing offer, new offer)
+        QMutableListIterator<KServiceOffer> sfit(data.offers);
+        while (sfit.hasNext()) {
+            if (sfit.next().service() == service) { // we can compare KService::Ptrs because they are from the memory hash
+                sfit.value().setPreference(qMax(sfit.value().preference(), offer.preference()));
+            }
+        }
+    }
+}
+
+void KOfferHash::removeServiceOffer(const QString &serviceType, KService::Ptr service)
+{
+    ServiceTypeOffersData &data = m_serviceTypeData[serviceType]; // find or create
+    data.removedOffers.insert(service);
+    data.offerSet.remove(service);
+    QMutableListIterator<KServiceOffer> sfit(data.offers);
+    while (sfit.hasNext()) {
+        if (sfit.next().service()->storageId() == service->storageId()) {
+            sfit.remove();
+        }
+    }
+}
+
+bool KOfferHash::hasRemovedOffer(const QString &serviceType, KService::Ptr service) const
+{
+    QHash<QString, ServiceTypeOffersData>::const_iterator it = m_serviceTypeData.find(serviceType);
+    if (it != m_serviceTypeData.end()) {
+        return (*it).removedOffers.contains(service);
+    }
+    return false;
+}
diff --git a/src/sycoca/kmimeassociations_p.h b/src/sycoca/kmimeassociations_p.h
new file mode 100644
index 0000000..f902d83
--- /dev/null
+++ b/src/sycoca/kmimeassociations_p.h
@@ -0,0 +1,81 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2008  David Faure  <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KMIMEASSOCIATIONS_H
+#define KMIMEASSOCIATIONS_H
+
+#include <QSet>
+#include <QStringList>
+#include <QHash>
+#include <kserviceoffer.h>
+class KConfigGroup;
+class KServiceFactory;
+
+struct ServiceTypeOffersData {
+    QList<KServiceOffer> offers; // service + initial preference + allow as default
+    QSet<KService::Ptr> offerSet; // for quick contains() check
+    QSet<KService::Ptr> removedOffers; // remember removed offers explicitly
+};
+
+class KOfferHash
+{
+public:
+    KOfferHash() {}
+    QList<KServiceOffer> offersFor(const QString &serviceType) const
+    {
+        QHash<QString, ServiceTypeOffersData>::const_iterator it = m_serviceTypeData.find(serviceType);
+        if (it != m_serviceTypeData.end()) {
+            return (*it).offers;
+        }
+        return QList<KServiceOffer>();
+    }
+    void addServiceOffer(const QString &serviceType, const KServiceOffer &offer);
+    void removeServiceOffer(const QString &serviceType, KService::Ptr service);
+    bool hasRemovedOffer(const QString &serviceType, KService::Ptr service) const;
+
+private:
+    KOfferHash(const KOfferHash &); // forbidden
+    QHash<QString, ServiceTypeOffersData> m_serviceTypeData;
+};
+
+/**
+ * Parse mimeapps.list files and:
+ * - modify mimetype associations in the relevant services (using KServiceFactory)
+ * - remember preferrence order specified by user
+ */
+class KMimeAssociations
+{
+public:
+    explicit KMimeAssociations(KOfferHash &offerHash, KServiceFactory *serviceFactory);
+
+    // Read mimeapps.list files
+    bool parseAllMimeAppsList();
+
+    void parseMimeAppsList(const QString &file, int basePreference);
+
+private:
+    void parseAddedAssociations(const KConfigGroup &group, const QString &file, int basePreference);
+    void parseRemovedAssociations(const KConfigGroup &group, const QString &file);
+
+    KOfferHash &m_offerHash;
+    KServiceFactory *m_serviceFactory;
+};
+
+#endif /* KMIMEASSOCIATIONS_H */
diff --git a/src/sycoca/ksycoca.cpp b/src/sycoca/ksycoca.cpp
index 2048c84..8c00484 100644
--- a/src/sycoca/ksycoca.cpp
+++ b/src/sycoca/ksycoca.cpp
@@ -32,16 +32,14 @@
 #include <QtCore/QCoreApplication>
 #include <QtCore/QFile>
 #include <QtCore/QFileInfo>
-#include <QProcess>
-#include <QDBusConnection>
-#include <QDBusConnectionInterface>
-#include <QDBusInterface>
-#include <QDBusReply>
+#include <QThread>
+#include <QMetaMethod>
 
 #include <stdlib.h>
 #include <fcntl.h>
 #include <QDir>
 
+#include "kbuildsycoca_p.h"
 #include "ksycocadevices_p.h"
 
 /**
@@ -64,8 +62,6 @@
 #define MAP_FAILED ((void *) -1)
 #endif
 
-static bool s_autoRebuild = true;
-
 // The following limitations are in place:
 // Maximum length of a single string: 8192 bytes
 // Maximum length of a string list: 1024 strings
@@ -82,6 +78,7 @@ KSycocaPrivate::KSycocaPrivate()
       timeStamp(0),
       m_databasePath(),
       updateSig(0),
+      m_haveListeners(false),
       sycoca_size(0),
       sycoca_mmap(0),
       m_mmapFile(0),
@@ -179,39 +176,51 @@ private:
 
 Q_GLOBAL_STATIC(KSycocaSingleton, ksycocaInstance)
 
-// Read-only constructor
-KSycoca::KSycoca()
-    : d(new KSycocaPrivate)
-{
-    QDBusConnection::sessionBus().connect(QString(), QString(),
-                                          QString::fromLatin1("org.kde.KSycoca"),
-                                          QString::fromLatin1("notifyDatabaseChanged"),
-                                          this, SLOT(notifyDatabaseChanged(QStringList)));
-}
-
-bool KSycocaPrivate::openDatabase(bool openDummyIfNotFound)
+QString KSycocaPrivate::findDatabase()
 {
     Q_ASSERT(databaseStatus == DatabaseNotOpen);
 
-    delete m_device; m_device = 0;
     QString path = KSycoca::absoluteFilePath();
-
     QFileInfo info(path);
     bool canRead = info.isReadable();
-    qCDebug(SYCOCA) << "Trying to open ksycoca from" << path;
     if (!canRead) {
         path = KSycoca::absoluteFilePath(KSycoca::GlobalDatabase);
         if (!path.isEmpty()) {
-            qCDebug(SYCOCA) << "Trying to open global ksycoca from " << path;
             info.setFile(path);
             canRead = info.isReadable();
         }
     }
+    if (canRead) {
+        if (m_haveListeners) {
+            m_fileWatcher.addFile(path);
+        }
+        return path;
+    }
+    return QString();
+}
+
+// Read-only constructor
+// One instance per thread
+KSycoca::KSycoca()
+    : d(new KSycocaPrivate)
+{
+    connect(&d->m_fileWatcher, &KDirWatch::created, this, [this](){ d->slotDatabaseChanged(); });
+}
+
+bool KSycocaPrivate::openDatabase(bool openDummyIfNotFound)
+{
+    Q_ASSERT(databaseStatus == DatabaseNotOpen);
+
+    delete m_device; m_device = 0;
+
+    if (m_databasePath.isEmpty()) {
+        m_databasePath = findDatabase();
+    }
 
     bool result = true;
-    if (canRead) {
-        m_databasePath = path;
-        m_dbLastModified = info.lastModified();
+    if (!m_databasePath.isEmpty()) {
+        qCDebug(SYCOCA) << "Opening ksycoca from" << m_databasePath;
+        m_dbLastModified = QFileInfo(m_databasePath).lastModified();
         checkVersion();
     } else { // No database file
         //qCDebug(SYCOCA) << "Could not open ksycoca";
@@ -289,6 +298,26 @@ QDataStream *&KSycocaPrivate::stream()
     return m_device->stream();
 }
 
+void KSycocaPrivate::slotDatabaseChanged()
+{
+    // We don't have information anymore on what resources changed, so emit them all
+    changeList = QStringList() << "services" << "servicetypes" << "xdgdata-mime" << "apps";
+
+    qCDebug(SYCOCA) << QThread::currentThread() << "got a notifyDatabaseChanged signal";
+    // kbuildsycoca tells us the database file changed
+    // We would have found out in the next call to ensureCacheValid(), but for
+    // now keep the call to closeDatabase, to help refcounting to 0 the old mmaped file earlier.
+    closeDatabase();
+    // Start monitoring the new file right away
+    m_databasePath = findDatabase();
+
+    // Now notify applications
+    KSycoca *q = KSycoca::self();
+    Q_ASSERT(q->d == this); // only the readonly ctor connects to this slot
+    emit q->databaseChanged();
+    emit q->databaseChanged(changeList);
+}
+
 // Read-write constructor - only for KBuildSycoca
 KSycoca::KSycoca(bool /* dummy */)
     : d(new KSycocaPrivate)
@@ -353,22 +382,6 @@ bool KSycoca::isChanged(const char *type)
 }
 #endif
 
-void KSycoca::notifyDatabaseChanged(const QStringList &changeList)
-{
-    d->changeList = changeList;
-    //qCDebug(SYCOCA) << QThread::currentThread() << "got a notifyDatabaseChanged signal" << changeList;
-    // kbuildsycoca tells us the database file changed
-    // We would have found out in the next call to ensureCacheValid(), but for
-    // now keep the call to closeDatabase, to help refcounting to 0 the old mmaped file earlier.
-    d->closeDatabase();
-
-    // Now notify applications
-#ifndef KSERVICE_NO_DEPRECATED
-    emit databaseChanged();
-#endif
-    emit databaseChanged(changeList);
-}
-
 QDataStream *KSycoca::findEntry(int offset, KSycocaType &type)
 {
     QDataStream *str = stream();
@@ -479,6 +492,11 @@ KSycoca::KSycocaHeader KSycoca::readSycocaHeader()
     return d->readSycocaHeader();
 }
 
+bool KSycoca::needsRebuild()
+{
+    return d->needsRebuild();
+}
+
 KSycoca::KSycocaHeader KSycocaPrivate::readSycocaHeader()
 {
     KSycoca::KSycocaHeader header;
@@ -568,26 +586,24 @@ static bool checkTimestamps(qint64 timestamp, const QStringList &dirs)
 
 void KSycocaPrivate::checkDirectories(BehaviorsIfNotFound ifNotFound)
 {
+    if (needsRebuild()) {
+        buildSycoca(ifNotFound);
+    }
+}
+
+bool KSycocaPrivate::needsRebuild()
+{
     if (!timeStamp && databaseStatus == DatabaseOK) {
         (void) readSycocaHeader();
     }
-    if (timeStamp == 0 || !checkTimestamps(timeStamp, allResourceDirs)) {
-        buildSycoca(ifNotFound);
-    }
+    return timeStamp != 0 && !checkTimestamps(timeStamp, allResourceDirs);
 }
 
 bool KSycocaPrivate::buildSycoca(BehaviorsIfNotFound ifNotFound)
 {
-    QProcess proc;
-    const QString kbuildsycoca = QStandardPaths::findExecutable(KBUILDSYCOCA_EXENAME);
-    if (!kbuildsycoca.isEmpty()) {
-        QStringList args;
-        if (QStandardPaths::isTestModeEnabled()) {
-            args << QLatin1String("--testmode");
-        }
-        proc.setProcessChannelMode(QProcess::MergedChannels); // silence kbuildsycoca output
-        proc.start(kbuildsycoca, args);
-        proc.waitForFinished();
+    KBuildSycoca builder;
+    if (!builder.recreate()) {
+        return false; // error
     }
 
     closeDatabase(); // close the dummy one
@@ -657,19 +673,15 @@ QStringList KSycoca::allResourceDirs()
 void KSycoca::flagError()
 {
     qWarning() << "ERROR: KSycoca database corruption!";
-    KSycocaPrivate *d = ksycocaInstance()->sycoca()->d;
-    if (d->readError) {
+    KSycoca *sycoca = self();
+    if (sycoca->d->readError) {
         return;
     }
-    d->readError = true;
-    if (s_autoRebuild) {
+    sycoca->d->readError = true;
+    if (qAppName() != KBUILDSYCOCA_EXENAME && !sycoca->isBuilding()) {
         // Rebuild the damned thing.
-        if (QProcess::execute(QStandardPaths::findExecutable(QString::fromLatin1(KBUILDSYCOCA_EXENAME))) != 0) {
-            qWarning("ERROR: Running %s failed", KBUILDSYCOCA_EXENAME);
-        }
-        // Old comment, maybe not true anymore:
-        // Do not wait until the DBUS signal from kbuildsycoca here.
-        // It deletes m_str which is a problem when flagError is called during the KSycocaFactory ctor...
+        KBuildSycoca builder;
+        (void)builder.recreate();
     }
 }
 
@@ -680,7 +692,7 @@ bool KSycoca::isBuilding()
 
 void KSycoca::disableAutoRebuild()
 {
-    s_autoRebuild = false;
+    qWarning("KSycoca::disableAutoRebuild() is internal, do not call it.");
 }
 
 QDataStream *&KSycoca::stream()
@@ -688,6 +700,18 @@ QDataStream *&KSycoca::stream()
     return d->stream();
 }
 
+void KSycoca::connectNotify(const QMetaMethod &signal)
+{
+    if (signal.name() == "databaseChanged" && !d->m_haveListeners) {
+        d->m_haveListeners = true;
+        if (d->m_databasePath.isEmpty()) {
+            d->m_databasePath = d->findDatabase();
+        } else {
+            d->m_fileWatcher.addFile(d->m_databasePath);
+        }
+    }
+}
+
 void KSycoca::clearCaches()
 {
     if (ksycocaInstance.exists() && ksycocaInstance()->hasSycoca())
@@ -700,10 +724,6 @@ void KSycoca::ensureCacheValid()
         return;
     }
 
-    if (d->m_databasePath.isEmpty()) {
-        return;
-    }
-
     if (d->databaseStatus == KSycocaPrivate::DatabaseNotOpen) {
         return;
     }
diff --git a/src/sycoca/ksycoca.h b/src/sycoca/ksycoca.h
index 5e762fd..c561dfd 100644
--- a/src/sycoca/ksycoca.h
+++ b/src/sycoca/ksycoca.h
@@ -106,7 +106,7 @@ public:
     /**
      * @internal - returns language stored inside database
      */
-    QString language(); // KF6: remove
+    KSERVICE_DEPRECATED QString language(); // KF6: remove
 
     /**
      * @internal - returns timestamp of database
@@ -114,7 +114,7 @@ public:
      * The database contains all changes made _before_ this time and
      * _might_ contain changes made after that.
      */
-    quint32 timeStamp(); // KF6: remove
+    KSERVICE_DEPRECATED quint32 timeStamp(); // KF6: remove
 
     /**
      * @internal - returns update signature of database
@@ -125,7 +125,7 @@ public:
      * Touching this file causes the database to be recreated
      * from scratch.
      */
-    quint32 updateSignature(); // KF6: remove
+    KSERVICE_DEPRECATED quint32 updateSignature(); // KF6: remove
 
     /**
      * @internal - returns all directories with information
@@ -146,8 +146,9 @@ public:
 
     /**
      * @internal - disables launching of kbuildsycoca
+     * @deprecated since 5.15, it only outputs a warning
      */
-    static void disableAutoRebuild();
+    KSERVICE_DEPRECATED static void disableAutoRebuild(); // KF6: remove
 
     /**
      * When you receive a "databaseChanged" signal, you can query here if
@@ -178,12 +179,15 @@ public:
 
 Q_SIGNALS:
     /**
-     * Connect to this to get notified when the database changes
-     * @deprecated use the databaseChanged(QStringList) signal
+     * Connect to this to get notified when the database changes.
+     *
+     * Example: after creating a .desktop file in KOpenWithDialog, it
+     * must wait until kbuildsycoca5 finishes until the KService::Ptr is available.
+     * Other examples: anything that displays a list of apps or plugins to the user
+     * and which is always visible (otherwise querying sycoca before showing
+     * could be enough).
      */
-#ifndef KSERVICE_NO_DEPRECATED
-    QT_MOC_COMPAT void databaseChanged(); // KDE5 TODO: remove
-#endif
+    void databaseChanged();
 
     /**
      * Connect to this to get notified when the database changes
@@ -196,7 +200,7 @@ Q_SIGNALS:
      * This can include the following resources (as defined in KStandardDirs) :
      * apps, xdgdata-apps, services, servicetypes, xdgdata-mime.
      */
-    void databaseChanged(const QStringList &changedResources);
+    void databaseChanged(const QStringList &changedResources); // KF6: deprecate
 
 protected:
     // @internal used by kbuildsycoca
@@ -207,11 +211,7 @@ protected:
     friend class KSycocaFactory;
     friend class KSycocaDict;
 
-private Q_SLOTS:
-    /**
-     * internal function for receiving kbuildsycoca's signal, when the sycoca file changes
-     */
-    void notifyDatabaseChanged(const QStringList &);
+    void connectNotify(const QMetaMethod &signal) Q_DECL_OVERRIDE;
 
 private:
     /**
@@ -229,6 +229,7 @@ private:
     };
 
     KSycocaHeader readSycocaHeader();
+    bool needsRebuild();
 
     friend class KBuildSycoca;
     friend class Kded;
diff --git a/src/sycoca/ksycoca_p.h b/src/sycoca/ksycoca_p.h
index 1a377e3..a86148a 100644
--- a/src/sycoca/ksycoca_p.h
+++ b/src/sycoca/ksycoca_p.h
@@ -25,6 +25,7 @@
 #include <QStringList>
 #include <QElapsedTimer>
 #include <QDateTime>
+#include <kdirwatch.h>
 class QFile;
 class QDataStream;
 class KSycocaAbstractDevice;
@@ -52,6 +53,11 @@ public:
     void checkDirectories(BehaviorsIfNotFound ifNotFound);
 
     /**
+     * Check if the on-disk cache needs to be rebuilt, and return true
+     */
+    bool needsRebuild();
+
+    /**
      * Recreate the cache and reopen the database
      */
     bool buildSycoca(BehaviorsIfNotFound ifNotFound);
@@ -61,6 +67,9 @@ public:
     KSycocaAbstractDevice *device();
     QDataStream *&stream();
 
+    QString findDatabase();
+    void slotDatabaseChanged();
+
     enum {
         DatabaseNotOpen, // openDatabase must be called
         NoDatabase, // not found, so we opened a dummy one instead
@@ -88,6 +97,14 @@ public:
 
     QElapsedTimer m_lastCheck;
     QDateTime m_dbLastModified;
+
+    // Using KDirWatch because it will reliably tell us everytime ksycoca is recreated.
+    // QFileSystemWatcher's inotify implementation easily gets confused between "removed" and "changed",
+    // and fails to re-add an inotify watch after the file was replaced at some point (KServiceTest::testThreads),
+    // thinking it only got changed and not removed+recreated.
+    KDirWatch m_fileWatcher;
+    bool m_haveListeners;
+
 private:
     KSycocaFactoryList m_factories;
     size_t sycoca_size;
diff --git a/src/sycoca/ksycocafactory_p.h b/src/sycoca/ksycocafactory_p.h
index e2f5e83..c54bfc7 100644
--- a/src/sycoca/ksycocafactory_p.h
+++ b/src/sycoca/ksycocafactory_p.h
@@ -34,8 +34,9 @@ template <typename KT, typename VT> class QHash;
 typedef QHash<QString, KSycocaEntry::Ptr> KSycocaEntryDict;
 class KSycocaFactoryPrivate;
 /**
- * @internal (only exported for kbuildsycoca)
+ * @internal
  * Base class for sycoca factories
+ * Exported for unit tests
  */
 class KSERVICE_EXPORT KSycocaFactory
 {
@@ -160,7 +161,7 @@ protected:
  * This, instead of a typedef, allows to declare "class ..." in header files.
  * @internal
  */
-class KSERVICE_EXPORT KSycocaFactoryList : public QList<KSycocaFactory *> //krazy:exclude=dpointer (acts as a typedef)
+class KSycocaFactoryList : public QList<KSycocaFactory *> //krazy:exclude=dpointer (acts as a typedef)
 {
 public:
     KSycocaFactoryList() { }
diff --git a/src/sycoca/ksycocaresourcelist_p.h b/src/sycoca/ksycocaresourcelist_p.h
new file mode 100644
index 0000000..ee60efb
--- /dev/null
+++ b/src/sycoca/ksycocaresourcelist_p.h
@@ -0,0 +1,47 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 1999 David Faure <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+#ifndef KSYCOCARESOURCELIST_H
+#define KSYCOCARESOURCELIST_H
+
+#include <QtCore/QLinkedList>
+#include <QtCore/QString>
+
+struct KSycocaResource {
+    QByteArray resource;
+    QString subdir;
+    QString extension;
+};
+
+class KSycocaResourceList : public QLinkedList<KSycocaResource>
+{
+public:
+    KSycocaResourceList() { }
+
+    // resource is just used in the databaseChanged signal
+    // subdir is always under QStandardPaths::GenericDataLocation. E.g. mime, kservices5, etc.
+    void add(const QByteArray &resource, const QString &subdir, const QString &filter)
+    {
+        KSycocaResource res;
+        res.resource = resource;
+        res.subdir = subdir;
+        res.extension = filter.mid(1);
+        append(res);
+    }
+};
+
+#endif
diff --git a/src/sycoca/ksycocautils_p.h b/src/sycoca/ksycocautils_p.h
index 6110ea8..c14057b 100644
--- a/src/sycoca/ksycocautils_p.h
+++ b/src/sycoca/ksycocautils_p.h
@@ -20,20 +20,17 @@
 #ifndef KSYCOCAUTILS_P_H
 #define KSYCOCAUTILS_P_H
 
-#include "kservice_export.h"
 class QString;
 class QStringList;
 class QDataStream;
 
 namespace KSycocaUtilsPrivate
 {
-// exported for kbuildsycoca
-
 /**
  * Safe demarshalling functions.
  */
-KSERVICE_EXPORT void read(QDataStream &s, QString &str);
-KSERVICE_EXPORT void read(QDataStream &s, QStringList &list);
+void read(QDataStream &s, QString &str);
+void read(QDataStream &s, QStringList &list);
 }
 
 #endif /* KSYCOCAUTILS_P_H */
diff --git a/src/sycoca/vfolder_menu.cpp b/src/sycoca/vfolder_menu.cpp
new file mode 100644
index 0000000..b17ef2d
--- /dev/null
+++ b/src/sycoca/vfolder_menu.cpp
@@ -0,0 +1,1436 @@
+/*  This file is part of the KDE libraries
+ *  Copyright (C) 2003 Waldo Bastian <bastian@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ **/
+
+#include "vfolder_menu_p.h"
+#include "kbuildservicefactory_p.h"
+#include "kbuildsycocainterface_p.h"
+
+#include <kservice.h>
+
+#include <QDebug>
+#include <QtCore/QMap>
+#include <QtCore/QFile>
+#include <QtCore/QDir>
+#include <QtCore/QRegExp>
+#include <QtCore/QDirIterator>
+#include <QStandardPaths>
+
+static void foldNode(QDomElement &docElem, QDomElement &e, QMap<QString, QDomElement> &dupeList, QString s = QString()) //krazy:exclude=passbyvalue
+{
+    if (s.isEmpty()) {
+        s = e.text();
+    }
+    QMap<QString, QDomElement>::iterator it = dupeList.find(s);
+    if (it != dupeList.end()) {
+        //qDebug() << e.tagName() << "and" << s << "requires combining!";
+
+        docElem.removeChild(*it);
+        dupeList.erase(it);
+    }
+    dupeList.insert(s, e);
+}
+
+static void replaceNode(QDomElement &docElem, QDomNode &n, const QStringList &list, const QString &tag)
+{
+    for (QStringList::ConstIterator it = list.begin();
+            it != list.end(); ++it) {
+        QDomElement e = docElem.ownerDocument().createElement(tag);
+        QDomText txt = docElem.ownerDocument().createTextNode(*it);
+        e.appendChild(txt);
+        docElem.insertAfter(e, n);
+    }
+
+    QDomNode next = n.nextSibling();
+    docElem.removeChild(n);
+    n = next;
+//   qDebug() << "Next tag = " << n.toElement().tagName();
+}
+
+void VFolderMenu::registerFile(const QString &file)
+{
+    int i = file.lastIndexOf('/');
+    if (i < 0) {
+        return;
+    }
+
+    QString dir = file.left(i + 1); // Include trailing '/'
+    registerDirectory(dir);
+}
+
+void VFolderMenu::registerDirectory(const QString &directory)
+{
+    m_allDirectories.append(directory);
+}
+
+QStringList VFolderMenu::allDirectories()
+{
+    if (m_allDirectories.isEmpty()) {
+        return m_allDirectories;
+    }
+    m_allDirectories.sort();
+
+    QStringList::Iterator it = m_allDirectories.begin();
+    QString previous = *it++;
+    for (; it != m_allDirectories.end();) {
+#ifndef Q_OS_WIN
+        if ((*it).startsWith(previous))
+#else
+        if ((*it).startsWith(previous, Qt::CaseInsensitive))
+#endif
+        {
+            it = m_allDirectories.erase(it);
+        } else {
+            previous = *it;
+            ++it;
+        }
+    }
+    return m_allDirectories;
+}
+
+static void
+track(const QString &menuId, const QString &menuName, const QHash<QString, KService::Ptr> &includeList, const QHash<QString, KService::Ptr> &excludeList, const QHash<QString, KService::Ptr> &itemList, const QString &comment)
+{
+    if (itemList.contains(menuId)) {
+        printf("%s: %s INCL %d EXCL %d\n", qPrintable(menuName), qPrintable(comment), includeList.contains(menuId) ? 1 : 0, excludeList.contains(menuId) ? 1 : 0);
+    }
+}
+
+void
+VFolderMenu::includeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
+{
+    foreach (const KService::Ptr &p, items2) {
+        items1.insert(p->menuId(), p);
+    }
+}
+
+void
+VFolderMenu::matchItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
+{
+    foreach (const KService::Ptr &p, items1) {
+        QString id = p->menuId();
+        if (!items2.contains(id)) {
+            items1.remove(id);
+        }
+    }
+}
+
+void
+VFolderMenu::excludeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2)
+{
+    foreach (const KService::Ptr &p, items2) {
+        items1.remove(p->menuId());
+    }
+}
+
+VFolderMenu::SubMenu *
+VFolderMenu::takeSubMenu(SubMenu *parentMenu, const QString &menuName)
+{
+    const int i = menuName.indexOf('/');
+    const QString s1 = i > 0 ? menuName.left(i) : menuName;
+    const QString s2 = menuName.mid(i + 1);
+
+    // Look up menu
+    for (QList<SubMenu *>::Iterator it = parentMenu->subMenus.begin(); it != parentMenu->subMenus.end(); ++it) {
+        SubMenu *menu = *it;
+        if (menu->name == s1) {
+            if (i == -1) {
+                // Take it out
+                parentMenu->subMenus.erase(it);
+                return menu;
+            } else {
+                return takeSubMenu(menu, s2);
+            }
+        }
+    }
+    return 0; // Not found
+}
+
+void
+VFolderMenu::mergeMenu(SubMenu *menu1, SubMenu *menu2, bool reversePriority)
+{
+    if (m_track) {
+        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->items, QString("Before MenuMerge w. %1 (incl)").arg(menu2->name));
+        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->excludeItems, QString("Before MenuMerge w. %1 (excl)").arg(menu2->name));
+    }
+    if (reversePriority) {
+        // Merge menu1 with menu2, menu1 takes precedent
+        excludeItems(menu2->items, menu1->excludeItems);
+        includeItems(menu1->items, menu2->items);
+        excludeItems(menu2->excludeItems, menu1->items);
+        includeItems(menu1->excludeItems, menu2->excludeItems);
+    } else {
+        // Merge menu1 with menu2, menu2 takes precedent
+        excludeItems(menu1->items, menu2->excludeItems);
+        includeItems(menu1->items, menu2->items);
+        includeItems(menu1->excludeItems, menu2->excludeItems);
+        menu1->isDeleted = menu2->isDeleted;
+    }
+    while (!menu2->subMenus.isEmpty()) {
+        SubMenu *subMenu = menu2->subMenus.takeFirst();
+        insertSubMenu(menu1, subMenu->name, subMenu, reversePriority);
+    }
+
+    if (reversePriority) {
+        // Merge menu1 with menu2, menu1 takes precedent
+        if (menu1->directoryFile.isEmpty()) {
+            menu1->directoryFile = menu2->directoryFile;
+        }
+        if (menu1->defaultLayoutNode.isNull()) {
+            menu1->defaultLayoutNode = menu2->defaultLayoutNode;
+        }
+        if (menu1->layoutNode.isNull()) {
+            menu1->layoutNode = menu2->layoutNode;
+        }
+    } else {
+        // Merge menu1 with menu2, menu2 takes precedent
+        if (!menu2->directoryFile.isEmpty()) {
+            menu1->directoryFile = menu2->directoryFile;
+        }
+        if (!menu2->defaultLayoutNode.isNull()) {
+            menu1->defaultLayoutNode = menu2->defaultLayoutNode;
+        }
+        if (!menu2->layoutNode.isNull()) {
+            menu1->layoutNode = menu2->layoutNode;
+        }
+    }
+
+    if (m_track) {
+        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->items, QString("After MenuMerge w. %1 (incl)").arg(menu2->name));
+        track(m_trackId, menu1->name, menu1->items, menu1->excludeItems, menu2->excludeItems, QString("After MenuMerge w. %1 (excl)").arg(menu2->name));
+    }
+
+    delete menu2;
+}
+
+void
+VFolderMenu::insertSubMenu(SubMenu *parentMenu, const QString &menuName, SubMenu *newMenu, bool reversePriority)
+{
+    const int i = menuName.indexOf('/');
+    const QString s1 = menuName.left(i);
+    const QString s2 = menuName.mid(i + 1);
+
+    // Look up menu
+    foreach (SubMenu *menu, parentMenu->subMenus) {
+        if (menu->name == s1) {
+            if (i == -1) {
+                mergeMenu(menu, newMenu, reversePriority);
+                return;
+            } else {
+                insertSubMenu(menu, s2, newMenu, reversePriority);
+                return;
+            }
+        }
+    }
+    if (i == -1) {
+        // Add it here
+        newMenu->name = menuName;
+        parentMenu->subMenus.append(newMenu);
+    } else {
+        SubMenu *menu = new SubMenu;
+        menu->name = s1;
+        parentMenu->subMenus.append(menu);
+        insertSubMenu(menu, s2, newMenu);
+    }
+}
+
+void
+VFolderMenu::insertService(SubMenu *parentMenu, const QString &name, KService::Ptr newService)
+{
+    const int i = name.indexOf('/');
+
+    if (i == -1) {
+        // Add it here
+        parentMenu->items.insert(newService->menuId(), newService);
+        return;
+    }
+
+    QString s1 = name.left(i);
+    QString s2 = name.mid(i + 1);
+
+    // Look up menu
+    foreach (SubMenu *menu, parentMenu->subMenus) {
+        if (menu->name == s1) {
+            insertService(menu, s2, newService);
+            return;
+        }
+    }
+
+    SubMenu *menu = new SubMenu;
+    menu->name = s1;
+    parentMenu->subMenus.append(menu);
+    insertService(menu, s2, newService);
+}
+
+VFolderMenu::VFolderMenu(KBuildServiceFactory *serviceFactory, KBuildSycocaInterface *kbuildsycocaInterface)
+    : m_appsInfo(0)
+    , m_rootMenu(0)
+    , m_currentMenu(0)
+    , m_track(false)
+    , m_serviceFactory(serviceFactory)
+    , m_kbuildsycocaInterface(kbuildsycocaInterface)
+{
+    m_usedAppsDict.reserve(797);
+    initDirs();
+}
+
+VFolderMenu::~VFolderMenu()
+{
+    qDeleteAll(m_appsInfoList);
+    delete m_rootMenu;
+}
+
+#define FOR_ALL_APPLICATIONS(it) \
+    foreach (AppsInfo *info, m_appsInfoStack) \
+    { \
+        QHashIterator<QString,KService::Ptr> it = info->applications; \
+        while (it.hasNext()) \
+        { \
+            it.next();
+#define FOR_ALL_APPLICATIONS_END } }
+
+#define FOR_CATEGORY(category, it) \
+    foreach (AppsInfo *info, m_appsInfoStack) \
+    { \
+        const KService::List list = info->dictCategories.value(category); \
+        for(KService::List::ConstIterator it = list.constBegin(); \
+                it != list.constEnd(); ++it) \
+        {
+#define FOR_CATEGORY_END } }
+
+KService::Ptr
+VFolderMenu::findApplication(const QString &relPath)
+{
+    foreach (AppsInfo *info, m_appsInfoStack) {
+        if (info->applications.contains(relPath)) {
+            KService::Ptr s = info->applications[relPath];
+            if (s) {
+                return s;
+            }
+        }
+    }
+    return KService::Ptr();
+}
+
+void
+VFolderMenu::addApplication(const QString &id, KService::Ptr service)
+{
+    service->setMenuId(id);
+    m_appsInfo->applications.insert(id, service); // replaces, if already there
+    m_serviceFactory->addEntry(KSycocaEntry::Ptr(service));
+}
+
+void
+VFolderMenu::buildApplicationIndex(bool unusedOnly)
+{
+    foreach (AppsInfo *info, m_appsInfoList) {
+        info->dictCategories.clear();
+        QMutableHashIterator<QString, KService::Ptr> it = info->applications;
+        while (it.hasNext()) {
+            KService::Ptr s = it.next().value();
+            if (unusedOnly && m_usedAppsDict.contains(s->menuId())) {
+                // Remove and skip this one
+                it.remove();
+                continue;
+            }
+
+            Q_FOREACH (const QString &cat, s->categories()) {
+                info->dictCategories[cat].append(s); // find or insert entry in hash
+            }
+        }
+    }
+}
+
+void
+VFolderMenu::createAppsInfo()
+{
+    if (m_appsInfo) {
+        return;
+    }
+
+    m_appsInfo = new AppsInfo;
+    m_appsInfoStack.prepend(m_appsInfo);
+    m_appsInfoList.append(m_appsInfo);
+    m_currentMenu->apps_info = m_appsInfo;
+}
+
+void
+VFolderMenu::loadAppsInfo()
+{
+    m_appsInfo = m_currentMenu->apps_info;
+    if (!m_appsInfo) {
+        return;    // No appsInfo for this menu
+    }
+
+    if (m_appsInfoStack.count() && m_appsInfoStack.first() == m_appsInfo) {
+        return;    // Already added (By createAppsInfo?)
+    }
+
+    m_appsInfoStack.prepend(m_appsInfo); // Add
+}
+
+void
+VFolderMenu::unloadAppsInfo()
+{
+    m_appsInfo = m_currentMenu->apps_info;
+    if (!m_appsInfo) {
+        return;    // No appsInfo for this menu
+    }
+
+    if (m_appsInfoStack.first() != m_appsInfo) {
+        return; // Already removed (huh?)
+    }
+
+    m_appsInfoStack.removeAll(m_appsInfo); // Remove
+    m_appsInfo = 0;
+}
+
+QString
+VFolderMenu::absoluteDir(const QString &_dir, const QString &baseDir, bool keepRelativeToCfg)
+{
+    QString dir = _dir;
+    if (QDir::isRelativePath(dir)) {
+        dir = baseDir + dir;
+    }
+
+    bool relative = QDir::isRelativePath(dir);
+    if (relative && !keepRelativeToCfg) {
+        relative = false;
+        dir = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + dir, QStandardPaths::LocateDirectory);
+    }
+
+    if (!relative) {
+        QString resolved = QDir(dir).canonicalPath();
+        if (!resolved.isEmpty()) {
+            dir = resolved;
+        }
+    }
+
+    if (!dir.endsWith('/')) {
+        dir += '/';
+    }
+
+    return dir;
+}
+
+static void tagBaseDir(QDomDocument &doc, const QString &tag, const QString &dir)
+{
+    QDomNodeList mergeFileList = doc.elementsByTagName(tag);
+    for (int i = 0; i < mergeFileList.count(); i++) {
+        QDomAttr attr = doc.createAttribute(QStringLiteral("__BaseDir"));
+        attr.setValue(dir);
+        mergeFileList.item(i).toElement().setAttributeNode(attr);
+    }
+}
+
+static void tagBasePath(QDomDocument &doc, const QString &tag, const QString &path)
+{
+    QDomNodeList mergeFileList = doc.elementsByTagName(tag);
+    for (int i = 0; i < mergeFileList.count(); i++) {
+        QDomAttr attr = doc.createAttribute(QStringLiteral("__BasePath"));
+        attr.setValue(path);
+        mergeFileList.item(i).toElement().setAttributeNode(attr);
+    }
+}
+
+QDomDocument
+VFolderMenu::loadDoc()
+{
+    QDomDocument doc;
+    if (m_docInfo.path.isEmpty()) {
+        return doc;
+    }
+    QFile file(m_docInfo.path);
+    if (!file.open(QIODevice::ReadOnly)) {
+        qWarning() << "Could not open " << m_docInfo.path;
+        return doc;
+    }
+    QString errorMsg;
+    int errorRow;
+    int errorCol;
+    if (!doc.setContent(&file, &errorMsg, &errorRow, &errorCol)) {
+        qWarning() << "Parse error in " << m_docInfo.path << ", line " << errorRow << ", col " << errorCol << ": " << errorMsg;
+        file.close();
+        return doc;
+    }
+    file.close();
+
+    tagBaseDir(doc, QStringLiteral("MergeFile"), m_docInfo.baseDir);
+    tagBasePath(doc, QStringLiteral("MergeFile"), m_docInfo.path);
+    tagBaseDir(doc, QStringLiteral("MergeDir"), m_docInfo.baseDir);
+    tagBaseDir(doc, QStringLiteral("DirectoryDir"), m_docInfo.baseDir);
+    tagBaseDir(doc, QStringLiteral("AppDir"), m_docInfo.baseDir);
+    tagBaseDir(doc, QStringLiteral("LegacyDir"), m_docInfo.baseDir);
+
+    return doc;
+}
+
+void
+VFolderMenu::mergeFile(QDomElement &parent, const QDomNode &mergeHere)
+{
+    //qDebug() << m_docInfo.path;
+    QDomDocument doc = loadDoc();
+
+    QDomElement docElem = doc.documentElement();
+    QDomNode n = docElem.firstChild();
+    QDomNode last = mergeHere;
+    while (!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+        QDomNode next = n.nextSibling();
+
+        if (e.isNull()) {
+            // Skip
+        }
+        // The spec says we must ignore any Name nodes
+        else if (e.tagName() != "Name") {
+            parent.insertAfter(n, last);
+            last = n;
+        }
+
+        docElem.removeChild(n);
+        n = next;
+    }
+}
+
+void
+VFolderMenu::mergeMenus(QDomElement &docElem, QString &name)
+{
+    QMap<QString, QDomElement> menuNodes;
+    QMap<QString, QDomElement> directoryNodes;
+    QMap<QString, QDomElement> appDirNodes;
+    QMap<QString, QDomElement> directoryDirNodes;
+    QMap<QString, QDomElement> legacyDirNodes;
+    QDomElement defaultLayoutNode;
+    QDomElement layoutNode;
+
+    QDomNode n = docElem.firstChild();
+    while (!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+        if (e.isNull()) {
+// qDebug() << "Empty node";
+        } else if (e.tagName() == QLatin1String("DefaultAppDirs")) {
+            // Replace with m_defaultAppDirs
+            replaceNode(docElem, n, m_defaultAppDirs, "AppDir");
+            continue;
+        } else if (e.tagName() == QLatin1String("DefaultDirectoryDirs")) {
+            // Replace with m_defaultDirectoryDirs
+            replaceNode(docElem, n, m_defaultDirectoryDirs, "DirectoryDir");
+            continue;
+        } else if (e.tagName() == QLatin1String("DefaultMergeDirs")) {
+            // Replace with m_defaultMergeDirs
+            replaceNode(docElem, n, m_defaultMergeDirs, "MergeDir");
+            continue;
+        } else if (e.tagName() == QLatin1String("AppDir")) {
+            // Filter out dupes
+            foldNode(docElem, e, appDirNodes);
+        } else if (e.tagName() == QLatin1String("DirectoryDir")) {
+            // Filter out dupes
+            foldNode(docElem, e, directoryDirNodes);
+        } else if (e.tagName() == QLatin1String("LegacyDir")) {
+            // Filter out dupes
+            foldNode(docElem, e, legacyDirNodes);
+        } else if (e.tagName() == QLatin1String("Directory")) {
+            // Filter out dupes
+            foldNode(docElem, e, directoryNodes);
+        } else if (e.tagName() == QLatin1String("Move")) {
+            // Filter out dupes
+            QString orig;
+            QDomNode n2 = e.firstChild();
+            while (!n2.isNull()) {
+                QDomElement e2 = n2.toElement(); // try to convert the node to an element.
+                if (e2.tagName() == QLatin1String("Old")) {
+                    orig = e2.text();
+                    break;
+                }
+                n2 = n2.nextSibling();
+            }
+            foldNode(docElem, e, appDirNodes, orig);
+        } else if (e.tagName() == QLatin1String("Menu")) {
+            QString name;
+            mergeMenus(e, name);
+            QMap<QString, QDomElement>::iterator it = menuNodes.find(name);
+            if (it != menuNodes.end()) {
+                QDomElement docElem2 = *it;
+                QDomNode n2 = docElem2.firstChild();
+                QDomNode first = e.firstChild();
+                while (!n2.isNull()) {
+                    QDomElement e2 = n2.toElement(); // try to convert the node to an element.
+                    QDomNode n3 = n2.nextSibling();
+                    e.insertBefore(n2, first);
+                    docElem2.removeChild(n2);
+                    n2 = n3;
+                }
+                // We still have duplicated Name entries
+                // but we don't care about that
+
+                docElem.removeChild(docElem2);
+                menuNodes.erase(it);
+            }
+            menuNodes.insert(name, e);
+        } else if (e.tagName() == QLatin1String("MergeFile")) {
+            if ((e.attribute(QStringLiteral("type")) == QLatin1String("parent"))) {
+                // Ignore e.text(), as per the standard. We'll just look up the parent (more global) xml file.
+                pushDocInfoParent(e.attribute(QStringLiteral("__BasePath")), e.attribute(QStringLiteral("__BaseDir")));
+            } else {
+                pushDocInfo(e.text(), e.attribute(QStringLiteral("__BaseDir")));
+            }
+
+            if (!m_docInfo.path.isEmpty()) {
+                mergeFile(docElem, n);
+            }
+            popDocInfo();
+
+            QDomNode last = n;
+            n = n.nextSibling();
+            docElem.removeChild(last); // Remove the MergeFile node
+            continue;
+        } else if (e.tagName() == QLatin1String("MergeDir")) {
+            QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")), true);
+            Q_ASSERT(dir.endsWith('/'));
+
+            const bool relative = QDir::isRelativePath(dir);
+            const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + dir, QStandardPaths::LocateDirectory);
+            Q_FOREACH (const QString &menuDir, dirs) {
+                registerDirectory(menuDir);
+            }
+
+            QStringList fileList;
+            Q_FOREACH (const QString &menuDir, dirs) {
+                const QStringList fileNames = QDir(menuDir).entryList(QStringList() << QStringLiteral("*.menu"));
+                Q_FOREACH (const QString &file, fileNames) {
+                    const QString fileToAdd = relative ? dir + file : menuDir + file;
+                    if (!fileList.contains(fileToAdd)) {
+                        fileList.append(fileToAdd);
+                    }
+                }
+            }
+
+            Q_FOREACH (const QString &file, fileList) {
+                pushDocInfo(file);
+                mergeFile(docElem, n);
+                popDocInfo();
+            }
+
+            QDomNode last = n;
+            n = n.nextSibling();
+            docElem.removeChild(last); // Remove the MergeDir node
+
+            continue;
+        } else if (e.tagName() == QLatin1String("Name")) {
+            name = e.text();
+        } else if (e.tagName() == QLatin1String("DefaultLayout")) {
+            if (!defaultLayoutNode.isNull()) {
+                docElem.removeChild(defaultLayoutNode);
+            }
+            defaultLayoutNode = e;
+        } else if (e.tagName() == QLatin1String("Layout")) {
+            if (!layoutNode.isNull()) {
+                docElem.removeChild(layoutNode);
+            }
+            layoutNode = e;
+        }
+        n = n.nextSibling();
+    }
+}
+
+static QString makeRelative(const QString &dir)
+{
+    const QString canonical = QDir(dir).canonicalPath();
+    Q_FOREACH (const QString &base, QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, "menus", QStandardPaths::LocateDirectory)) {
+        if (canonical.startsWith(base)) {
+            return canonical.mid(base.length() + 1);
+        }
+    }
+    return dir;
+}
+
+void
+VFolderMenu::pushDocInfo(const QString &fileName, const QString &baseDir)
+{
+    m_docInfoStack.push(m_docInfo);
+    if (!baseDir.isEmpty()) {
+        if (!QDir::isRelativePath(baseDir)) {
+            m_docInfo.baseDir = makeRelative(baseDir);
+        } else {
+            m_docInfo.baseDir = baseDir;
+        }
+    }
+
+    QString baseName = fileName;
+    if (!QDir::isRelativePath(baseName)) {
+        registerFile(baseName);
+    } else {
+        baseName = m_docInfo.baseDir + baseName;
+    }
+
+    m_docInfo.path = locateMenuFile(fileName);
+    if (m_docInfo.path.isEmpty()) {
+        m_docInfo.baseDir.clear();
+        m_docInfo.baseName.clear();
+        qDebug() << "Menu" << fileName << "not found.";
+        return;
+    }
+    int i;
+    i = baseName.lastIndexOf('/');
+    if (i > 0) {
+        m_docInfo.baseDir = baseName.left(i + 1);
+        m_docInfo.baseName = baseName.mid(i + 1, baseName.length() - i - 6);
+    } else {
+        m_docInfo.baseDir.clear();
+        m_docInfo.baseName = baseName.left(baseName.length() - 5);
+    }
+}
+
+void
+VFolderMenu::pushDocInfoParent(const QString &basePath, const QString &baseDir)
+{
+    m_docInfoStack.push(m_docInfo);
+
+    m_docInfo.baseDir = baseDir;
+
+    QString fileName = basePath.mid(basePath.lastIndexOf('/') + 1);
+    m_docInfo.baseName = fileName.left(fileName.length() - 5);   // without ".menu"
+    QString baseName = QDir::cleanPath(m_docInfo.baseDir + fileName);
+
+    QStringList result = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
+
+    // Remove anything "more local" than basePath.
+    while (!result.isEmpty() && (result.at(0) != basePath)) {
+        result.removeFirst();
+    }
+
+    if (result.count() <= 1) {
+        m_docInfo.path.clear(); // No parent found
+        return;
+    }
+    // Now result.at(0) == basePath, take the next one, i.e. the one in the parent dir.
+    m_docInfo.path = result.at(1);
+}
+
+void
+VFolderMenu::popDocInfo()
+{
+    m_docInfo = m_docInfoStack.pop();
+}
+
+QString
+VFolderMenu::locateMenuFile(const QString &fileName)
+{
+    if (!QDir::isRelativePath(fileName)) {
+        if (QFile::exists(fileName)) {
+            return fileName;
+        }
+        return QString();
+    }
+
+    QString result;
+
+    QString xdgMenuPrefix = QString::fromLocal8Bit(qgetenv("XDG_MENU_PREFIX"));
+    if (!xdgMenuPrefix.isEmpty()) {
+        QFileInfo fileInfo(fileName);
+
+        QString fileNameOnly = fileInfo.fileName();
+        if (!fileNameOnly.startsWith(xdgMenuPrefix)) {
+            fileNameOnly = xdgMenuPrefix + fileNameOnly;
+        }
+
+        QString baseName = QDir::cleanPath(m_docInfo.baseDir +
+                                           fileInfo.path() + '/' + fileNameOnly);
+        result = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
+    }
+
+    if (result.isEmpty()) {
+        QString baseName = QDir::cleanPath(m_docInfo.baseDir + fileName);
+        result = QStandardPaths::locate(QStandardPaths::GenericConfigLocation, QStringLiteral("menus/") + baseName);
+    }
+
+    return result;
+}
+
+QString
+VFolderMenu::locateDirectoryFile(const QString &fileName)
+{
+    if (fileName.isEmpty()) {
+        return QString();
+    }
+
+    if (!QDir::isRelativePath(fileName)) {
+        if (QFile::exists(fileName)) {
+            return fileName;
+        }
+        return QString();
+    }
+
+    // First location in the list wins
+    for (QStringList::ConstIterator it = m_directoryDirs.constBegin();
+            it != m_directoryDirs.constEnd();
+            ++it) {
+        QString tmp = (*it) + fileName;
+        if (QFile::exists(tmp)) {
+            return tmp;
+        }
+    }
+
+    return QString();
+}
+
+void
+VFolderMenu::initDirs()
+{
+    m_defaultAppDirs = QStandardPaths::standardLocations(QStandardPaths::ApplicationsLocation);
+    m_defaultDirectoryDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, "desktop-directories", QStandardPaths::LocateDirectory);
+}
+
+void
+VFolderMenu::loadMenu(const QString &fileName)
+{
+    m_defaultMergeDirs.clear();
+
+    if (!fileName.endsWith(QLatin1String(".menu"))) {
+        return;
+    }
+
+    pushDocInfo(fileName);
+    m_defaultMergeDirs << m_docInfo.baseName + QStringLiteral("-merged/");
+    m_doc = loadDoc();
+    popDocInfo();
+
+    if (m_doc.isNull()) {
+        if (m_docInfo.path.isEmpty()) {
+            qCritical() << fileName << " not found in " << m_allDirectories << endl;
+        } else {
+            qWarning() << "Load error (" << m_docInfo.path << ")";
+        }
+        return;
+    }
+
+    QDomElement e = m_doc.documentElement();
+    QString name;
+    mergeMenus(e, name);
+}
+
+void
+VFolderMenu::processCondition(QDomElement &domElem, QHash<QString, KService::Ptr> &items)
+{
+    if (domElem.tagName() == QLatin1String("And")) {
+        QDomNode n = domElem.firstChild();
+        // Look for the first child element
+        while (!n.isNull()) { // loop in case of comments
+            QDomElement e = n.toElement();
+            n = n.nextSibling();
+            if (!e.isNull()) {
+                processCondition(e, items);
+                break; // we only want the first one
+            }
+        }
+
+        QHash<QString, KService::Ptr> andItems;
+        while (!n.isNull()) {
+            QDomElement e = n.toElement();
+            if (e.tagName() == QLatin1String("Not")) {
+                // Special handling for "and not"
+                QDomNode n2 = e.firstChild();
+                while (!n2.isNull()) {
+                    QDomElement e2 = n2.toElement();
+                    andItems.clear();
+                    processCondition(e2, andItems);
+                    excludeItems(items, andItems);
+                    n2 = n2.nextSibling();
+                }
+            } else {
+                andItems.clear();
+                processCondition(e, andItems);
+                matchItems(items, andItems);
+            }
+            n = n.nextSibling();
+        }
+    } else if (domElem.tagName() == QLatin1String("Or")) {
+        QDomNode n = domElem.firstChild();
+        // Look for the first child element
+        while (!n.isNull()) { // loop in case of comments
+            QDomElement e = n.toElement();
+            n = n.nextSibling();
+            if (!e.isNull()) {
+                processCondition(e, items);
+                break; // we only want the first one
+            }
+        }
+
+        QHash<QString, KService::Ptr> orItems;
+        while (!n.isNull()) {
+            QDomElement e = n.toElement();
+            if (!e.isNull()) {
+                orItems.clear();
+                processCondition(e, orItems);
+                includeItems(items, orItems);
+            }
+            n = n.nextSibling();
+        }
+    } else if (domElem.tagName() == QLatin1String("Not")) {
+        FOR_ALL_APPLICATIONS(it) {
+            KService::Ptr s = it.value();
+            items.insert(s->menuId(), s);
+        }
+        FOR_ALL_APPLICATIONS_END
+
+        QHash<QString, KService::Ptr> notItems;
+        QDomNode n = domElem.firstChild();
+        while (!n.isNull()) {
+            QDomElement e = n.toElement();
+            if (!e.isNull()) {
+                notItems.clear();
+                processCondition(e, notItems);
+                excludeItems(items, notItems);
+            }
+            n = n.nextSibling();
+        }
+    } else if (domElem.tagName() == QLatin1String("Category")) {
+        FOR_CATEGORY(domElem.text(), it) {
+            KService::Ptr s = *it;
+            items.insert(s->menuId(), s);
+        }
+        FOR_CATEGORY_END
+    } else if (domElem.tagName() == QLatin1String("All")) {
+        FOR_ALL_APPLICATIONS(it) {
+            KService::Ptr s = it.value();
+            items.insert(s->menuId(), s);
+        }
+        FOR_ALL_APPLICATIONS_END
+    } else if (domElem.tagName() == QLatin1String("Filename")) {
+        const QString filename = domElem.text();
+        //qDebug() << "Adding file" << filename;
+        KService::Ptr s = findApplication(filename);
+        if (s) {
+            items.insert(filename, s);
+        }
+    }
+}
+
+void
+VFolderMenu::loadApplications(const QString &dir, const QString &prefix)
+{
+    //qDebug() << "Looking up applications under" << dir;
+
+    QDirIterator it(dir);
+    while (it.hasNext()) {
+        it.next();
+        const QFileInfo fi = it.fileInfo();
+        const QString fn = fi.fileName();
+        if (fi.isDir() && !fi.isBundle()) {
+            if (fn == QLatin1String(".") || fn == QLatin1String("..")) {
+                continue;
+            }
+            loadApplications(fi.filePath(), prefix + fn + '-');
+            continue;
+        }
+        if (fi.isFile()) {
+            if (!fn.endsWith(QLatin1String(".desktop"))) {
+                continue;
+            }
+            KService::Ptr service = m_kbuildsycocaInterface->createService(fi.absoluteFilePath());
+            if (service) {
+                addApplication(prefix + fn, service);
+            }
+        }
+    }
+}
+
+void
+VFolderMenu::processLegacyDir(const QString &dir, const QString &relDir, const QString &prefix)
+{
+    //qDebug().nospace() << "processLegacyDir(" << dir << ", " << relDir << ", " << prefix << ")";
+
+    QHash<QString, KService::Ptr> items;
+    QDirIterator it(dir);
+    while (it.hasNext()) {
+        it.next();
+        const QFileInfo fi = it.fileInfo();
+        const QString fn = fi.fileName();
+        if (fi.isDir()) {
+            if (fn == QLatin1String(".") || fn == QLatin1String("..")) {
+                continue;
+            }
+            SubMenu *parentMenu = m_currentMenu;
+
+            m_currentMenu = new SubMenu;
+            m_currentMenu->name = fn;
+            m_currentMenu->directoryFile = fi.absoluteFilePath() + QStringLiteral("/.directory");
+
+            parentMenu->subMenus.append(m_currentMenu);
+
+            processLegacyDir(fi.filePath(), relDir + fn + '/', prefix);
+            m_currentMenu = parentMenu;
+            continue;
+        }
+        if (fi.isFile() /*&& !fi.isSymLink() ?? */) {
+            if (!fn.endsWith(QLatin1String(".desktop"))) {
+                continue;
+            }
+            KService::Ptr service = m_kbuildsycocaInterface->createService(fi.absoluteFilePath());
+            if (service) {
+                const QString id = prefix + fn;
+
+                // TODO: Add legacy category
+                addApplication(id, service);
+                items.insert(service->menuId(), service);
+
+                if (service->categories().isEmpty()) {
+                    m_currentMenu->items.insert(id, service);
+                }
+            }
+        }
+    }
+    markUsedApplications(items);
+}
+
+void
+VFolderMenu::processMenu(QDomElement &docElem, int pass)
+{
+    SubMenu *parentMenu = m_currentMenu;
+    int oldDirectoryDirsCount = m_directoryDirs.count();
+
+    QString name;
+    QString directoryFile;
+    bool onlyUnallocated = false;
+    bool isDeleted = false;
+    QDomElement defaultLayoutNode;
+    QDomElement layoutNode;
+
+    QDomElement query;
+    QDomNode n = docElem.firstChild();
+    while (!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+        if (e.tagName() == QLatin1String("Name")) {
+            name = e.text();
+        } else if (e.tagName() == QLatin1String("Directory")) {
+            directoryFile = e.text();
+        } else if (e.tagName() == QLatin1String("DirectoryDir")) {
+            QString dir = absoluteDir(e.text(), e.attribute("__BaseDir"));
+
+            m_directoryDirs.prepend(dir);
+        } else if (e.tagName() == QLatin1String("OnlyUnallocated")) {
+            onlyUnallocated = true;
+        } else if (e.tagName() == QLatin1String("NotOnlyUnallocated")) {
+            onlyUnallocated = false;
+        } else if (e.tagName() == QLatin1String("Deleted")) {
+            isDeleted = true;
+        } else if (e.tagName() == QLatin1String("NotDeleted")) {
+            isDeleted = false;
+        } else if (e.tagName() == QLatin1String("DefaultLayout")) {
+            defaultLayoutNode = e;
+        } else if (e.tagName() == QLatin1String("Layout")) {
+            layoutNode = e;
+        }
+        n = n.nextSibling();
+    }
+
+    // Setup current menu entry
+    if (pass == 0) {
+        m_currentMenu = 0;
+        // Look up menu
+        if (parentMenu) {
+            foreach (SubMenu *menu, parentMenu->subMenus) {
+                if (menu->name == name) {
+                    m_currentMenu = menu;
+                    break;
+                }
+            }
+        }
+
+        if (!m_currentMenu) { // Not found?
+            // Create menu
+            m_currentMenu = new SubMenu;
+            m_currentMenu->name = name;
+
+            if (parentMenu) {
+                parentMenu->subMenus.append(m_currentMenu);
+            } else {
+                m_rootMenu = m_currentMenu;
+            }
+        }
+        if (directoryFile.isEmpty()) {
+            //qDebug() << "Menu" << name << "does not specify a directory file.";
+        }
+
+        // Override previous directoryFile iff available
+        QString tmp = locateDirectoryFile(directoryFile);
+        if (! tmp.isEmpty()) {
+            m_currentMenu->directoryFile = tmp;
+        }
+        m_currentMenu->isDeleted = isDeleted;
+
+        m_currentMenu->defaultLayoutNode = defaultLayoutNode;
+        m_currentMenu->layoutNode = layoutNode;
+    } else {
+        // Look up menu
+        if (parentMenu) {
+            foreach (SubMenu *menu, parentMenu->subMenus) {
+                if (menu->name == name) {
+                    m_currentMenu = menu;
+                    break;
+                }
+            }
+        } else {
+            m_currentMenu = m_rootMenu;
+        }
+    }
+
+    // Process AppDir and LegacyDir
+    if (pass == 0) {
+        QDomElement query;
+        QDomNode n = docElem.firstChild();
+        while (!n.isNull()) {
+            QDomElement e = n.toElement(); // try to convert the node to an element.
+            if (e.tagName() == QLatin1String("AppDir")) {
+                createAppsInfo();
+                QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")));
+
+                registerDirectory(dir);
+
+                loadApplications(dir, QString());
+            } else if (e.tagName() == QLatin1String("LegacyDir")) {
+                createAppsInfo();
+                QString dir = absoluteDir(e.text(), e.attribute(QStringLiteral("__BaseDir")));
+
+                QString prefix = e.attributes().namedItem(QStringLiteral("prefix")).toAttr().value();
+
+                SubMenu *oldMenu = m_currentMenu;
+                m_currentMenu = new SubMenu;
+
+                registerDirectory(dir);
+
+                processLegacyDir(dir, QString(), prefix);
+
+                m_legacyNodes.insert(dir, m_currentMenu);
+                m_currentMenu = oldMenu;
+            }
+            n = n.nextSibling();
+        }
+    }
+
+    loadAppsInfo(); // Update the scope wrt the list of applications
+
+    if (((pass == 1) && !onlyUnallocated) || ((pass == 2) && onlyUnallocated)) {
+        n = docElem.firstChild();
+
+        while (!n.isNull()) {
+            QDomElement e = n.toElement(); // try to convert the node to an element.
+            if (e.tagName() == QLatin1String("Include")) {
+                QHash<QString, KService::Ptr> items;
+
+                QDomNode n2 = e.firstChild();
+                while (!n2.isNull()) {
+                    QDomElement e2 = n2.toElement();
+                    items.clear();
+                    processCondition(e2, items);
+                    if (m_track) {
+                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "Before <Include>");
+                    }
+                    includeItems(m_currentMenu->items, items);
+                    excludeItems(m_currentMenu->excludeItems, items);
+                    markUsedApplications(items);
+
+                    if (m_track) {
+                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "After <Include>");
+                    }
+
+                    n2 = n2.nextSibling();
+                }
+            }
+
+            else if (e.tagName() == QLatin1String("Exclude")) {
+                QHash<QString, KService::Ptr> items;
+
+                QDomNode n2 = e.firstChild();
+                while (!n2.isNull()) {
+                    QDomElement e2 = n2.toElement();
+                    items.clear();
+                    processCondition(e2, items);
+                    if (m_track) {
+                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "Before <Exclude>");
+                    }
+                    excludeItems(m_currentMenu->items, items);
+                    includeItems(m_currentMenu->excludeItems, items);
+                    if (m_track) {
+                        track(m_trackId, m_currentMenu->name, m_currentMenu->items, m_currentMenu->excludeItems, items, "After <Exclude>");
+                    }
+                    n2 = n2.nextSibling();
+                }
+            }
+
+            n = n.nextSibling();
+        }
+    }
+
+    n = docElem.firstChild();
+    while (!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+        if (e.tagName() == QLatin1String("Menu")) {
+            processMenu(e, pass);
+        }
+// We insert legacy dir in pass 0, this way the order in the .menu-file determines
+// which .directory file gets used, but the menu-entries of legacy-menus will always
+// have the lowest priority.
+//      else if (((pass == 1) && !onlyUnallocated) || ((pass == 2) && onlyUnallocated))
+        else if (pass == 0) {
+            if (e.tagName() == QLatin1String("LegacyDir")) {
+                // Add legacy nodes to Menu structure
+                QString dir = absoluteDir(e.text(), e.attribute("__BaseDir"));
+                SubMenu *legacyMenu = m_legacyNodes[dir];
+                if (legacyMenu) {
+                    mergeMenu(m_currentMenu, legacyMenu);
+                }
+            }
+        }
+        n = n.nextSibling();
+    }
+
+    if (pass == 2) {
+        n = docElem.firstChild();
+        while (!n.isNull()) {
+            QDomElement e = n.toElement(); // try to convert the node to an element.
+            if (e.tagName() == QLatin1String("Move")) {
+                QString orig;
+                QString dest;
+                QDomNode n2 = e.firstChild();
+                while (!n2.isNull()) {
+                    QDomElement e2 = n2.toElement(); // try to convert the node to an element.
+                    if (e2.tagName() == QLatin1String("Old")) {
+                        orig = e2.text();
+                    }
+                    if (e2.tagName() == QLatin1String("New")) {
+                        dest = e2.text();
+                    }
+                    n2 = n2.nextSibling();
+                }
+                //qDebug() << "Moving" << orig << "to" << dest;
+                if (!orig.isEmpty() && !dest.isEmpty()) {
+                    SubMenu *menu = takeSubMenu(m_currentMenu, orig);
+                    if (menu) {
+                        insertSubMenu(m_currentMenu, dest, menu, true); // Destination has priority
+                    }
+                }
+            }
+            n = n.nextSibling();
+        }
+
+    }
+
+    unloadAppsInfo(); // Update the scope wrt the list of applications
+
+    while (m_directoryDirs.count() > oldDirectoryDirsCount) {
+        m_directoryDirs.pop_front();
+    }
+
+    m_currentMenu = parentMenu;
+}
+
+static QString parseAttribute(const QDomElement &e)
+{
+    QString option;
+
+    const QString SHOW_EMPTY=QStringLiteral("show_empty");
+    if (e.hasAttribute(SHOW_EMPTY)) {
+        QString str = e.attribute(SHOW_EMPTY);
+        if (str == QLatin1String("true")) {
+            option = "ME ";
+        } else if (str == QLatin1String("false")) {
+            option = "NME ";
+        } else {
+            //qDebug()<<" Error in parsing show_empty attribute :"<<str;
+        }
+    }
+    const QString INLINE=QStringLiteral("inline");
+    if (e.hasAttribute(INLINE)) {
+        QString str = e.attribute(INLINE);
+        if (str == QLatin1String("true")) {
+            option += "I ";
+        } else if (str == QLatin1String("false")) {
+            option += "NI ";
+        } else {
+            qDebug() << " Error in parsing inline attribute :" << str;
+        }
+    }
+    if (e.hasAttribute(QStringLiteral("inline_limit"))) {
+        bool ok;
+        int value = e.attribute(QStringLiteral("inline_limit")).toInt(&ok);
+        if (ok) {
+            option += QStringLiteral("IL[%1] ").arg(value);
+        }
+    }
+    if (e.hasAttribute(QStringLiteral("inline_header"))) {
+        QString str = e.attribute(QStringLiteral("inline_header"));
+        if (str == QLatin1String("true")) {
+            option += QStringLiteral("IH ");
+        } else if (str == QLatin1String("false")) {
+            option += QStringLiteral("NIH ");
+        } else {
+            qDebug() << " Error in parsing of inline_header attribute :" << str;
+        }
+
+    }
+    if (e.hasAttribute("inline_alias") && e.attribute("inline_alias") == QLatin1String("true")) {
+        QString str = e.attribute("inline_alias");
+        if (str == QLatin1String("true")) {
+            option += "IA";
+        } else if (str == QLatin1String("false")) {
+            option += "NIA";
+        } else {
+            qDebug() << " Error in parsing inline_alias attribute :" << str;
+        }
+    }
+    if (!option.isEmpty()) {
+        option = option.prepend(QStringLiteral(":O"));
+    }
+    return option;
+
+}
+
+static QStringList parseLayoutNode(const QDomElement &docElem)
+{
+    QStringList layout;
+
+    QString optionDefaultLayout;
+    if (docElem.tagName() == QLatin1String("DefaultLayout")) {
+        optionDefaultLayout =  parseAttribute(docElem);
+    }
+    if (!optionDefaultLayout.isEmpty()) {
+        layout.append(optionDefaultLayout);
+    }
+
+    bool mergeTagExists = false;
+    QDomNode n = docElem.firstChild();
+    while (!n.isNull()) {
+        QDomElement e = n.toElement(); // try to convert the node to an element.
+        if (e.tagName() == QLatin1String("Separator")) {
+            layout.append(":S");
+        } else if (e.tagName() == QLatin1String("Filename")) {
+            layout.append(e.text());
+        } else if (e.tagName() == QLatin1String("Menuname")) {
+            layout.append('/' + e.text());
+            QString option = parseAttribute(e);
+            if (!option.isEmpty()) {
+                layout.append(option);
+            }
+        } else if (e.tagName() == QLatin1String("Merge")) {
+            QString type = e.attributeNode(QStringLiteral("type")).value();
+            if (type == QLatin1String("files")) {
+                layout.append(QStringLiteral(":F"));
+            } else if (type == QLatin1String("menus")) {
+                layout.append(QStringLiteral(":M"));
+            } else if (type == QLatin1String("all")) {
+                layout.append(QStringLiteral(":A"));
+            }
+            mergeTagExists = true;
+        }
+
+        n = n.nextSibling();
+    }
+
+    if (!mergeTagExists) {
+        layout.append(QStringLiteral(":M"));
+        layout.append(QStringLiteral(":F"));
+        qWarning() << "The menu spec file contains a Layout or DefaultLayout tag without the mandatory Merge tag inside. Please fix your file.";
+    }
+    return layout;
+}
+
+void
+VFolderMenu::layoutMenu(VFolderMenu::SubMenu *menu, QStringList defaultLayout) //krazy:exclude=passbyvalue
+{
+    if (!menu->defaultLayoutNode.isNull()) {
+        defaultLayout = parseLayoutNode(menu->defaultLayoutNode);
+    }
+
+    if (menu->layoutNode.isNull()) {
+        menu->layoutList = defaultLayout;
+    } else {
+        menu->layoutList = parseLayoutNode(menu->layoutNode);
+        if (menu->layoutList.isEmpty()) {
+            menu->layoutList = defaultLayout;
+        }
+    }
+
+    foreach (VFolderMenu::SubMenu *subMenu, menu->subMenus) {
+        layoutMenu(subMenu, defaultLayout);
+    }
+}
+
+void
+VFolderMenu::markUsedApplications(const QHash<QString, KService::Ptr> &items)
+{
+    foreach (const KService::Ptr &p, items) {
+        m_usedAppsDict.insert(p->menuId());
+    }
+}
+
+VFolderMenu::SubMenu *VFolderMenu::parseMenu(const QString &file)
+{
+    m_appsInfo = 0;
+
+    const QStringList dirs = QStandardPaths::locateAll(QStandardPaths::GenericConfigLocation, QLatin1String("menus"), QStandardPaths::LocateDirectory);
+    for (QStringList::ConstIterator it = dirs.begin();
+            it != dirs.end(); ++it) {
+        registerDirectory(*it);
+    }
+
+    loadMenu(file);
+
+    delete m_rootMenu;
+    m_rootMenu = m_currentMenu = 0;
+
+    QDomElement docElem = m_doc.documentElement();
+
+    for (int pass = 0; pass <= 2; pass++) {
+        // pass 0: load application desktop files
+        // pass 1: the normal processing
+        // pass 2: process <OnlyUnallocated> to put unused files into "Lost & Found".
+        processMenu(docElem, pass);
+
+        switch (pass) {
+        case 0:
+            // Fill the dictCategories for each AppsInfo in m_appsInfoList,
+            // in preparation for processMenu pass 1.
+            buildApplicationIndex(false);
+            break;
+        case 1:
+            // Fill the dictCategories for each AppsInfo in m_appsInfoList,
+            // with only the unused apps, in preparation for processMenu pass 2.
+            buildApplicationIndex(true /* unusedOnly */);
+            break;
+        case 2: {
+            QStringList defaultLayout;
+            defaultLayout << QStringLiteral(":M"); // Sub-Menus
+            defaultLayout << QStringLiteral(":F"); // Individual entries
+            layoutMenu(m_rootMenu, defaultLayout);
+            break;
+        }
+        default:
+            break;
+        }
+    }
+
+    return m_rootMenu;
+}
+
+void
+VFolderMenu::setTrackId(const QString &id)
+{
+    m_track = !id.isEmpty();
+    m_trackId = id;
+}
+
diff --git a/src/sycoca/vfolder_menu_p.h b/src/sycoca/vfolder_menu_p.h
new file mode 100644
index 0000000..b90f5ef
--- /dev/null
+++ b/src/sycoca/vfolder_menu_p.h
@@ -0,0 +1,279 @@
+/*
+   This file is part of the KDE libraries
+   Copyright (c) 2003 Waldo Bastian <bastian@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef VFOLDER_MENU_H
+#define VFOLDER_MENU_H
+
+#include <QtCore/QObject>
+#include <QtXml/QDomDocument>
+#include <QtCore/QStringList>
+#include <QtCore/QHash>
+#include <QtCore/QSet>
+#include <QtCore/QStack>
+
+#include <kservice.h>
+
+class KBuildSycocaInterface;
+class KBuildServiceFactory;
+
+class VFolderMenu : public QObject
+{
+    Q_OBJECT
+public:
+    class AppsInfo;
+    class SubMenu
+    {
+    public:
+        SubMenu() : isDeleted(false), apps_info(0)
+        {
+            items.reserve(43);
+        }
+        ~SubMenu()
+        {
+            qDeleteAll(subMenus);
+        }
+
+    public:
+        QString name;
+        QString directoryFile;
+        QList<SubMenu *> subMenus;
+        QHash<QString, KService::Ptr> items;
+        QHash<QString, KService::Ptr> excludeItems; // Needed when merging due to Move.
+        QDomElement defaultLayoutNode;
+        QDomElement layoutNode;
+        bool isDeleted;
+        QStringList layoutList;
+        AppsInfo *apps_info;
+    };
+
+    VFolderMenu(KBuildServiceFactory *serviceFactory, KBuildSycocaInterface *kbuildsycocaInterface);
+    ~VFolderMenu();
+
+    /**
+     * Parses VFolder menu definition and generates a menu layout.
+     * The newService signals is used as callback to load
+     * a specific service description.
+     *
+     * @param file Menu file to load
+     */
+    SubMenu *parseMenu(const QString &file);
+
+    /**
+     * Returns a list of all directories involved in the last call to
+     * parseMenu().
+     *
+     * A change in any of these directories or in any of their child-
+     * directories can result in changes to the menu.
+     */
+    QStringList allDirectories();
+
+    /**
+     * Debug function to enable tracking of what happens with a specific
+     * menu item id
+     */
+    void setTrackId(const QString &id);
+
+public:
+    struct MenuItem {
+        enum Type { MI_Service, MI_SubMenu, MI_Separator };
+        Type type;
+        KService::Ptr service;
+        SubMenu  *submenu;
+    };
+
+public:
+    QStringList m_allDirectories; // A list of all the directories that we touch
+
+    QStringList m_defaultAppDirs;
+    QStringList m_defaultDirectoryDirs;
+    QStringList m_defaultMergeDirs;
+
+    QStringList m_directoryDirs; // Current set of applicable <DirectoryDir> dirs
+    QHash<QString, SubMenu *> m_legacyNodes; // Dictionary that stores Menu nodes
+    // associated with legacy tree.
+
+    class DocInfo
+    {
+    public:
+        QString baseDir; // Relative base dir of current menu file
+        QString baseName; // Filename of current menu file without ".menu"
+        QString path; // Full path of current menu file including ".menu"
+    };
+
+    DocInfo m_docInfo; // DocInfo for current doc
+    QStack<VFolderMenu::DocInfo> m_docInfoStack;
+
+    class AppsInfo
+    {
+    public:
+        AppsInfo()
+        {
+            dictCategories.reserve(53);
+            applications.reserve(997);
+            appRelPaths.reserve(997);
+        }
+
+        ~AppsInfo()
+        {
+        }
+
+        QHash<QString, KService::List> dictCategories; // category -> apps
+        QHash<QString, KService::Ptr> applications; // rel path -> service
+        QHash<KService::Ptr, QString> appRelPaths; // service -> rel path
+    };
+
+    AppsInfo *m_appsInfo; // AppsInfo for current menu
+    QList<AppsInfo *> m_appsInfoStack; // All applicable AppsInfo for current menu
+    QList<AppsInfo *> m_appsInfoList; // List of all AppsInfo objects.
+    QSet<QString /*menuId*/> m_usedAppsDict; // all applications that have been allocated
+
+    QDomDocument m_doc;
+    SubMenu *m_rootMenu;
+    SubMenu *m_currentMenu;
+    bool m_track;
+    QString m_trackId;
+
+private:
+    /**
+     * Lookup application by relative path
+     */
+    KService::Ptr findApplication(const QString &relPath);
+
+    /**
+     * Lookup applications by category
+     */
+    QList<KService::List *> findCategory(const QString &category);
+
+    /**
+     * Add new application
+     */
+    void addApplication(const QString &id, KService::Ptr service);
+
+    /**
+     * Build application indices
+     */
+    void buildApplicationIndex(bool unusedOnly);
+
+    /**
+     * Create a AppsInfo frame for current menu
+     */
+    void createAppsInfo();
+
+    /**
+     * Load additional AppsInfo frame for current menu
+     */
+    void loadAppsInfo();
+
+    /**
+     * Unload additional AppsInfo frame for current menu
+     */
+    void unloadAppsInfo();
+
+    QDomDocument loadDoc();
+    void mergeMenus(QDomElement &docElem, QString &name);
+    void mergeFile(QDomElement &docElem, const QDomNode &mergeHere);
+    void loadMenu(const QString &filename);
+
+    /**
+     * Merge the items2 set into the items1 set
+     */
+    void includeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
+
+    /**
+     * Remove all items from the items1 set that aren't also in the items2 set
+     */
+    void matchItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
+
+    /**
+     * Remove all items in the items2 set from the items1 set
+     */
+    void excludeItems(QHash<QString, KService::Ptr> &items1, const QHash<QString, KService::Ptr> &items2);
+
+    /**
+     * Search the parentMenu tree for the menu menuName and takes it
+     * out.
+     *
+     * This function returns a pointer to the menu if it was found
+     * or 0 if it was not found.
+     */
+    SubMenu *takeSubMenu(SubMenu *parentMenu, const QString &menuName);
+
+    /**
+     * Insert the menu newMenu with name menuName into the parentMenu.
+     * If such menu already exist the result is merged, if any additional
+     * submenus are required they are created.
+     * If reversePriority is false, newMenu has priority over the existing
+     * menu during merging.
+     * If reversePriority is true, the existing menu has priority over newMenu
+     * during merging.
+     */
+    void insertSubMenu(VFolderMenu::SubMenu *parentMenu, const QString &menuName, VFolderMenu::SubMenu *newMenu, bool reversePriority = false);
+
+    /**
+     * Merge menu2 and its submenus into menu1 and its submenus
+     * If reversePriority is false, menu2 has priority over menu1
+     * If reversePriority is true, menu1 has priority over menu2
+     */
+    void mergeMenu(SubMenu *menu1, SubMenu *menu2, bool reversePriority = false);
+
+    /**
+     * Inserts service into the menu using name relative to parentMenu
+     * Any missing sub-menus are created.
+     */
+    void insertService(SubMenu *parentMenu, const QString &name, KService::Ptr newService);
+
+    /**
+     * Register the directory that @p file is in.
+     * @see allDirectories()
+     */
+    void registerFile(const QString &file);
+
+    /**
+     * Fill m_usedAppsDict with all applications from @p items
+     */
+    void markUsedApplications(const QHash<QString, KService::Ptr> &items);
+
+    /**
+     * Register @p directory
+     * @see allDirectories()
+     */
+    void registerDirectory(const QString &directory);
+
+    void processLegacyDir(const QString &dir, const QString &relDir, const QString &prefix);
+    void processMenu(QDomElement &docElem, int pass);
+    void layoutMenu(VFolderMenu::SubMenu *menu, QStringList defaultLayout);
+    void processCondition(QDomElement &docElem, QHash<QString, KService::Ptr> &items);
+
+    void initDirs();
+
+    void pushDocInfo(const QString &fileName, const QString &baseDir = QString());
+    void pushDocInfoParent(const QString &basePath, const QString &baseDir);
+    void popDocInfo();
+
+    QString absoluteDir(const QString &_dir, const QString &baseDir, bool keepRelativeToCfg = false);
+    QString locateMenuFile(const QString &fileName);
+    QString locateDirectoryFile(const QString &fileName);
+    void loadApplications(const QString &, const QString &);
+
+private:
+    KBuildServiceFactory *m_serviceFactory;
+    KBuildSycocaInterface *m_kbuildsycocaInterface;
+};
+
+#endif
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 1d59e27..53f7e0c 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -18,6 +18,6 @@ endmacro()
 kservice_executable_tests(
   startserviceby
   kdbusservicestartertest
-  ksycocatest
+  kservicegroup_dumper
   findservice
 )
diff --git a/tests/kservicegroup_dumper.cpp b/tests/kservicegroup_dumper.cpp
new file mode 100644
index 0000000..1872b12
--- /dev/null
+++ b/tests/kservicegroup_dumper.cpp
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (C) 2002-2006 David Faure   <faure@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License version 2 as published by the Free Software Foundation;
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include <QCoreApplication>
+#include <QDebug>
+#include <kservice.h>
+#include <kservicegroup.h>
+
+int main(int argc, char *argv[])
+{
+    QCoreApplication k(argc, argv);
+
+    KServiceGroup::Ptr root = KServiceGroup::root();
+    KServiceGroup::List list = root->entries();
+
+    KServiceGroup::Ptr first;
+
+    qDebug("Found %d entries", list.count());
+    for (KServiceGroup::List::ConstIterator it = list.constBegin();
+            it != list.constEnd(); ++it) {
+        KSycocaEntry::Ptr p = (*it);
+        if (p->isType(KST_KService)) {
+            KService::Ptr service(static_cast<KService*>(p.data()));
+            qDebug("%s", qPrintable(service->name()));
+            qDebug("%s", qPrintable(service->entryPath()));
+        } else if (p->isType(KST_KServiceGroup)) {
+            KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(p.data()));
+            qDebug("             %s -->", qPrintable(serviceGroup->caption()));
+            if (!first) {
+                first = serviceGroup;
+            }
+        } else {
+            qDebug("KServiceGroup: Unexpected object in list!");
+        }
+    }
+
+    if (first) {
+        list = first->entries();
+        qDebug("Found %d entries", list.count());
+        for (KServiceGroup::List::ConstIterator it = list.constBegin();
+                it != list.constEnd(); ++it) {
+            KSycocaEntry::Ptr p = (*it);
+            if (p->isType(KST_KService)) {
+                KService::Ptr service(static_cast<KService*>(p.data()));
+                qDebug("             %s", qPrintable(service->name()));
+            } else if (p->isType(KST_KServiceGroup)) {
+                KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(p.data()));
+                qDebug("             %s -->", qPrintable(serviceGroup->caption()));
+            } else {
+                qDebug("KServiceGroup: Unexpected object in list!");
+            }
+        }
+    }
+
+    return 0;
+}
diff --git a/tests/ksycocatest.cpp b/tests/ksycocatest.cpp
deleted file mode 100644
index fa9e4bc..0000000
--- a/tests/ksycocatest.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- *  Copyright (C) 2002-2006 David Faure   <faure@kde.org>
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License version 2 as published by the Free Software Foundation;
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- */
-
-#include <QCoreApplication>
-#include <QDebug>
-#include <kservice.h>
-#include <kservicegroup.h>
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-// ############
-// Some of the tests here (those that don't depend on other modules being installed)
-// should be moved to kmimetypetest, and then kmimetypetest can be renamed ksycocatest.
-//
-// But it's still convenient to have an interactive test program, for checking things
-// in the user's ksycoca instead of checking them in the safe .kde-unit-test one.
-//
-int main(int argc, char *argv[])
-{
-    QCoreApplication::setApplicationName("ksycocatest");
-    QCoreApplication k(argc, argv);
-
-    QString instname = "kword";
-    QString desktopPath = QString::fromLatin1("Office/%1.desktop").arg(instname);
-    qDebug("Looking for %s", desktopPath.toLatin1().constData());
-    KService::Ptr service = KService::serviceByDesktopPath(desktopPath);
-    if (service) {
-        qDebug("found: %s", service->entryPath().toLatin1().constData());
-    } else {
-        qDebug("not found");
-    }
-
-    qDebug("Looking for desktop name = %s", instname.toLatin1().constData());
-    service = KService::serviceByDesktopName(instname);
-    if (service) {
-        qDebug("found: %s", service->entryPath().toLatin1().constData());
-    } else {
-        qDebug("not found");
-    }
-
-    KService::Ptr se;
-
-    qDebug("Trying to look for kpager");
-    se = KService::serviceByDesktopName("kpager");
-    if (se) {
-        qDebug("Found it !");
-        qDebug("Comment is %s", qPrintable(se->comment()));
-        QVariant qv = se->property("X-DocPath");
-        qDebug("Property type is %s", qv.typeName());
-        qDebug("Property value is %s", qPrintable(qv.toString()));
-    } else {
-        qDebug("Not found !");
-    }
-
-    qDebug("Trying to look for System/kpager.desktop");
-    se = KService::serviceByDesktopPath("System/kpager.desktop");
-    if (se) {
-        qDebug("Found it !");
-        qDebug("Comment is %s", qPrintable(se->comment()));
-    } else {
-        qDebug("Not found !");
-    }
-
-    qDebug("Trying to look for System/fake-entry.desktop");
-    se = KService::serviceByDesktopPath("System/fake-entry.desktop");
-    if (se) {
-        qDebug("Found it !");
-        qDebug("Comment is %s", qPrintable(se->comment()));
-    } else {
-        qDebug("Not found !");
-    }
-
-#if 1
-    KServiceGroup::Ptr root = KServiceGroup::root();
-    KServiceGroup::List list = root->entries();
-    //KServiceGroup::Ptr topGroup = KServiceGroup::childGroup( "kview" );
-    //Q_ASSERT( topGroup );
-    //KServiceGroup::List list = topGroup->entries();
-
-    KServiceGroup::Ptr first;
-
-    qDebug("Found %d entries", list.count());
-    for (KServiceGroup::List::ConstIterator it = list.constBegin();
-            it != list.constEnd(); ++it) {
-        KSycocaEntry::Ptr p = (*it);
-        if (p->isType(KST_KService)) {
-            KService::Ptr service(static_cast<KService*>(p.data()));
-            qDebug("%s", qPrintable(service->name()));
-            qDebug("%s", qPrintable(service->entryPath()));
-        } else if (p->isType(KST_KServiceGroup)) {
-            KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(p.data()));
-            qDebug("             %s -->", qPrintable(serviceGroup->caption()));
-            if (!first) {
-                first = serviceGroup;
-            }
-        } else {
-            qDebug("KServiceGroup: Unexpected object in list!");
-        }
-    }
-
-    if (first) {
-        list = first->entries();
-        qDebug("Found %d entries", list.count());
-        for (KServiceGroup::List::ConstIterator it = list.constBegin();
-                it != list.constEnd(); ++it) {
-            KSycocaEntry::Ptr p = (*it);
-            if (p->isType(KST_KService)) {
-                KService::Ptr service(static_cast<KService*>(p.data()));
-                qDebug("             %s", qPrintable(service->name()));
-            } else if (p->isType(KST_KServiceGroup)) {
-                KServiceGroup::Ptr serviceGroup(static_cast<KServiceGroup*>(p.data()));
-                qDebug("             %s -->", qPrintable(serviceGroup->caption()));
-            } else {
-                qDebug("KServiceGroup: Unexpected object in list!");
-            }
-        }
-    }
-#endif
-    return 0;
-}
