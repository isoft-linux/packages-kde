diff -Nur kitemmodels-5.16.0/autotests/CMakeLists.txt kitemmodels-5.17.0/autotests/CMakeLists.txt
--- kitemmodels-5.16.0/autotests/CMakeLists.txt	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/CMakeLists.txt	2015-12-06 22:07:13.000000000 +0800
@@ -32,4 +32,3 @@
   LINK_LIBRARIES KF5::ItemModels Qt5::Test Qt5::Widgets proxymodeltestsuite
 )
 
-add_subdirectory(proxymodeltestapp)
diff -Nur kitemmodels-5.16.0/autotests/kselectionproxymodeltest.cpp kitemmodels-5.17.0/autotests/kselectionproxymodeltest.cpp
--- kitemmodels-5.16.0/autotests/kselectionproxymodeltest.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/kselectionproxymodeltest.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -1,37 +1,87 @@
+/*
+    Copyright (c) 2015 Stephen Kelly <steveire@gmail.com>
+    Copyright (c) 2015 David Faure <faure@kde.org>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
 
 #include <QTest>
 #include <QStringListModel>
 #include <QIdentityProxyModel>
 #include <QSignalSpy>
-
 #include <kselectionproxymodel.h>
 
+#include "test_model_helpers.h"
+using namespace TestModelHelpers;
+
 class KSelectionProxyModelTest : public QObject
 {
   Q_OBJECT
 public:
   KSelectionProxyModelTest(QObject* parent = 0)
-    : QObject(parent)
+    : QObject(parent),
+      days({
+          QStringLiteral("Monday"),
+          QStringLiteral("Tuesday"),
+          QStringLiteral("Wednesday"),
+          QStringLiteral("Thursday")
+      })
   {
-
   }
 
 private Q_SLOTS:
+  void columnCountShouldBeStable();
   void selectOnSourceReset();
 
 #if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)
   void selectionModelModelChange();
 #endif
+
+private:
+  const QStringList days;
 };
 
+void KSelectionProxyModelTest::columnCountShouldBeStable()
+{
+    // Given a KSelectionProxy on top of a stringlist model
+    QStringListModel strings(days);
+    QItemSelectionModel selectionModel(&strings);
+    KSelectionProxyModel proxy(&selectionModel);
+    proxy.setSourceModel(&strings);
+
+    QSignalSpy rowATBISpy(&proxy, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)));
+    QSignalSpy rowInsertedSpy(&proxy, SIGNAL(rowsInserted(QModelIndex,int,int)));
+
+    // No selection => the proxy should have 0 rows, 1 column
+    // (if it had 0 columns, it would have to emit column insertions, too much trouble)
+    QCOMPARE(proxy.rowCount(), 0);
+    QCOMPARE(proxy.columnCount(), 1);
+    QCOMPARE(rowATBISpy.count(), 0);
+    QCOMPARE(rowInsertedSpy.count(), 0);
+
+    // Select second entry -> the proxy should have 1 rows, 1 column
+    selectionModel.select(QItemSelection(strings.index(1, 0), strings.index(1, 0)), QItemSelectionModel::Select);
+    QCOMPARE(proxy.rowCount(), 1);
+    QCOMPARE(proxy.columnCount(), 1);
+    QCOMPARE(rowSpyToText(rowATBISpy), QString("0,0"));
+    QCOMPARE(rowSpyToText(rowInsertedSpy), QString("0,0"));
+}
+
 void KSelectionProxyModelTest::selectOnSourceReset()
 {
-  QStringList days = {
-    QStringLiteral("Monday"),
-    QStringLiteral("Tuesday"),
-    QStringLiteral("Wednesday"),
-    QStringLiteral("Thursday")
-  };
   QStringListModel strings(days);
   QItemSelectionModel selectionModel(&strings);
 
@@ -65,12 +115,7 @@
 #if QT_VERSION >= QT_VERSION_CHECK(5, 5, 0)
 void KSelectionProxyModelTest::selectionModelModelChange()
 {
-  QStringListModel strings({
-    QStringLiteral("Monday"),
-    QStringLiteral("Tuesday"),
-    QStringLiteral("Wednesday"),
-    QStringLiteral("Thursday")
-  });
+  QStringListModel strings(days);
   QItemSelectionModel selectionModel(&strings);
 
   QIdentityProxyModel identity;
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,107 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "breadcrumbdirectionwidget.h"
-
-#include <dynamictreemodel.h>
-#include <kbreadcrumbselectionmodel.h>
-#include <QBoxLayout>
-#include <QSplitter>
-#include <QTreeView>
-#include <QEvent>
-
-BreadcrumbDirectionWidget::BreadcrumbDirectionWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-
-    ModelInsertCommand ins(rootModel);
-    ins.setStartRow(0);
-    ins.interpret(
-        QStringLiteral("- 1"
-        "- 2"
-        "- - 3"
-        "- - 3"
-        "- - - 4"
-        "- - - 4"
-        "- - - - 4"
-        "- - 4"
-        "- - 5"
-        "- - - 4"
-        "- - - - 4"
-        "- - 5"
-        "- 6"
-        "- 7"
-        "- - 8"
-        "- - - 9"
-        "- - - 10"
-        "- - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - - - - 9"
-        "- - - - - - - - 10"
-        "- - - - - - - - 9"
-        "- - - - - - - 10"
-        "- 20"
-        "- 21"));
-    ins.doCommand();
-
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *splitter1 = new QSplitter(Qt::Vertical, this);
-    layout->addWidget(splitter1);
-    QSplitter *splitter2 = new QSplitter(splitter1);
-    QSplitter *splitter3 = new QSplitter(splitter1);
-
-    QTreeView *view1 = new QTreeView(splitter2);
-    view1->setModel(rootModel);
-    view1->expandAll();
-    view1->viewport()->setBackgroundRole(QPalette::Button);
-    QTreeView *view2 = new QTreeView(splitter2);
-    view2->setModel(rootModel);
-    view2->expandAll();
-    view2->viewport()->installEventFilter(this);
-    QTreeView *view3 = new QTreeView(splitter3);
-    view3->setModel(rootModel);
-    view3->expandAll();
-    QTreeView *view4 = new QTreeView(splitter3);
-    view4->setModel(rootModel);
-    view4->expandAll();
-    view4->viewport()->installEventFilter(this);
-    view4->viewport()->setBackgroundRole(QPalette::Button);
-
-    KBreadcrumbSelectionModel *breadcrumbSelection1 = new KBreadcrumbSelectionModel(view2->selectionModel(), this);
-    view1->setSelectionModel(breadcrumbSelection1);
-
-    KBreadcrumbSelectionModel *breadcrumbSelection2 = new KBreadcrumbSelectionModel(view3->selectionModel(),
-            KBreadcrumbSelectionModel::MakeBreadcrumbSelectionInOther, this);
-    view4->setSelectionModel(breadcrumbSelection2);
-}
-
-bool BreadcrumbDirectionWidget::eventFilter(QObject *o, QEvent *e)
-{
-    if (e->type() == QEvent::MouseButtonPress || e->type() == QEvent::MouseButtonDblClick || e->type() == QEvent::MouseButtonRelease) {
-        return true;
-    }
-    return QObject::eventFilter(o, e);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbdirectionwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef BREADCRUMBDIRECTIONWIDGET_H
-#define BREADCRUMBDIRECTIONWIDGET_H
-
-#include <QWidget>
-
-class BreadcrumbDirectionWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    BreadcrumbDirectionWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-protected:
-    virtual bool eventFilter(QObject *, QEvent *);
-
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,289 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "breadcrumbnavigationwidget.h"
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-
-#include <QSplitter>
-#include <QListView>
-#include <QTreeView>
-#include <QBoxLayout>
-
-#include "kselectionproxymodel.h"
-#include "kbreadcrumbselectionmodel.h"
-
-#define SON(object) object->setObjectName(#object)
-
-CurrentItemLabel::CurrentItemLabel(QAbstractItemModel *model, QWidget *parent, Qt::WindowFlags f)
-    : QLabel(parent, f), m_model(model)
-{
-    connect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), SLOT(dataChanged(QModelIndex,QModelIndex)));
-    connect(model, SIGNAL(rowsInserted(QModelIndex,int,int)), SLOT(rowsInserted(QModelIndex,int,int)));
-    connect(model, SIGNAL(rowsRemoved(QModelIndex,int,int)), SLOT(rowsRemoved(QModelIndex,int,int)));
-    connect(model, SIGNAL(modelReset()), SLOT(modelReset()));
-
-    if (!m_model->hasChildren()) {
-        setText(QStringLiteral("No selection"));
-    }
-}
-
-void CurrentItemLabel::dataChanged(const QModelIndex &, const QModelIndex &)
-{
-    setText(m_model->index(0, 0).data().toString());
-}
-
-void CurrentItemLabel::rowsInserted(const QModelIndex &, int, int)
-{
-    setText(m_model->index(0, 0).data().toString());
-}
-
-void CurrentItemLabel::rowsRemoved(const QModelIndex &, int, int)
-{
-    if (!m_model->hasChildren()) {
-        setText(QStringLiteral("No selection"));
-        return;
-    }
-    setText(m_model->index(0, 0).data().toString());
-}
-
-void CurrentItemLabel::modelReset()
-{
-    if (!m_model->hasChildren()) {
-        setText(QStringLiteral("No selection"));
-    }
-    setText(m_model->index(0, 0).data().toString());
-}
-
-KBreadcrumbNavigationProxyModel::KBreadcrumbNavigationProxyModel(QItemSelectionModel *selectionModel, QObject *parent)
-    : KSelectionProxyModel(selectionModel, parent)
-{
-
-}
-
-QVariant KBreadcrumbNavigationProxyModel::data(const QModelIndex &index, int role) const
-{
-    if (rowCount() > 2 && index.row() == 0 && role == Qt::DisplayRole) {
-        QModelIndex sourceIndex = mapToSource(index);
-        QStringList dataList;
-        while (sourceIndex.isValid()) {
-            dataList.prepend(sourceIndex.data().toString());
-            sourceIndex = sourceIndex.parent();
-        }
-        return dataList.join(QStringLiteral(" > "));
-    }
-    return KSelectionProxyModel::data(index, role);
-}
-
-void KBreadcrumbNavigationProxyModel::setShowHiddenAscendantData(bool showHiddenAscendantData)
-{
-    m_showHiddenAscendantData = showHiddenAscendantData;
-}
-
-bool KBreadcrumbNavigationProxyModel::showHiddenAscendantData() const
-{
-    return m_showHiddenAscendantData;
-}
-
-KNavigatingProxyModel::KNavigatingProxyModel(QItemSelectionModel *selectionModel, QObject *parent)
-    : KSelectionProxyModel(selectionModel, parent), m_selectionModel(selectionModel)
-{
-
-}
-
-void KNavigatingProxyModel::setSourceModel(QAbstractItemModel *sourceModel)
-{
-    connect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-            SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
-
-    KSelectionProxyModel::setSourceModel(sourceModel);
-    updateNavigation();
-}
-
-void KNavigatingProxyModel::navigationSelectionChanged(const QItemSelection &, const QItemSelection &)
-{
-    updateNavigation();
-}
-
-void KNavigatingProxyModel::updateNavigation()
-{
-    if (!sourceModel()) {
-        return;
-    }
-
-    if (m_selectionModel->selection().isEmpty()) {
-        setFilterBehavior(KSelectionProxyModel::ExactSelection);
-        QModelIndex top = sourceModel()->index(0, 0);
-        QModelIndex bottom = sourceModel()->index(sourceModel()->rowCount() - 1, 0);
-
-        disconnect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-                   this, SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
-        m_selectionModel->select(QItemSelection(top, bottom), QItemSelectionModel::Select);
-        connect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-                SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
-    } else if (filterBehavior() != KSelectionProxyModel::ChildrenOfExactSelection) {
-        setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
-    }
-}
-
-void KNavigatingProxyModel::modelReset()
-{
-    updateNavigation();
-}
-
-QVariant KNavigatingProxyModel::data(const QModelIndex &index, int role) const
-{
-    if (role == Qt::DisplayRole && sourceModel()->hasChildren(mapToSource(index))) {
-        return QString("+ " + KSelectionProxyModel::data(index, role).toString());
-    }
-    return KSelectionProxyModel::data(index, role);
-}
-
-KForwardingItemSelectionModel::KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, QObject *parent)
-    : QItemSelectionModel(model, parent), m_selectionModel(selectionModel), m_direction(Forward)
-{
-    Q_ASSERT(model == selectionModel->model());
-    connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-            SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
-}
-
-KForwardingItemSelectionModel::KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, Direction direction, QObject *parent)
-    : QItemSelectionModel(model, parent), m_selectionModel(selectionModel), m_direction(direction)
-{
-    Q_ASSERT(model == selectionModel->model());
-    if (m_direction == Forward)
-        connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
-                SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
-}
-
-void KForwardingItemSelectionModel::select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
-{
-    if (m_direction == Reverse) {
-        m_selectionModel->select(index, command);
-    } else {
-        QItemSelectionModel::select(index, command);
-    }
-}
-
-void KForwardingItemSelectionModel::select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command)
-{
-    if (m_direction == Reverse) {
-        m_selectionModel->select(selection, command);
-    } else {
-        QItemSelectionModel::select(selection, command);
-    }
-}
-
-void KForwardingItemSelectionModel::navigationSelectionChanged(const QItemSelection &selected, const QItemSelection &)
-{
-    select(selected, ClearAndSelect);
-}
-
-BreadcrumbNavigationWidget::BreadcrumbNavigationWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-    QSplitter *splitter = new QSplitter(this);
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    layout->addWidget(splitter);
-
-    DynamicTreeWidget *dynamicTree = new DynamicTreeWidget(rootModel, splitter);
-    dynamicTree->treeView()->setSelectionMode(QAbstractItemView::SingleSelection);
-    dynamicTree->setInitialTree(
-        QStringLiteral("- 1"
-        "- - 2"
-        "- - 2"
-        "- - - 3"
-        "- - - - 4"
-        "- - - - - 5"
-        "- - 2"
-        "- 6"
-        "- 6"
-        "- 6"
-        "- - 7"
-        "- - - 8"
-        "- - - 8"
-        "- - - - 9"
-        "- - - - - 10"
-        "- - - 8"
-        "- - - 8"
-        "- - 8"
-        "- 16"
-        "- - 17"
-        "- - - 18"
-        "- - - - 19"
-        "- - - - - 20"));
-
-    QList<QItemSelectionModel *> selectionModelList;
-
-    QSplitter *vSplitter = new QSplitter(Qt::Vertical, splitter);
-
-    QItemSelectionModel *rootSelectionModel = new QItemSelectionModel(rootModel, this);
-    SON(rootSelectionModel);
-
-    dynamicTree->treeView()->setSelectionModel(rootSelectionModel);
-
-    KBreadcrumbSelectionModel *breadcrumbOnlyProxySelector2 = new KBreadcrumbSelectionModel(rootSelectionModel, KBreadcrumbSelectionModel::MakeBreadcrumbSelectionInOther, this);
-    SON(breadcrumbOnlyProxySelector2);
-    breadcrumbOnlyProxySelector2->setActualSelectionIncluded(false);
-
-    KBreadcrumbNavigationProxyModel *breadcrumbNavigationModel = new KBreadcrumbNavigationProxyModel(breadcrumbOnlyProxySelector2, this);
-    SON(breadcrumbNavigationModel);
-    breadcrumbNavigationModel->setSourceModel(rootModel);
-    breadcrumbNavigationModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QListView *breadcrumbView = new QListView(vSplitter);
-//   SON(breadcrumbNavigationModel);
-    breadcrumbView->setModel(breadcrumbNavigationModel);
-
-    // This shouldn't operate on rootSelectionModel. It should operate on oneway instead?
-    KLinkItemSelectionModel *breadcrumbViewSelectionModel = new KLinkItemSelectionModel(breadcrumbNavigationModel, rootSelectionModel, this);
-    SON(breadcrumbViewSelectionModel);
-
-    KForwardingItemSelectionModel *oneway2 = new KForwardingItemSelectionModel(breadcrumbNavigationModel, breadcrumbViewSelectionModel, KForwardingItemSelectionModel::Reverse);
-    SON(oneway2);
-
-    breadcrumbView->setSelectionModel(oneway2);
-
-    KSelectionProxyModel *currentItemSelectionModel = new KSelectionProxyModel(rootSelectionModel, this);
-    currentItemSelectionModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-    currentItemSelectionModel->setSourceModel(rootModel);
-    SON(currentItemSelectionModel);
-
-    new CurrentItemLabel(currentItemSelectionModel, vSplitter);
-
-    QListView *selectionView = new QListView(vSplitter);
-
-    // Need a one-way connection from rootSelectionModel to rootSelectionModel2
-
-    KForwardingItemSelectionModel *oneway = new KForwardingItemSelectionModel(rootModel, rootSelectionModel);
-
-    KNavigatingProxyModel *navigatingProxyModel = new KNavigatingProxyModel(oneway, this);
-    SON(navigatingProxyModel);
-    navigatingProxyModel->setSourceModel(rootModel);
-    selectionView->setModel(navigatingProxyModel);
-
-    KLinkItemSelectionModel *selectedChildrenSelectionModel = new KLinkItemSelectionModel(navigatingProxyModel, rootSelectionModel, this);
-
-    selectionView->setSelectionModel(selectedChildrenSelectionModel);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbnavigationwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,120 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef BREADCRUMBNAVIGATION_WIDGET_H
-#define BREADCRUMBNAVIGATION_WIDGET_H
-
-#include <QWidget>
-#include <QItemSelection>
-#include <QLabel>
-#include <QListView>
-#include <kselectionproxymodel.h>
-
-#include "klinkitemselectionmodel.h"
-
-class CurrentItemLabel : public QLabel
-{
-    Q_OBJECT
-public:
-    CurrentItemLabel(QAbstractItemModel *model, QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-private Q_SLOTS:
-    void rowsInserted(const QModelIndex &parent, int start, int end);
-    void rowsRemoved(const QModelIndex &parent, int start, int end);
-    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
-    void modelReset();
-
-private:
-    QAbstractItemModel *m_model;
-};
-
-class KBreadcrumbNavigationProxyModel : public KSelectionProxyModel
-{
-    Q_OBJECT
-public:
-    KBreadcrumbNavigationProxyModel(QItemSelectionModel *selectionModel, QObject *parent = 0);
-
-    void setShowHiddenAscendantData(bool showHiddenAscendantData);
-    bool showHiddenAscendantData() const;
-
-    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
-
-private:
-    bool m_showHiddenAscendantData;
-
-};
-
-class KNavigatingProxyModel : public KSelectionProxyModel
-{
-    Q_OBJECT
-public:
-    KNavigatingProxyModel(QItemSelectionModel *selectionModel, QObject *parent = 0);
-
-    virtual void setSourceModel(QAbstractItemModel *sourceModel);
-
-    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
-
-private Q_SLOTS:
-    void modelReset();
-    void updateNavigation();
-    void navigationSelectionChanged(const QItemSelection &, const QItemSelection &);
-
-private:
-
-private:
-    using KSelectionProxyModel::setFilterBehavior;
-
-    QItemSelectionModel *m_selectionModel;
-
-};
-
-class KForwardingItemSelectionModel : public QItemSelectionModel
-{
-    Q_OBJECT
-public:
-    enum Direction {
-        Forward,
-        Reverse
-    };
-    KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, QObject *parent = 0);
-    KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, Direction direction, QObject *parent = 0);
-
-    virtual void select(const QModelIndex &index, SelectionFlags command);
-    virtual void select(const QItemSelection &selection, SelectionFlags command);
-
-private Q_SLOTS:
-    void navigationSelectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
-
-private:
-    QItemSelectionModel *m_selectionModel;
-    Direction m_direction;
-};
-
-class BreadcrumbNavigationWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    BreadcrumbNavigationWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbswidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbswidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbswidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbswidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,150 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "breadcrumbswidget.h"
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-
-#include <QSplitter>
-#include <QListView>
-#include <QTreeView>
-#include <QBoxLayout>
-
-#include "kselectionproxymodel.h"
-#include "kbreadcrumbselectionmodel.h"
-
-MultiSelectionModel::MultiSelectionModel(QAbstractItemModel *model, QList< QItemSelectionModel * > selectionModels, QObject *parent)
-    : QItemSelectionModel(model, parent), m_selectionModels(selectionModels)
-{
-
-}
-
-void MultiSelectionModel::select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
-{
-    Q_FOREACH (QItemSelectionModel *selectionModel, m_selectionModels) {
-        selectionModel->select(index, command);
-    }
-    QItemSelectionModel::select(index, command);
-}
-
-void MultiSelectionModel::select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command)
-{
-    Q_FOREACH (QItemSelectionModel *selectionModel, m_selectionModels) {
-        selectionModel->select(selection, command);
-    }
-    QItemSelectionModel::select(selection, command);
-}
-
-BreadcrumbsWidget::BreadcrumbsWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-    QSplitter *splitter = new QSplitter(this);
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    layout->addWidget(splitter);
-
-    DynamicTreeWidget *dynamicTree = new DynamicTreeWidget(rootModel, splitter);
-    dynamicTree->treeView()->setSelectionMode(QAbstractItemView::SingleSelection);
-    dynamicTree->setInitialTree(
-        QStringLiteral("- 1"
-        "- - 2"
-        "- - 2"
-        "- - - 3"
-        "- - - - 4"
-        "- - - - - 5"
-        "- - 2"
-        "- 6"
-        "- 6"
-        "- 6"
-        "- - 7"
-        "- - - 8"
-        "- - - 8"
-        "- - - - 9"
-        "- - - - - 10"
-        "- - - 8"
-        "- - - 8"
-        "- - 8"
-        "- 16"
-        "- - 17"
-        "- - - 18"
-        "- - - - 19"
-        "- - - - - 20"));
-
-    QList<QItemSelectionModel *> selectionModelList;
-    QItemSelectionModel *fullBreadcrumbSelectionModel = new QItemSelectionModel(rootModel, this);
-
-    KBreadcrumbSelectionModel *fullBreadcrumbProxySelector = new KBreadcrumbSelectionModel(fullBreadcrumbSelectionModel, this);
-    selectionModelList << fullBreadcrumbProxySelector;
-
-    KSelectionProxyModel *fullBreadCrumbSelectionProxyModel = new KSelectionProxyModel(fullBreadcrumbSelectionModel, this);
-    fullBreadCrumbSelectionProxyModel->setSourceModel(rootModel);
-    fullBreadCrumbSelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QListView *fullBreadcrumbProxyView = new QListView(splitter);
-    fullBreadcrumbProxyView->setModel(fullBreadCrumbSelectionProxyModel);
-
-    QItemSelectionModel *breadcrumbOnlySelectionModel = new QItemSelectionModel(rootModel, this);
-
-    KBreadcrumbSelectionModel *breadcrumbOnlyProxySelector = new KBreadcrumbSelectionModel(breadcrumbOnlySelectionModel, this);
-    breadcrumbOnlyProxySelector->setActualSelectionIncluded(false);
-    selectionModelList << breadcrumbOnlyProxySelector;
-
-    KSelectionProxyModel *breadcrumbOnlySelectionProxyModel = new KSelectionProxyModel(breadcrumbOnlySelectionModel, this);
-    breadcrumbOnlySelectionProxyModel->setSourceModel(rootModel);
-    breadcrumbOnlySelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QListView *breadcrumbOnlyProxyView = new QListView(splitter);
-    breadcrumbOnlyProxyView->setModel(breadcrumbOnlySelectionProxyModel);
-
-    int selectionDepth = 2;
-
-    QItemSelectionModel *thisAndAscendantsSelectionModel = new QItemSelectionModel(rootModel, this);
-
-    KBreadcrumbSelectionModel *thisAndAscendantsProxySelector = new KBreadcrumbSelectionModel(thisAndAscendantsSelectionModel, this);
-    thisAndAscendantsProxySelector->setBreadcrumbLength(selectionDepth);
-    selectionModelList << thisAndAscendantsProxySelector;
-
-    KSelectionProxyModel *thisAndAscendantsSelectionProxyModel = new KSelectionProxyModel(thisAndAscendantsSelectionModel, this);
-    thisAndAscendantsSelectionProxyModel->setSourceModel(rootModel);
-    thisAndAscendantsSelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QListView *thisAndAscendantsProxyView = new QListView(splitter);
-    thisAndAscendantsProxyView->setModel(thisAndAscendantsSelectionProxyModel);
-
-    QItemSelectionModel *ascendantsOnlySelectionModel = new QItemSelectionModel(rootModel, this);
-
-    KBreadcrumbSelectionModel *ascendantsOnlyProxySelector = new KBreadcrumbSelectionModel(ascendantsOnlySelectionModel, this);
-    ascendantsOnlyProxySelector->setActualSelectionIncluded(false);
-    ascendantsOnlyProxySelector->setBreadcrumbLength(selectionDepth);
-    selectionModelList << ascendantsOnlyProxySelector;
-
-    KSelectionProxyModel *ascendantsOnlySelectionProxyModel = new KSelectionProxyModel(ascendantsOnlySelectionModel, this);
-    ascendantsOnlySelectionProxyModel->setSourceModel(rootModel);
-    ascendantsOnlySelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QListView *ascendantsOnlyProxyView = new QListView(splitter);
-    ascendantsOnlyProxyView->setModel(ascendantsOnlySelectionProxyModel);
-
-    MultiSelectionModel *multiSelectionModel = new MultiSelectionModel(rootModel, selectionModelList, this);
-    dynamicTree->treeView()->setSelectionModel(multiSelectionModel);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbswidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbswidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/breadcrumbswidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/breadcrumbswidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef BREADCRUBS_WIDGET_H
-#define BREADCRUBS_WIDGET_H
-
-#include <QWidget>
-#include <QItemSelection>
-#include <QLabel>
-#include <QListView>
-#include <kselectionproxymodel.h>
-
-#include "klinkitemselectionmodel.h"
-
-class MultiSelectionModel : public QItemSelectionModel
-{
-    Q_OBJECT
-public:
-    MultiSelectionModel(QAbstractItemModel *model, QList<QItemSelectionModel *> selectionModels, QObject *parent = 0);
-
-public:
-    virtual void select(const QModelIndex &index, SelectionFlags command);
-    virtual void select(const QItemSelection &selection, SelectionFlags command);
-
-private:
-    QList<QItemSelectionModel *> m_selectionModels;
-};
-
-class BreadcrumbsWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    BreadcrumbsWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/checkablewidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/checkablewidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/checkablewidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/checkablewidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "checkablewidget.h"
-
-#include <QTreeView>
-#include <QHBoxLayout>
-#include <QSplitter>
-
-#include <kselectionproxymodel.h>
-#include <kcheckableproxymodel.h>
-#include "dynamictreemodel.h"
-
-CheckableWidget::CheckableWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *vSplitter = new QSplitter(this);
-    layout->addWidget(vSplitter);
-
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-
-    ModelInsertCommand *insert = new ModelInsertCommand(rootModel, this);
-    insert->setStartRow(0);
-    insert->interpret(
-        QStringLiteral("- 1"
-        "- 1"
-        "- 1"
-        "- - 2"
-        "- - 2"
-        "- - 2"
-        "- - 2"
-        "- 1"
-        "- 1"
-        "- 1"
-        "- - 2"
-        "- - - 3"
-        "- - - - 4"
-        "- - - - 4"
-        "- - - 3"
-        "- - - 3"
-        "- - - 3"
-        "- - 2"
-        "- - 2"
-        "- - 2"
-        "- 1"
-        "- 1")
-    );
-    insert->doCommand();
-
-    QItemSelectionModel *checkModel = new QItemSelectionModel(rootModel, this);
-    KCheckableProxyModel *checkable = new KCheckableProxyModel(this);
-    checkable->setSourceModel(rootModel);
-    checkable->setSelectionModel(checkModel);
-
-    QTreeView *tree1 = new QTreeView(vSplitter);
-    tree1->setModel(checkable);
-    tree1->expandAll();
-
-    KSelectionProxyModel *selectionProxy = new KSelectionProxyModel(checkModel, this);
-    selectionProxy->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-    selectionProxy->setSourceModel(rootModel);
-
-    QTreeView *tree2 = new QTreeView(vSplitter);
-    tree2->setModel(selectionProxy);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/checkablewidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/checkablewidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/checkablewidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/checkablewidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef CHECKABLEWIDGET_H
-#define CHECKABLEWIDGET_H
-
-#include <QWidget>
-
-class CheckableWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    CheckableWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/CMakeLists.txt kitemmodels-5.17.0/autotests/proxymodeltestapp/CMakeLists.txt
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/CMakeLists.txt	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
-
-set(proxymodeltestapp_SRCS
-    main.cpp
-    mainwindow.cpp
-    breadcrumbswidget.cpp
-    breadcrumbnavigationwidget.cpp
-    breadcrumbdirectionwidget.cpp
-    checkablewidget.cpp
-    selectionpmwidget.cpp
-#     statesaverwidget.cpp
-    kidentityproxymodelwidget.cpp
-    recursivefilterpmwidget.cpp
-    descendantpmwidget.cpp
-    kreparentingproxymodel.cpp
-    proxymodeltestwidget.cpp
-    proxyitemselectionwidget.cpp
-    lessthanwidget.cpp
-    modelcommanderwidget.cpp
-    matchcheckingwidget.cpp
-)
-
-find_package(Qt5Script ${REQUIRED_QT_VERSION} QUIET CONFIG)
-if (Qt5Script_FOUND)
-  list(APPEND proxymodeltestapp_SRCS
-    reparentingpmwidget.cpp
-    scriptablereparentingwidget.cpp
-  )
-endif()
-
-find_package(Qt5QuickWidgets ${REQUIRED_QT_VERSION} CONFIG)
-if (Qt5QuickWidgets_FOUND AND NOT Qt5QuickWidgets_VERSION VERSION_LESS 5.5)
-  list(APPEND proxymodeltestapp_SRCS
-    selectioninqmlwidget.cpp
-  )
-  add_definitions(-DSRC_DIR="${CMAKE_CURRENT_SOURCE_DIR}")
-endif()
-
-add_executable(proxymodeltestapp ${proxymodeltestapp_SRCS})
-
-target_link_libraries(proxymodeltestapp
-   KF5::ItemModels
-   proxymodeltestsuite
-   Qt5::Widgets
-)
-
-if (Qt5Script_FOUND)
-  target_link_libraries(proxymodeltestapp
-    Qt5::Script
-  )
-endif()
-if (Qt5QuickWidgets_FOUND AND NOT Qt5QuickWidgets_VERSION VERSION_LESS 5.5)
-  target_link_libraries(proxymodeltestapp
-    Qt5::QuickWidgets
-  )
-endif()
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/descendantpmwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/descendantpmwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/descendantpmwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/descendantpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,165 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "descendantpmwidget.h"
-
-#include <QTreeView>
-#include <QSplitter>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include "kdescendantsproxymodel.h"
-#include <QHBoxLayout>
-#include <QLineEdit>
-#include <QApplication>
-
-#include "modeleventlogger.h"
-
-DescendantProxyModelWidget::DescendantProxyModelWidget(QWidget *parent): QWidget(parent)
-{
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *vSplitter = new QSplitter(this);
-    layout->addWidget(vSplitter);
-
-    m_rootModel = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *dynTreeWidget = new DynamicTreeWidget(m_rootModel, vSplitter);
-
-    dynTreeWidget->setInitialTree(
-        QStringLiteral("- 1"
-        "- 2"
-        "- - 3"
-        "- - 3"
-        "- - - 4"
-        "- - - 4"
-        "- - - - 4"
-        "- - 4"
-        "- - 5"
-        "- - - 4"
-        "- - - - 4"
-        "- - 5"
-        "- 6"
-        "- 7"
-        "- - 8"
-        "- - - 9"
-        "- - - 10"
-        "- - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - - - - 9"
-        "- - - - - - - - 10"
-        "- - - - - - - - 9"
-        "- - - - - - - 10"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - 10"
-        "- - 11"
-        "- - 12"
-        "- 13"
-        "- 14"
-        "- 15"
-        "- - 16"
-        "- - - 17"
-        "- - - 18"
-        "- 19"
-        "- 20"
-        "- 21"));
-
-    m_eventLogger = new ModelEventLogger(m_rootModel, this);
-
-    m_descProxyModel = new KDescendantsProxyModel(this);
-    m_descProxyModel->setSourceModel(m_rootModel);
-
-//   KDescendantsProxyModel *descProxyModel2 = new KDescendantsProxyModel(this);
-//   descProxyModel2->setSourceModel(m_rootModel);
-//   descProxyModel2->setDisplayAncestorData(true);
-
-//   QTreeView *treeview = new QTreeView( vSplitter );
-//   treeview->setModel(m_rootModel);
-//   treeview->setSelectionMode(QAbstractItemView::ExtendedSelection);
-
-    m_descView = new QTreeView(vSplitter);
-    m_descView->setModel(m_descProxyModel);
-
-//   QTreeView *descView2 = new QTreeView( vSplitter );
-//   descView2->setModel(descProxyModel2);
-
-//   QWidget *w = new QWidget(vSplitter);
-//   QVBoxLayout *vLayout = new QVBoxLayout(w);
-//   QTreeView *matchView = new QTreeView(w);
-//   matchView->setModel(m_selectionProxyModel);
-//   m_lineEdit = new QLineEdit(w);
-//   connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(doMatch(QString)));
-//   connect(m_descView->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)), SLOT(refreshMatch()));
-
-//   vLayout->addWidget(m_lineEdit);
-//   vLayout->addWidget(matchView);
-
-    setLayout(layout);
-}
-
-DescendantProxyModelWidget::~DescendantProxyModelWidget()
-{
-}
-
-void DescendantProxyModelWidget::doMatch(const QString &matchData)
-{
-    Q_UNUSED(matchData);
-#if 0
-    m_itemSelectionModel->clearSelection();
-
-    if (matchData.isEmpty()) {
-        return;
-    }
-
-    QModelIndex start = m_descView->currentIndex();
-
-    if (!start.isValid()) {
-        start = m_descProxyModel->index(0, 0);
-    }
-
-    // TODO: get from user.
-    int hits = -1;
-
-    QModelIndexList matches = m_descProxyModel->match(start, Qt::DisplayRole, matchData, hits, Qt::MatchContains);
-
-    Q_FOREACH (const QModelIndex &matchingIndex, matches) {
-        m_itemSelectionModel->select(matchingIndex, QItemSelectionModel::Select | QItemSelectionModel::Rows);
-    }
-#endif
-}
-
-void DescendantProxyModelWidget::refreshMatch()
-{
-    doMatch(m_lineEdit->text());
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/descendantpmwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/descendantpmwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/descendantpmwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/descendantpmwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,59 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef DESCENDANTPM_WIDGET_H
-#define DESCENDANTPM_WIDGET_H
-
-#include <QWidget>
-
-class DynamicTreeModel;
-class QTreeView;
-class QLineEdit;
-class QItemSelectionModel;
-
-class KDescendantsProxyModel;
-class KSelectionProxyModel;
-
-class ModelEventLogger;
-
-class DescendantProxyModelWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    DescendantProxyModelWidget(QWidget *parent = 0);
-    virtual ~DescendantProxyModelWidget();
-
-protected Q_SLOTS:
-    void doMatch(const QString &matchData);
-    void refreshMatch();
-
-private:
-    DynamicTreeModel *m_rootModel;
-    ModelEventLogger *m_eventLogger;
-    KDescendantsProxyModel *m_descProxyModel;
-    KSelectionProxyModel *m_selectionProxyModel;
-    QItemSelectionModel *m_itemSelectionModel;
-    QTreeView *m_descView;
-    QLineEdit *m_lineEdit;
-
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,76 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "kidentityproxymodelwidget.h"
-
-#include <dynamictreemodel.h>
-#include <kbreadcrumbselectionmodel.h>
-#include <QBoxLayout>
-#include <QSplitter>
-#include <QTreeView>
-#include <QEvent>
-#include <QIdentityProxyModel>
-
-#include "dynamictreewidget.h"
-
-#include "modeltest.h"
-
-KIdentityProxyModelWidget::KIdentityProxyModelWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *splitter = new QSplitter(this);
-    layout->addWidget(splitter);
-
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *treeWidget = new DynamicTreeWidget(rootModel, splitter);
-    treeWidget->setInitialTree(
-        QStringLiteral(" - 1"
-        " - 2"
-        " - - 3"
-        " - - 4"
-        " - - 5"
-        " - 6"
-        " - 7"
-        " - - 8"
-        " - - - 9"
-        " - - - 10"
-        " - - 11")
-//     " - - 12"
-//     " - 13"
-//     " - 14"
-//     " - 15"
-//     " - - 16"
-//     " - - - 17"
-//     " - - - 18"
-//     " - 19"
-//     " - 20"
-//     " - 21"
-    );
-
-    QIdentityProxyModel *proxy = new QIdentityProxyModel(this);
-    proxy->setSourceModel(rootModel);
-
-    QTreeView *view1 = new QTreeView(splitter);
-    view1->setModel(proxy);
-    view1->expandAll();
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/kidentityproxymodelwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef KIDENTITYPROXYMODELWIDGET_H
-#define KIDENTITYPROXYMODELWIDGET_H
-
-#include <QWidget>
-
-class KIdentityProxyModelWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    KIdentityProxyModelWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/kreparentingproxymodel.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/kreparentingproxymodel.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/kreparentingproxymodel.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/kreparentingproxymodel.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,1505 +0,0 @@
-/*
-    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "kreparentingproxymodel.h"
-#include <QDebug>
-#include <QStack>
-
-#include <functional>
-#include <algorithm>
-
-class KReparentingProxyModelPrivate
-{
-    KReparentingProxyModelPrivate(KReparentingProxyModel *proxyModel)
-        : m_nextId(0), q_ptr(proxyModel)
-    {
-
-    }
-
-    qint64 newId() const
-    {
-        return m_nextId++;
-    }
-
-    enum MapStrategy {
-        MapDescendants,
-        MapChildrenOnly
-    };
-
-    /**
-      Creates mappings of indexes in the source model between @p start
-      and @p end which should be represented in the proxy model as descendants
-      of @p parent.
-    */
-    QHash<QModelIndex, QModelIndexList> recreateMappings(const QModelIndex &parent, int start, int end = -1, int strategy = MapChildrenOnly) const;
-
-    /**
-      Merges all indexes from @p mappings which are descendants of @p parent into the model.
-      Returns the remaining mappings.
-
-      Note that this changes the internal model structure and must only be called between begin/end insert/remove/move/reset calls.
-    */
-    QHash<QModelIndex, QModelIndexList> mergeDescendants(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent, int start);
-
-    /**
-      Verifies that the indexes below @p parent between @p start and rowCount(parent)
-      are in the correct positions in the proxy model. Repositions them if not.
-    */
-    void verifyStructure(const QModelIndex &parent, int start);
-
-    /**
-      Returns the index vertically below index in the model @p model.
-      If @p model is 0, the sourceModel is used
-      Returns an invalid index if there is no index below @p index.
-    */
-    QModelIndex getIndexBelow(const QModelIndex &index, QAbstractItemModel *model = 0) const;
-
-    /**
-      Returns the last descendant of @p index or itself if it has no children
-    */
-    QModelIndex getLastDescendant(const QModelIndex &index) const;
-
-    bool isDescendantInModel(const QModelIndex &ancestor, const QModelIndex &descendant) const;
-
-    /**
-      Returns the ancestors of @p descendant that are already in the proxy model.
-
-      Note that @p descendant does not have to be in the proxy yet, and it is not part of the
-      result list.
-    */
-    QVector<QModelIndex> getExistingAncestors(const QModelIndex &descendant) const;
-
-    void sourceRowsAboutToBeInserted(const QModelIndex &parent, int start, int end);
-    void sourceRowsInserted(const QModelIndex &parent, int start, int end);
-    void sourceRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);
-    void sourceRowsRemoved(const QModelIndex &parent, int start, int end);
-    void sourceRowsAboutToBeMoved(const QModelIndex &parent, int start, int end, const QModelIndex &destParent, int destRow);
-    void sourceRowsMoved(const QModelIndex &parent, int start, int end, const QModelIndex &destParent, int destRow);
-    void sourceModelAboutToBeReset();
-    void endResetProxy();
-    void sourceModelReset();
-    void sourceLayoutAboutToBeChanged();
-    void sourceLayoutChanged();
-    void sourceDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
-
-    mutable QHash<qint64, QPersistentModelIndex> m_parents;
-    mutable QHash<QPersistentModelIndex, QList<QPersistentModelIndex> > m_childIndexes;
-
-    struct PendingInsertion {
-        PendingInsertion()
-            : parentId(-1), start(-1), end(-1)
-        { }
-
-        PendingInsertion(const QModelIndex &_index, int _start, int _end)
-            : index(_index), start(_start), end(_end)
-        { }
-
-        QPersistentModelIndex index;
-        QModelIndex sourceIndex;
-        qint64 parentId;
-        int start;
-        int end;
-    };
-
-    struct PendingRemoval : PendingInsertion {
-        int numTrailing;
-    };
-    // Needed between the beginRemoveRows and endRemoveRows signals.
-    mutable QHash<qint64, QPersistentModelIndex> m_pendingRemovalParents;
-    mutable QHash<QPersistentModelIndex, QList<QPersistentModelIndex> > m_pendingRemovalChildIndexes;
-
-    QHash<QModelIndex, QModelIndexList> insertTree(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent);
-
-    void handleInsertion(const PendingInsertion &pendingInsertion);
-
-    void handleRemoval(const PendingRemoval &pendingRemoval);
-
-    mutable QHash<QModelIndex, PendingInsertion> m_pendingInsertions;
-    mutable QVector<PendingRemoval> m_pendingRemovals;
-
-    mutable qint64 m_nextId;
-
-    Q_DECLARE_PUBLIC(KReparentingProxyModel)
-    KReparentingProxyModel *q_ptr;
-
-    QList<QPersistentModelIndex> m_layoutChangePersistentIndexes;
-    QModelIndexList m_proxyIndexes;
-
-    void emitDataChangedSignals(const QModelIndex &parent, int maxChanged);
-
-    /**
-      Given @p parent in the proxy model, return the last index lying between @p start and @p end
-      which is also a descendant of @p parent.
-    */
-    QModelIndex findLastInParent(QModelIndex parent, int start, int end);
-
-    /**
-      Removes @P idx (which is a source model index) and its children from the model data structures.
-    */
-    void removeTree(const QPersistentModelIndex &idx, int start = 0, int end = -1);
-
-    int pendingRemovalRowCount(const QModelIndex &sourceIndex) const;
-
-};
-
-class LessThan
-{
-    const KReparentingProxyModel *m_model;
-public:
-    LessThan(const KReparentingProxyModel *model) : m_model(model) {}
-    bool operator()(const QModelIndex &ancestor, const QModelIndex &descendant)
-    {
-        return m_model->isDescendantOf(ancestor, descendant);
-    }
-};
-
-QModelIndex KReparentingProxyModelPrivate::getIndexBelow(const QModelIndex &index, QAbstractItemModel *model) const
-{
-    Q_Q(const KReparentingProxyModel);
-
-//   qDebug() << index.data() << index;
-
-    if (!model) {
-        model = q->sourceModel();
-    }
-
-    if (model->hasChildren(index)) {
-        return model->index(0, 0, index);
-    }
-
-    QModelIndex sibling = index.sibling(index.row() + 1, index.column());
-    if (sibling.isValid()) {
-        return sibling;
-    }
-
-    QModelIndex parent = index.parent();
-
-    if (!parent.isValid()) {
-        return QModelIndex();
-    }
-
-    int affectedRow = index.row();
-    const int column = 0;
-
-    while (parent.isValid()) {
-//     qDebug() << "parent" << parent.data() << model->rowCount(parent) << affectedRow;
-        if (affectedRow < model->rowCount(parent) - 1) {
-            return model->index(affectedRow + 1, column, parent);
-        }
-
-        affectedRow = parent.row();
-        parent = parent.parent();
-    }
-
-    if (model->rowCount(parent) >= affectedRow) {
-        return model->index(affectedRow + 1, column, parent);
-    }
-
-    return QModelIndex();
-}
-
-QModelIndex KReparentingProxyModelPrivate::getLastDescendant(const QModelIndex &index) const
-{
-    Q_Q(const KReparentingProxyModel);
-
-    QModelIndex proxyIndex = q->mapFromSource(index);
-
-    while (q->hasChildren(proxyIndex)) {
-        proxyIndex = proxyIndex.child(q->rowCount(proxyIndex), proxyIndex.column());
-        if (!proxyIndex.isValid()) {
-            break;
-        }
-    }
-    return q->mapToSource(proxyIndex);
-}
-
-QVector<QModelIndex> KReparentingProxyModelPrivate::getExistingAncestors(const QModelIndex &descendant) const
-{
-    Q_Q(const KReparentingProxyModel);
-
-    QVector<QModelIndex> vector;
-    if (!descendant.isValid()) {
-        return vector;
-    }
-
-    QModelIndex parent = q->mapFromSource(descendant).parent();
-    QModelIndex sourceParent = q->mapToSource(parent);
-    if (!sourceParent.isValid()) {
-        return vector;
-    }
-
-    vector.append(sourceParent);
-    while (parent.isValid()) {
-        parent = parent.parent();
-        sourceParent = q->mapToSource(parent);
-        if (!sourceParent.isValid()) {
-            return vector;
-        }
-        vector.prepend(sourceParent);
-    }
-    return vector;
-}
-
-QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::recreateMappings(const QModelIndex &ancestor, int start, int end, int strategy) const
-{
-    Q_Q(const KReparentingProxyModel);
-    const int column = 0;
-
-    QHash<QModelIndex, QModelIndexList> mappings;
-    // Handle listing the root QModelIndex().
-    if (!ancestor.isValid() && !q->sourceModel()->hasChildren())
-        // Empty model. Nothing to do.
-    {
-        return mappings;
-    }
-
-    // A
-    // - B
-    // - - C
-    // - D
-    // If start refers to D, existing ancestors will contain only A.
-    // We need to go 'up' to C and get its ancestors in case D is to be made a child of B or C (for example if B and C have just been inserted)
-    QModelIndex indexAbove;
-    if (start > 0) {
-        indexAbove = getLastDescendant(q->sourceModel()->index(start - 1, column, ancestor));
-    } else {
-        indexAbove = ancestor;
-    }
-
-    QVector<QModelIndex> ancestors = getExistingAncestors(indexAbove);
-
-//   ancestors.append(indexAbove);
-//   qDebug() << ancestors;
-    QModelIndex nextIndex = ancestor;
-
-    for (int row = start; (row <= end || end == -1);) {
-        // A
-        // - B
-        // - - C
-        // - D
-        // The nextIndex of the invalid QModelIndex is A,
-        // The nextIndex of A is B,
-        // The nextIndex of B is C,
-        // The nextIndex of C is D,
-        // The nextIndex of D is invalid,
-        // When the nextIndex is invalid we're finished creating mappings.
-        if (MapDescendants == strategy) {
-            nextIndex = getIndexBelow(nextIndex);
-        } else {
-            nextIndex = q->sourceModel()->index(row, column, ancestor);
-        }
-
-        if (!nextIndex.isValid()) {
-            break;
-        }
-
-        const QVector<QModelIndex>::iterator ancestorIt = qLowerBound(ancestors.begin(), ancestors.end(), nextIndex, LessThan(q));
-
-        ancestors.erase(ancestorIt, ancestors.end());
-
-        QModelIndex parent;
-        if (ancestorIt != ancestors.begin()) {
-            parent = *(ancestorIt - 1);
-        }
-
-        ancestors.append(nextIndex);
-
-        mappings[parent].append(nextIndex);
-    }
-
-    return mappings;
-}
-
-void KReparentingProxyModelPrivate::verifyStructure(const QModelIndex &sourceParent, int sourceStart)
-{
-    Q_Q(KReparentingProxyModel);
-
-    // If the start structure is:
-
-    // C
-    // D
-    // E
-
-    // and then A and B are inserted, we may need to move C D and E. Not all of the siblings will
-    // necessarily be moved to the same destination parent.
-    // Some example finished scenarios depending on the outcome of isDescendantOf:
-
-    // A
-    // B
-    // C
-    // D
-    // E
-
-    // A
-    // B
-    // - C
-    // - D
-    // - E
-
-    // A
-    // - B
-    // - C
-    // - D
-    // - E
-
-    // A
-    // - B
-    // - - C
-    // - D
-    // E
-
-    // Local variable mappings now contains all the information about finished state
-    // When we locate the first child to be moved, we process it and its siblings
-
-    QHash<QModelIndex, QModelIndexList> mappings = recreateMappings(sourceParent, sourceStart, -1);
-
-    if (mappings.isEmpty()) {
-        return;
-    }
-
-    QModelIndex sourceFirstIndex = q->sourceModel()->index(sourceStart, 0, sourceParent);
-
-    QModelIndex destinationParent;
-    QModelIndexList movedIndexes;
-
-    QHashIterator<QModelIndex, QModelIndexList> it(mappings);
-    while (it.hasNext()) {
-        it.next();
-//     qDebug() << it.key() << it.key().data() << it.value();
-        if (it.value().at(0) == sourceFirstIndex) {
-            destinationParent = it.key();
-            movedIndexes = it.value();
-            break;
-        }
-    }
-
-    Q_FOREVER {
-
-    if (destinationParent == sourceParent)
-            // No indexes moved
-        {
-            return;
-        }
-
-        Q_ASSERT(destinationParent.isValid());
-        Q_ASSERT(!movedIndexes.isEmpty());
-
-        // It's only possible for things to move right, and even that's only an option
-        // for children of parent, but not their descendants. ie, children of C D and E will not need to be reparented.
-        // They are already in the correct positions.
-
-        QList<QPersistentModelIndex> &existingSourceIndexes = m_childIndexes[sourceParent];
-        QList<QPersistentModelIndex> existingDestinationIndexes = m_childIndexes[destinationParent];
-
-        QModelIndex proxySourceParent = q->mapFromSource(sourceParent);
-        QModelIndex proxyDestinationParent = q->mapFromSource(destinationParent);
-
-        // That is, start position of indexes to be moved from the source parent.
-        int proxySourceStart = m_childIndexes.value(sourceParent).indexOf(movedIndexes.at(0));
-        int proxySourceEnd = proxySourceStart + movedIndexes.size() - 1;
-
-        // The moved indexes are appended to the destinationParent. Nothing else is possible.
-        // If they were to be inserted in the middle somewhere, they would already be there.
-
-        int destinationRow = existingDestinationIndexes.size();
-
-        bool allowMove = q->beginMoveRows(proxySourceParent, proxySourceStart, proxySourceEnd, proxyDestinationParent, destinationRow);
-        Q_ASSERT(allowMove);
-
-        for (int row = proxySourceEnd; row >= proxySourceStart; --row)
-        {
-            existingSourceIndexes.removeAt(row);
-        }
-
-        QHash<QModelIndex, QModelIndexList> mapping;
-        mapping.insert(destinationParent, movedIndexes);
-        mergeDescendants(mapping, destinationParent, existingDestinationIndexes.size());
-
-        q->endMoveRows();
-
-        if (!mappings.contains(q->mapToSource(proxyDestinationParent.parent())))
-        {
-            break;
-        }
-
-        destinationParent = q->mapToSource(proxyDestinationParent.parent());
-        movedIndexes = mappings.value(destinationParent);
-    }
-}
-
-KReparentingProxyModel::KReparentingProxyModel(QObject *parent)
-    : QAbstractProxyModel(parent), d_ptr(new KReparentingProxyModelPrivate(this))
-{
-
-}
-
-KReparentingProxyModel::~KReparentingProxyModel()
-{
-    delete d_ptr;
-}
-
-bool KReparentingProxyModelPrivate::isDescendantInModel(const QModelIndex &ancestor, const QModelIndex &descendant) const
-{
-//   qDebug() << ancestor.data() << descendant.data();
-
-//   if (!ancestor.isValid())
-//     return true;
-
-    QModelIndex _ancestor = descendant.parent();
-    while (_ancestor.isValid()) {
-        if (_ancestor == ancestor) {
-            return true;
-        }
-        _ancestor = _ancestor.parent();
-    }
-    return (!ancestor.isValid() && descendant.isValid());
-}
-
-bool KReparentingProxyModel::isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const
-{
-    Q_D(const KReparentingProxyModel);
-    return d->isDescendantInModel(ancestor, descendant);
-//   return (!ancestor.isValid() && descendant.isValid());
-}
-
-QModelIndex KReparentingProxyModel::mapFromSource(const QModelIndex &sourceIndex) const
-{
-    Q_D(const KReparentingProxyModel);
-    if (!sourceIndex.isValid()) {
-        return QModelIndex();
-    }
-
-    QModelIndex sourceIndexFirstColumn = sourceIndex.sibling(sourceIndex.row(), 0);
-
-    QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator it;
-    const QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator begin = d->m_childIndexes.constBegin();
-    const QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator end = d->m_childIndexes.constEnd();
-
-    for (it = begin; it != end; ++it) {
-        QList<QPersistentModelIndex> list = it.value();
-        if (list.contains(sourceIndexFirstColumn)) {
-            QModelIndex sourceParent = it.key();
-            int row = list.indexOf(sourceIndexFirstColumn);
-
-            // There must have been a mapping made for it.
-            Q_ASSERT(d->m_parents.values().contains(sourceParent));
-
-            qint64 id = d->m_parents.key(sourceParent);
-
-            // id refers to the parent.
-            return createIndex(row, sourceIndex.column(), reinterpret_cast<void *>(id));
-        }
-    }
-    return QModelIndex();
-}
-
-QModelIndex KReparentingProxyModel::mapToSource(const QModelIndex &proxyIndex) const
-{
-    Q_D(const KReparentingProxyModel);
-
-//   qDebug() << "MMMMMM" << proxyIndex;
-
-    if (!proxyIndex.isValid()) {
-        return QModelIndex();
-    }
-
-    qint64 id = reinterpret_cast<qint64>(proxyIndex.internalPointer());
-
-//   if (!d->m_parents.contains(id))
-//     qDebug() << d->m_parents << id;
-
-    QModelIndex sourceParent;
-    if (d->m_pendingRemovalParents.contains(id)) {
-//     qDebug() << "pending";
-        sourceParent = d->m_pendingRemovalParents.value(id);
-    } else {
-        Q_ASSERT(d->m_parents.contains(id));
-        sourceParent = d->m_parents.value(id);
-    }
-
-// qDebug() <<  sourceParent << sourceParent.data();
-
-    QModelIndex sourceIndexFirstColumn;
-    if (d->m_pendingRemovalChildIndexes.contains(sourceParent)) {
-//     qDebug() << "#############";
-
-        Q_FOREACH (KReparentingProxyModelPrivate::PendingRemoval pendingRemoval, d->m_pendingRemovals) {
-//       qDebug() << "In" << pendingRemoval.index << pendingRemoval.sourceIndex << sourceParent;
-            if (pendingRemoval.sourceIndex == sourceParent) {
-//         qDebug() << "Out" << pendingRemoval.sourceIndex << sourceParent;
-                int proxyRow = proxyIndex.row();
-                int row = proxyRow - pendingRemoval.start;
-
-//         qDebug() << d->m_pendingRemovalChildIndexes.value(sourceParent) << proxyRow << row << pendingRemoval.end;
-
-                if (proxyRow > pendingRemoval.end) {
-                    Q_ASSERT(d->m_childIndexes.contains(sourceParent));
-                    row = proxyRow - (pendingRemoval.end - pendingRemoval.start + 1);
-//           qDebug() << "new row" << row;
-                    sourceIndexFirstColumn = d->m_childIndexes.value(sourceParent).at(row);
-                } else {
-                    sourceIndexFirstColumn = d->m_pendingRemovalChildIndexes.value(sourceParent).at(row);
-                }
-                break;
-            }
-        }
-    } else {
-        Q_ASSERT(d->m_childIndexes.contains(sourceParent));
-        sourceIndexFirstColumn = d->m_childIndexes.value(sourceParent).at(proxyIndex.row());
-    }
-
-    Q_ASSERT(sourceIndexFirstColumn.isValid());
-
-    return sourceIndexFirstColumn.sibling(sourceIndexFirstColumn.row(), proxyIndex.column());
-}
-
-int KReparentingProxyModel::columnCount(const QModelIndex &parent) const
-{
-    Q_D(const KReparentingProxyModel);
-
-    if (!sourceModel()) {
-        return 0;
-    }
-
-    if (!parent.isValid()) {
-        return sourceModel()->columnCount();
-    }
-
-    if (parent.column() > 0) {
-        return 0;
-    }
-    QModelIndex sourceIndex = mapToSource(parent);
-
-    return (d->m_childIndexes.value(sourceIndex).size() > 0)
-           ? sourceModel()->columnCount() : 0;
-}
-
-QVariant KReparentingProxyModel::data(const QModelIndex &proxyIndex, int role) const
-{
-    return QAbstractProxyModel::data(proxyIndex, role);
-}
-
-QModelIndex KReparentingProxyModel::index(int row, int column, const QModelIndex &parent) const
-{
-    Q_D(const KReparentingProxyModel);
-
-    if (!hasIndex(row, column, parent)) {
-        return QModelIndex();
-    }
-
-    QModelIndex sourceParent = mapToSource(parent);
-
-//   if (!d->m_pendingRemovals.isEmpty())
-//     qDebug() << sourceParent << sourceParent.data();
-
-    // ### This is where we need to have the children of removed indexes stored.
-
-//   if (!d->m_parents.values().contains(sourceParent))
-//   {
-//     qDebug() << d->m_pendingRemovalParents.values() << sourceParent << d->m_pendingRemovalParents.values().contains(sourceParent);
-//   }
-
-    qint64 id;
-    if (d->m_pendingRemovalParents.values().contains(sourceParent)) {
-        id = d->m_pendingRemovalParents.key(sourceParent);
-    } else {
-        // There must have been a mapping made for it.
-        Q_ASSERT(d->m_parents.values().contains(sourceParent));
-        id = d->m_parents.key(sourceParent);
-    }
-    return createIndex(row, column, reinterpret_cast<void *>(id));
-}
-
-QModelIndex KReparentingProxyModel::parent(const QModelIndex &child) const
-{
-    Q_D(const KReparentingProxyModel);
-
-    if (!child.isValid()) {
-        return QModelIndex();
-    }
-
-    QModelIndex sourceIndex = mapToSource(child);
-
-    QModelIndex firstColumnChild = sourceIndex;
-    if (sourceIndex.column() > 0) {
-        firstColumnChild = sourceIndex.sibling(sourceIndex.row(), 0);
-    }
-
-    QHashIterator<QPersistentModelIndex, QList<QPersistentModelIndex> > itPending(d->m_pendingRemovalChildIndexes);
-
-    while (itPending.hasNext()) {
-        itPending.next();
-
-        if (itPending.value().contains(firstColumnChild)) {
-            return mapFromSource(itPending.key());
-        }
-    }
-
-    QHashIterator<QPersistentModelIndex, QList<QPersistentModelIndex> > it(d->m_childIndexes);
-
-    while (it.hasNext()) {
-        it.next();
-
-        if (it.value().contains(firstColumnChild)) {
-            return mapFromSource(it.key());
-        }
-    }
-    return QModelIndex();
-}
-
-int KReparentingProxyModelPrivate::pendingRemovalRowCount(const QModelIndex &sourceIndex) const
-{
-
-    Q_FOREACH (const PendingRemoval &pendingRemoval, m_pendingRemovals) {
-//     qDebug() << pendingRemoval.sourceIndex;
-        if (pendingRemoval.sourceIndex == sourceIndex) {
-            return pendingRemoval.end - pendingRemoval.start + 1;
-        }
-    }
-    return 0;
-}
-
-int KReparentingProxyModel::rowCount(const QModelIndex &parent) const
-{
-    Q_D(const KReparentingProxyModel);
-
-    if (parent.column() > 0) {
-        return 0;
-    }
-
-    QModelIndex sourceIndex = mapToSource(parent);
-
-    int size = d->m_childIndexes.value(sourceIndex).size() + d->m_pendingRemovalChildIndexes.value(sourceIndex).size();
-
-//   qDebug() << d->m_pendingRemovalChildIndexes.value(sourceIndex).size();
-
-//   if (!d->m_pendingRemovals.isEmpty())
-//   {
-//     qDebug() << "SIZE" << sourceIndex << sourceIndex.data() << size << d->m_pendingRemovals.size() << d->pendingRemovalRowCount(sourceIndex);
-//   }
-
-    return size;
-}
-
-bool KReparentingProxyModel::hasChildren(const QModelIndex &parent) const
-{
-    return rowCount(parent) > 0;
-}
-
-void KReparentingProxyModel::setSourceModel(QAbstractItemModel *sourceModel)
-{
-    Q_D(KReparentingProxyModel);
-
-    beginResetModel();
-
-    disconnect(sourceModel, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
-               this, SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
-    disconnect(sourceModel, SIGNAL(rowsInserted(QModelIndex,int,int)),
-               this, SLOT(sourceRowsInserted(QModelIndex,int,int)));
-    disconnect(sourceModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-               this, SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
-    disconnect(sourceModel, SIGNAL(rowsRemoved(QModelIndex,int,int)),
-               this, SLOT(sourceRowsRemoved(QModelIndex,int,int)));
-    disconnect(sourceModel, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
-               this, SLOT(sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
-    disconnect(sourceModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
-               this, SLOT(sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
-    disconnect(sourceModel, SIGNAL(modelAboutToBeReset()),
-               this, SLOT(sourceModelAboutToBeReset()));
-    disconnect(sourceModel, SIGNAL(modelReset()),
-               this, SLOT(sourceModelReset()));
-    disconnect(sourceModel, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
-               this, SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
-    disconnect(sourceModel, SIGNAL(layoutAboutToBeChanged()),
-               this, SLOT(sourceLayoutAboutToBeChanged()));
-    disconnect(sourceModel, SIGNAL(layoutChanged()),
-               this, SLOT(sourceLayoutChanged()));
-
-    QAbstractProxyModel::setSourceModel(sourceModel);
-
-//   qDebug() << "set";
-    QHash<QModelIndex, QModelIndexList> mappings = d->recreateMappings(QModelIndex(), 0, sourceModel->rowCount() - 1, KReparentingProxyModelPrivate::MapDescendants);
-//   qDebug() << "begin";
-    d->mergeDescendants(mappings, QModelIndex(), 0);
-
-    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
-            SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
-    connect(sourceModel, SIGNAL(rowsInserted(QModelIndex,int,int)),
-            SLOT(sourceRowsInserted(QModelIndex,int,int)));
-    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-            SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
-    connect(sourceModel, SIGNAL(rowsRemoved(QModelIndex,int,int)),
-            SLOT(sourceRowsRemoved(QModelIndex,int,int)));
-    connect(sourceModel, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
-            SLOT(sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
-    connect(sourceModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
-            SLOT(sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
-    connect(sourceModel, SIGNAL(modelAboutToBeReset()),
-            SLOT(sourceModelAboutToBeReset()));
-    connect(sourceModel, SIGNAL(modelReset()),
-            SLOT(sourceModelReset()));
-    connect(sourceModel, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
-            SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
-    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()),
-            SLOT(sourceLayoutAboutToBeChanged()));
-    connect(sourceModel, SIGNAL(layoutChanged()),
-            SLOT(sourceLayoutChanged()));
-
-    endResetModel();
-}
-
-void KReparentingProxyModelPrivate::sourceRowsAboutToBeInserted(const QModelIndex &parent, int start, int end)
-{
-    Q_Q(KReparentingProxyModel);
-    return q->beginResetModel();
-
-    // We can't figure out the structure until the indexes are in the model.
-    // Store the signal until the new rows are actually there in sourceRowsInserted.
-    PendingInsertion pendingInsertion(parent, start, end);
-    m_pendingInsertions.insert(parent, pendingInsertion);
-}
-
-QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::mergeDescendants(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent, int start)
-{
-    QModelIndexList childIndexes = mappings.take(parent);
-//   qDebug() << childIndexes;
-    if (!childIndexes.isEmpty()) {
-        if (!m_parents.values().contains(parent)) {
-            m_parents.insert(newId(), QPersistentModelIndex(parent));
-        }
-    }
-    int row = start;
-    Q_FOREACH (const QModelIndex &idx, childIndexes) {
-        m_childIndexes[parent].insert(row++, QPersistentModelIndex(idx));
-        mappings = mergeDescendants(mappings, idx, 0);
-    }
-    return mappings;
-}
-
-QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::insertTree(QHash<QModelIndex, QModelIndexList>, const QModelIndex &)
-{
-    return QHash<QModelIndex, QModelIndexList>();
-
-}
-
-void KReparentingProxyModelPrivate::handleInsertion(const PendingInsertion &pendingInsertion)
-{
-    Q_Q(KReparentingProxyModel);
-    QModelIndex parent = pendingInsertion.index;
-    int start = pendingInsertion.start;
-    int end = pendingInsertion.end;
-
-//   qDebug() << parent << parent.data() << start << end;
-
-//   for (int i = start; i < end; ++i)
-//   {
-//     QModelIndex idx = q->sourceModel()->index(i, 0, parent);
-//     qDebug() << idx << idx.data();
-//   }
-
-    QHash<QModelIndex, QModelIndexList> newItemMappings = recreateMappings(parent, start, end, KReparentingProxyModelPrivate::MapDescendants);
-
-    // iterate over keys. if key in keys iterate up. This gives list of top level parents.
-    // Pick the one whoes parent is @p parent. Insert it. Look up until find the parent of another one and insert that.
-    // If one of the parents is invalid it is necessarily the last one to be processed (if there are more to process, they'll be children of it)
-    // That case should work too.
-
-//   qDebug() << "new item mappings" << newItemMappings;
-
-    const int column = 0;
-
-//   qDebug() << m_childIndexes.contains(parent);
-
-    if (newItemMappings.contains(parent)) {
-        QModelIndexList newItemList = newItemMappings.value(parent);
-//     qDebug() << "newItemList" << newItemList;
-        int proxyStart = 0;
-
-        // A single insertion in the source model might be multiple insertions in the proxy model.
-        Q_FOREVER {
-        if (newItemList.isEmpty())
-            {
-                if (!newItemMappings.contains(parent.parent())) {
-                    break;
-                }
-
-                newItemList = newItemMappings.value(parent.parent());
-                continue;
-            }
-
-            proxyStart = 0;
-
-            QModelIndex proxyParent = q->mapFromSource(parent);
-            if (start > 0)
-            {
-                QModelIndex lastDesc = q->mapFromSource(getLastDescendant(q->sourceModel()->index(start - 1, column, parent)));
-
-                while (lastDesc.parent() != proxyParent) {
-                    lastDesc = lastDesc.parent();
-                }
-                proxyStart = lastDesc.row() + 1;
-            }
-
-            q->beginInsertRows(proxyParent, proxyStart, proxyStart + newItemList.size() - 1);
-
-            newItemMappings = mergeDescendants(newItemMappings, parent, proxyStart);
-
-            q->endInsertRows();
-
-            if (!newItemMappings.contains(parent.parent()))
-            {
-                break;
-            }
-
-            newItemList = newItemMappings.value(parent.parent());
-        }
-    }
-
-//   // The rest are not descendants of pendingInsertion.index in the proxy model, but are elsewhere.
-//   Q_FOREACH(const QModelIndex &parent, newItemMappings.keys())
-//   {
-//
-//   }
-
-    return;
-}
-
-void KReparentingProxyModelPrivate::sourceRowsInserted(const QModelIndex &parent, int, int end)
-{
-    Q_Q(KReparentingProxyModel);
-    return endResetProxy();
-    if (m_pendingInsertions.contains(parent)) {
-        PendingInsertion pendingInsertion = m_pendingInsertions.value(parent);
-        handleInsertion(pendingInsertion);
-
-        if (q->sourceModel()->rowCount(parent) <= (end + 1)) {
-            return;
-        }
-
-        // The presence of new rows might affect the structure of indexes below.
-        verifyStructure(parent, end + 1);
-    }
-}
-
-void KReparentingProxyModelPrivate::removeTree(const QPersistentModelIndex &idxToRemove, int start, int end)
-{
-    if (!m_childIndexes.contains(idxToRemove)) {
-        return;
-    }
-
-//   qDebug() << "idxToRemove" << idxToRemove << start << end;
-
-    QList<QPersistentModelIndex> &toRemove = m_childIndexes[ idxToRemove ];
-//   qDebug() << toRemove << toRemove.size();
-
-//   QList<int> intList;
-//   intList << 1 << 2 << 3 << 4 << 5;
-//
-//   QList<int>::iterator intit = intList.begin();
-//   QList<int>::iterator intendIt = intList.end();
-//
-//   if (end == 0)
-//     intendIt = intit + 1;
-//
-//   if (end > 0)
-//   {
-//     intendIt = intit + (end - start + 1) + 1;
-//     qDebug() << "intend" << *intendIt;
-//   }
-//   intit += start;
-//
-//   while (intit != intendIt)
-//   {
-//     int i = *intit;
-//     qDebug() << i;
-//     intit = intList.erase(intit);
-//   }
-
-    QList<QPersistentModelIndex>::iterator it = toRemove.begin();
-    QList<QPersistentModelIndex>::iterator endIt = toRemove.end();
-
-    if (end == 0) {
-        endIt = it + 1;
-    }
-
-    if (end > 0) {
-        endIt = it + (end - start + 1) + 1;
-    }
-    it += start;
-
-    int i = start;
-    while (it != endIt) {
-        QPersistentModelIndex idx = *it;
-//     qDebug() << "removing" << idx << idx.data();
-
-        if (m_parents.values().contains(idx)) {
-            qint64 key = m_parents.key(idx);
-            QPersistentModelIndex value = m_parents.take(key);
-            m_pendingRemovalParents.insert(key, value);
-//       qDebug() << "take from parent" << value;
-        }
-        removeTree(idx);
-
-        ++i;
-
-        m_pendingRemovalChildIndexes[idxToRemove].append(idx);
-//     qDebug() << idxToRemove << idxToRemove.data() << idx << idx.data();
-
-        it = toRemove.erase(it);
-//     qDebug() << (it == endIt);
-//     if (i > end)
-//       break;
-
-//     if (it == toRemove.end())
-//       break;
-
-    }
-
-//   qDebug() << "toRemove" << toRemove;
-
-//   for(int i = start; (i <= end || (end == -1 && toRemove.size() > i)); )
-//   {
-//     qDebug() << i;
-//     QPersistentModelIndex idx = toRemove.takeAt(i);
-//     --end;
-//
-//     qDebug() << "removing" << idx.data();
-//
-//     if (m_parents.values().contains(idx))
-//     {
-//       QPersistentModelIndex bah = m_parents.take(m_parents.key(idx));
-// //       qDebug() << "take from parent" << bah;
-//     }
-//     removeTree(idx);
-//   }
-}
-
-void KReparentingProxyModelPrivate::sourceRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end)
-{
-    Q_Q(KReparentingProxyModel);
-    q->beginResetModel();
-    return;
-//   qDebug() << parent << start << end;
-
-    // This is really tricky.
-    //
-    // We could have something like:
-    //
-    //   A              A
-    //   B              - B
-    //   C    ->        - - C
-    //   D              D
-    //   E              - E
-    //
-    // And have to remove something like B to D. That would mean a remove signal for B, move E to its grandparent, remove D.
-
-//   QHashIterator<QPersistentModelIndex, QList< QPersistentModelIndex> > it(m_childIndexes);
-//   while (it.hasNext())
-//   {
-//     it.next();
-//     qDebug() << it.key() << it.key().data();
-//     qDebug() << it.value();
-//   }
-
-    const int column = 0;
-
-    QModelIndex firstAffectedIndex = q->mapFromSource(q->sourceModel()->index(start, column, parent));
-    QModelIndex lastAffectedIndex = q->mapFromSource(q->sourceModel()->index(end, column, parent));
-
-//   qDebug() << "firstAffectedIndex" << firstAffectedIndex.data();
-//   qDebug() << "lastAffectedIndex" << lastAffectedIndex.data();
-
-    QModelIndex proxyParent = firstAffectedIndex.parent();
-
-    Q_ASSERT(firstAffectedIndex.isValid() && lastAffectedIndex.isValid());
-
-    Q_FOREVER {
-    if (isDescendantInModel(proxyParent, lastAffectedIndex))
-        {
-            // They share a common ancestor.
-
-            QModelIndex _parent = lastAffectedIndex.parent();
-            QModelIndex lastAffectedAncestor = lastAffectedIndex;
-//       qDebug() << "last affected ancestor" << lastAffectedAncestor.data();
-            while (_parent != proxyParent) {
-                lastAffectedAncestor = _parent;
-                _parent = _parent.parent();
-            }
-
-            if (q->hasChildren(lastAffectedAncestor)) {
-                QModelIndex next = q->index(0, 0, lastAffectedAncestor);
-
-                QModelIndex proxySourceParent = lastAffectedAncestor;
-                int startRow = next.row();
-                int lastRow = q->rowCount(lastAffectedAncestor) - 1;
-
-                QList<QPersistentModelIndex> &existingSourceIndexes = m_childIndexes[q->mapToSource(proxySourceParent)];
-                QList<QPersistentModelIndex> &existingDestinationIndexes = m_childIndexes[q->mapToSource(proxyParent)];
-
-                int destRow = lastAffectedAncestor.row() + 1;
-
-//         qDebug() << "Move from" << lastAffectedAncestor.data() << startRow << lastRow << " To " << proxyParent.data() << destRow;
-                bool allowMove = q->beginMoveRows(lastAffectedAncestor, startRow, lastRow, proxyParent, destRow);
-                Q_ASSERT(allowMove);
-
-                for (int i = startRow; i <= lastRow; ++i) {
-                    QPersistentModelIndex movingIdx = existingSourceIndexes.takeAt(startRow);
-                    existingDestinationIndexes.insert(destRow + (i - startRow), movingIdx);
-                }
-
-                // TODO: If source was a parent before, it might not be now.
-                // dest was already a parent.
-
-                q->endMoveRows();
-            }
-            PendingRemoval removal;
-            removal.index = proxyParent;
-            removal.start = firstAffectedIndex.row();
-            removal.end = lastAffectedAncestor.row();
-            removal.parentId = proxyParent.internalId();
-            removal.sourceIndex = q->mapToSource(proxyParent);
-            m_pendingRemovals.append(removal);
-
-            removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
-
-//       qDebug() << "beg rem 1";
-            q->beginRemoveRows(proxyParent, removal.start, removal.end);
-
-            return;
-
-        } else {
-            QModelIndex next = getIndexBelow(firstAffectedIndex);
-
-            proxyParent = next.parent();
-
-            while (isDescendantInModel(proxyParent, next))
-            {
-                next = getIndexBelow(next);
-            }
-            QModelIndex _parent = next.parent();
-            QModelIndex lastAffectedAncestor = next;
-
-            while (_parent != proxyParent)
-            {
-                lastAffectedAncestor = _parent;
-                _parent = _parent.parent();
-            }
-
-            PendingRemoval removal;
-            removal.index = proxyParent;
-            removal.start = firstAffectedIndex.row();
-            removal.end = lastAffectedAncestor.row();
-            removal.parentId = proxyParent.internalId();
-            removal.sourceIndex = q->mapToSource(proxyParent);
-            m_pendingRemovals.append(removal);
-
-            removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
-
-//       qDebug() << "beg rem 1";
-            q->beginRemoveRows(proxyParent, removal.start, removal.end);
-
-            proxyParent = next.parent();
-        }
-    }
-
-// //   qDebug() << proxyParent.data() << lastAffectedIndex.parent().data() << proxyParent << lastAffectedIndex.parent();
-//   if (proxyParent == lastAffectedIndex.parent())
-//   {
-//     PendingRemoval removal;
-//     removal.index = proxyParent;
-//     removal.start = firstAffectedIndex.row();
-//     removal.end = lastAffectedIndex.row();
-//     removal.parentId = proxyParent.internalId();
-//     removal.sourceIndex = q->mapToSource(proxyParent);
-//     m_pendingRemovals.append(removal);
-//
-//     // Also need to store a removal object for each of the descendants.
-//
-//     removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
-//
-// //     qDebug() << "beg rem 1";
-//     q->beginRemoveRows(proxyParent, removal.start, removal.end);
-//     return;
-//   }
-//
-//   QModelIndex lastParent = lastAffectedIndex.parent();
-//   while (lastParent.parent().isValid())
-//   {
-//     if (lastParent.parent() == proxyParent)
-//     {
-//       PendingRemoval removal;
-//       removal.index = proxyParent;
-//       removal.start = firstAffectedIndex.row();
-//       removal.end = lastParent.row();
-//       removal.parentId = proxyParent.internalId();
-//       removal.sourceIndex = q->mapToSource(proxyParent);
-//       m_pendingRemovals.append(removal);
-//
-// //       qDebug() << "beg rem 2";
-//       q->beginRemoveRows(proxyParent, removal.start, removal.end);
-//       return;
-//     }
-//     lastParent = lastParent.parent();
-//   }
-//
-//   // Several blocks need to be removed from the proxy model.
-//   // Divide and conquer to find them.
-//
-//   int proxyStart = firstAffectedIndex.row();
-//   int proxyEnd = proxyStart + (end - start);
-//   int processedUntil = start;
-//
-//   while (processedUntil <= end)
-//   {
-//     QModelIndex lastInParent = findLastInParent(proxyParent, proxyStart, proxyEnd);
-//     qDebug() << "lastInParent" << lastInParent;
-//
-//     QModelIndex sourceLast = q->mapToSource(lastInParent);
-//     processedUntil = sourceLast.row();
-//
-//     PendingRemoval removal;
-//     removal.index = proxyParent;
-//     removal.start = proxyStart;
-//     removal.end = lastInParent.row();
-//     removal.parentId = proxyParent.internalId();
-//     removal.sourceIndex = q->mapToSource(proxyParent);
-//     m_pendingRemovals.append(removal);
-//
-//     qDebug() << "beg rem 3";
-//     q->beginRemoveRows(proxyParent, removal.start, removal.end);
-//
-//     QModelIndex proxyIndexBelow = getIndexBelow(lastInParent, q);
-//
-//     if (!proxyIndexBelow.isValid())
-//       return;
-//
-//     proxyParent = proxyIndexBelow.parent();
-//     proxyStart = proxyIndexBelow.row();
-//   }
-}
-
-QModelIndex KReparentingProxyModelPrivate::findLastInParent(QModelIndex parent, int start, int end)
-{
-    Q_Q(KReparentingProxyModel);
-
-    const int column = 0;
-
-    if (start == end) {
-        return q->index(start, column, parent);
-    }
-
-    int middle = start + (end - start / 2);
-
-    QModelIndex sourceParent = q->mapToSource(parent);
-    QModelIndex middleIndex = q->mapFromSource(q->sourceModel()->index(middle, column, sourceParent));
-
-    if (middleIndex.parent() == parent) {
-        return findLastInParent(parent, middle, end);
-    } else {
-        return findLastInParent(parent, start + ((middle - start) / 2), middle);
-    }
-}
-
-//   qDebug() << affectedIndex << affectedIndex.data() << proxyParent;
-//
-//   QHash<QModelIndex, PendingRemoval> pendingRemovals;
-//
-//   int i = start;
-//   while (i <= end)
-//   {
-//     affectedIndex = affectedIndex.sibling(i, column);
-//
-// //     affectedIndex = getIndexBelow(affectedIndex, q);
-//     if (!affectedIndex.isValid())
-//       break;
-// //     Q_ASSERT(affectedIndex.isValid());
-//
-//     if (affectedIndex.parent() != proxyParent)
-//     {
-//       // affectedIndex.parent() must be left of proxyParent
-//
-//       PendingRemoval removal;
-//       removal.index = proxyParent;
-//       removal.start = start;
-//       removal.end = i;
-//       pendingRemovals.insert(proxyParent, removal);
-//
-//       emit q->rowsAboutToBeRemoved(proxyParent, start, i);
-//       proxyParent = affectedIndex.parent();
-//
-//       end -= (i - start + 1);
-//       start = affectedIndex.row();
-//       i = start;
-//     }
-//
-//     ++i;
-//   }
-
-// Move younger siblings out of the way so that the rows can be removed easily
-// No. It's easier to use verifyStructure afterward.
-
-//   // Removing rows in the source model could require sending the children to their grandparents.
-//
-//   QHash<QModelIndex, QModelIndexList> mappings;
-//   recreateMappings(parent, start, end);
-//
-//   QHashIterator<QModelIndex, QModelIndexList> it(mappings);
-//   while (it.hasNext())
-//   {
-//     it.next();
-//     QModelIndexList removedList = it.value();
-//     PendingRemoval pendingRemoval;
-//     pendingRemoval.index = it.key();
-//     pendingRemoval.start = q->mapFromSource(removedList.at(0)).row();
-//     pendingRemoval.end = pendingRemoval.start + removedList.size() - 1;
-//     m_pendingRemovals.insert(parent, pendingRemoval);
-//   }
-// }
-
-void KReparentingProxyModelPrivate::handleRemoval(const PendingRemoval &pendingRemoval)
-{
-  Q_UNUSED(pendingRemoval)
-//   Q_Q(KReparentingProxyModel);
-//   q->beginRemoveRows(pendingRemoval.index, pendingRemoval.start, pendingRemoval.end);
-//   m_childIndexes.remove(pendingRemoval.index);
-//   // Remove stuff from m_parents.
-//   q->endRemoveRows();
-}
-
-void KReparentingProxyModelPrivate::sourceRowsRemoved(const QModelIndex &parent, int, int)
-{
-    return endResetProxy();
-
-    Q_Q(KReparentingProxyModel);
-
-    // loop over pending removals and process each one. Then look after the last one
-    // to move displaced rows to where they should be.
-
-    int lastAffectedRow = m_pendingRemovals.last().end;
-    QModelIndex lastAffectedIndex = m_pendingRemovals.last().index;
-
-    QMutableVectorIterator<PendingRemoval> it(m_pendingRemovals);
-
-    while (it.hasNext()) {
-        PendingRemoval removal = it.next();
-        m_pendingRemovalChildIndexes.remove(removal.sourceIndex);
-        m_pendingRemovalParents.remove(parent.internalId());
-        it.remove();
-
-        emit q->endRemoveRows();
-    }
-//   qDebug() << "Remove done ##########";
-
-//   qDebug() << lastAffectedIndex << lastAffectedIndex.data() << lastAffectedRow;
-
-    verifyStructure(lastAffectedIndex, lastAffectedRow - 1);
-}
-
-void KReparentingProxyModelPrivate::sourceRowsAboutToBeMoved(const QModelIndex &parent, int start, int end, const QModelIndex &, int)
-{
-    // This could be several individual moves in the proxy model, or it could be no moves at all.
-    // We can get the top indexes of the moved list and move those.
-    // because their children won't be moved anywhere different.
-
-    // I could look at the indexes between start and end (proxied could be several blocks), and move them to dest.
-    // Then verify structure.
-    // This could lead to an illegal move.
-    // If we have
-    //
-    // Source:        Proxy:
-    // A              A
-    // B              B
-    // C              - C
-    // D              - D
-    // E              E
-    //
-    // then source can legally move B to between C and D, however, implemented naively the proxymodel would attempt an illegal move.
-    // We must first reparent everything below destRow in the proxy to the parent of parent in this case, then perform the move, then
-    // verifyStructure.
-    //
-    // Moving B C and D to below E would be a legal move in the proxy model.
-    //
-    // Children of moved indexes which are not themselves moved must be first sent to their grandparents.
-    // So if B and C were moved in the source model above to below E, D would first be moved to its grandparent, then B would be moved below E,
-    // then the structure would need to be verified.
-    //
-    // Proxy start state:     Intermediate state:   Intermediate or final state:   Possible alternative final state:
-    //       A                      A                     A                              A
-    //       B                      B                     E                              E
-    //       - C                    - C                   D                              - D
-    //       - D                    D                     B                              B
-    //       E                      E                     - C                            - C
-
-    // So, I could iterate from start to end in proxySourceParent and if the depth goes less than parent, emit a block move, then start again.
-
-    QHash<QModelIndex, QModelIndexList> newMappings = recreateMappings(parent, start, end);
-
-}
-
-void KReparentingProxyModelPrivate::sourceRowsMoved(const QModelIndex &, int, int, const QModelIndex &, int)
-{
-
-}
-
-void KReparentingProxyModelPrivate::sourceLayoutAboutToBeChanged()
-{
-    Q_Q(KReparentingProxyModel);
-
-    q->beginResetModel();
-    return;
-
-    emit q->layoutAboutToBeChanged();
-
-    Q_FOREACH (QPersistentModelIndex proxyPersistentIndex, q->persistentIndexList()) {
-        m_proxyIndexes << proxyPersistentIndex;
-        m_layoutChangePersistentIndexes << QPersistentModelIndex(q->mapToSource(proxyPersistentIndex));
-    }
-}
-
-void KReparentingProxyModelPrivate::sourceLayoutChanged()
-{
-    Q_Q(KReparentingProxyModel);
-
-    endResetProxy();
-    return;
-
-    for (int i = 0; i < m_proxyIndexes.size(); ++i) {
-        q->changePersistentIndex(m_proxyIndexes.at(i), q->mapFromSource(m_layoutChangePersistentIndexes.at(i)));
-    }
-
-    m_layoutChangePersistentIndexes.clear();
-    m_proxyIndexes.clear();
-
-    emit q->layoutChanged();
-}
-
-void KReparentingProxyModelPrivate::sourceModelAboutToBeReset()
-{
-    Q_Q(KReparentingProxyModel);
-    q->beginResetModel();
-}
-
-void KReparentingProxyModelPrivate::endResetProxy()
-{
-    Q_Q(KReparentingProxyModel);
-
-    m_parents.clear();
-    m_childIndexes.clear();
-    m_nextId = 0;
-    m_pendingInsertions.clear();
-    m_pendingRemovals.clear();
-    m_pendingRemovalChildIndexes.clear();
-    m_pendingRemovalParents.clear();
-//   qDebug() << q->sourceModel()->rowCount();
-    QHash<QModelIndex, QModelIndexList> mappings = recreateMappings(QModelIndex(), 0, q->sourceModel()->rowCount() - 1, KReparentingProxyModelPrivate::MapDescendants);
-    qDebug() << mappings;
-
-    mergeDescendants(mappings, QModelIndex(), 0);
-    q->endResetModel();
-}
-
-void KReparentingProxyModelPrivate::sourceModelReset()
-{
-    endResetProxy();
-}
-
-void KReparentingProxyModelPrivate::emitDataChangedSignals(const QModelIndex &startIndex, int maxChanged)
-{
-    Q_Q(KReparentingProxyModel);
-
-    QModelIndex proxyParent = startIndex.parent();
-
-    int numChanged = 1;
-
-    QModelIndex lastAffectedSibling = startIndex;
-    QModelIndex proxySibling = getIndexBelow(startIndex, q);
-
-    Q_FOREVER {
-    if (proxySibling.parent() != proxyParent || numChanged >= maxChanged)
-        {
-            break;
-        }
-
-        numChanged++;
-        lastAffectedSibling = proxySibling;
-
-        proxySibling = getIndexBelow(proxySibling);
-    }
-
-    emit q->dataChanged(startIndex, lastAffectedSibling);
-    if (numChanged < maxChanged) {
-        emitDataChangedSignals(proxySibling, maxChanged - numChanged);
-    }
-}
-
-void KReparentingProxyModelPrivate::sourceDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)
-{
-    Q_Q(KReparentingProxyModel);
-
-    q->beginResetModel();
-    endResetProxy();
-    return;
-
-    QModelIndex parent = topLeft.parent();
-    const int start = topLeft.row();
-    const int end = bottomRight.row();
-    const int column = 0;
-    const int maxChanged = end - start + 1;
-
-    // Create mappings to the end because changing data can affect structure of siblings.
-    verifyStructure(parent, start);
-
-    // mapFromSource and emit signals.
-
-    QModelIndex proxyStartIndex = q->mapFromSource(q->sourceModel()->index(start, column, parent));
-
-    emitDataChangedSignals(proxyStartIndex, maxChanged);
-
-}
-
-Qt::DropActions KReparentingProxyModel::supportedDropActions() const
-{
-    Q_ASSERT(sourceModel());
-    return sourceModel()->supportedDropActions();
-}
-
-void KReparentingProxyModel::beginChangeRule()
-{
-    Q_D(KReparentingProxyModel);
-    d->sourceModelAboutToBeReset();
-//   beginResetModel();
-//   d->m_childIndexes.clear();
-//   d->m_layoutChangePersistentIndexes.clear();
-//   d->m_nextId = 1;
-//   d->m_parents.clear();
-//   d->m_pendingInsertions.clear();
-//   d->m_pendingRemovalChildIndexes.clear();
-//   d->m_pendingRemovalParents.clear();
-//   d->m_pendingRemovals.clear();
-//   d->m_proxyIndexes.clear();
-}
-
-void KReparentingProxyModel::endChangeRule()
-{
-    Q_D(KReparentingProxyModel);
-    d->endResetProxy();
-    return;
-}
-
-#include "moc_kreparentingproxymodel.cpp"
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/kreparentingproxymodel.h kitemmodels-5.17.0/autotests/proxymodeltestapp/kreparentingproxymodel.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/kreparentingproxymodel.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/kreparentingproxymodel.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,157 +0,0 @@
-/*
-    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef KREPARENTINGPROXYMODEL_H
-#define KREPARENTINGPROXYMODEL_H
-
-#include <QAbstractProxyModel>
-
-class KReparentingProxyModelPrivate;
-
-/**
-  @brief Restructures a source model, changing the parents of items.
-
-  Subclasses can change the structure of a source model by reimplementing
-  the isDescendantOf method.
-
-  For example, if the source model is a list,
-
-  @verbatim
-  0
-  - A
-  - B
-  - C
-  - D
-  - E
-  @endverbatim
-
-  It could be converted to a tree by an implementation something like:
-
-  @code
-  bool MyReparentingModel::isDescedantOf(const QModelIndex& ancestor, const QModelIndex& descendant ) const
-  {
-     return (
-             (ancestor.data().toString() == "A" && descendant.data().toString() == "B")
-          || (ancestor.data().toString() == "A" && descendant.data().toString() == "C")
-          || (ancestor.data().toString() == "B" && descendant.data().toString() == "C")
-          || (ancestor.data().toString() == "A" && descendant.data().toString() == "D")
-          )
-    ? true : KReparentingProxyModel::isDescendantOf(ancestor, descendant);
-  }
-  @endcode
-
-  to get this result:
-
-  @verbatim
-  0
-  - A
-  - - B
-  - - - C
-  - - D
-  - E
-  @endverbatim
-
-  Note that the implementation returns true for a query if "C" is a descendant of "A".
-  The implementation must return the correct value for all of its descendants, not only its direct parent.
-  The actual location to insert the descendant in the tree is determined internally by a binary find algorithm.
-
-  The KReparentingProxyModel performs movement of items in the left-right directions, but not the up-down directions.
-
-  \image html reparenting1.png "KReparentingProxyModel moving rows left to right"
-
-  \image html reparenting2.png "KReparentingProxyModel can not move items both left-right and up-down"
-
-  Reordering the rows in a model is the domain of QSortFilterProxyModel. An intermediate QSortFilterProxyModel
-  can be used to achieve the desired result.
-
-  \image html reparenting3.png "KReparentingProxyModel and QSortFilterProxyModel working in concert to move items both left-right and up-down"
-
-  @code
-    QAbstractItemModel *model = getModel();
-
-    QSortFilterProxyModel *sorter = getSorter();
-    sorter->setSourceModel(model);
-
-    KReparentingProxyModel *reparenter = getReparenter();
-    reparenter->setSourceModel(sorter);
-
-    QTreeView *view = getView();
-    view->setModel(reparenter);
-  @endcode
-
-*/
-class KReparentingProxyModel : public QAbstractProxyModel
-{
-    Q_OBJECT
-public:
-    KReparentingProxyModel(QObject *parent = 0);
-
-    virtual ~KReparentingProxyModel();
-
-    virtual QModelIndex mapFromSource(const QModelIndex &sourceIndex) const;
-
-    virtual QModelIndex mapToSource(const QModelIndex &proxyIndex) const;
-
-    virtual void setSourceModel(QAbstractItemModel *sourceModel);
-
-    /**
-      Reimplement this to return whether @p descendant is a descendant of @p ancestor.
-    */
-    virtual bool isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const;
-
-    virtual int columnCount(const QModelIndex &parent = QModelIndex()) const;
-
-    virtual QVariant data(const QModelIndex &proxyIndex, int role = Qt::DisplayRole) const;
-
-    virtual QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
-
-    virtual QModelIndex parent(const QModelIndex &child) const;
-
-    virtual int rowCount(const QModelIndex &parent = QModelIndex()) const;
-
-    virtual bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
-
-    virtual Qt::DropActions supportedDropActions() const;
-
-protected:
-    void beginChangeRule();
-    void endChangeRule();
-
-private:
-    Q_DECLARE_PRIVATE(KReparentingProxyModel)
-    //@cond PRIVATE
-    KReparentingProxyModelPrivate *d_ptr;
-
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeInserted(const QModelIndex &, int, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsInserted(const QModelIndex &, int, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeRemoved(const QModelIndex &, int, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsRemoved(const QModelIndex &, int, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeMoved(const QModelIndex &, int, int, const QModelIndex &, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceRowsMoved(const QModelIndex &, int, int, const QModelIndex &, int))
-    Q_PRIVATE_SLOT(d_func(), void sourceModelAboutToBeReset())
-    Q_PRIVATE_SLOT(d_func(), void sourceModelReset())
-    Q_PRIVATE_SLOT(d_func(), void sourceLayoutAboutToBeChanged())
-    Q_PRIVATE_SLOT(d_func(), void sourceLayoutChanged())
-    Q_PRIVATE_SLOT(d_func(), void sourceDataChanged(const QModelIndex &, const QModelIndex &))
-
-    //@endcond
-
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/lessthanwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/lessthanwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/lessthanwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/lessthanwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,116 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "lessthanwidget.h"
-
-#include <QLabel>
-#include <QTreeView>
-#include <QVBoxLayout>
-
-ColoredTreeModel::ColoredTreeModel(QObject *parent)
-    : DynamicTreeModel(parent),
-      m_selectionModel(0),
-      m_lessThanColour(Qt::yellow),
-      m_greaterThanColour(Qt::red)
-{
-}
-
-void ColoredTreeModel::setSelectionModel(QItemSelectionModel *selectionModel)
-{
-    m_selectionModel = selectionModel;
-    connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)), SLOT(recolor()));
-}
-
-void ColoredTreeModel::recolor(const QModelIndex &parent)
-{
-    const QModelIndex topLeft = index(0, 0, parent);
-    const int _rowCount = rowCount(parent);
-    const QModelIndex bottomRight = index(_rowCount - 1, columnCount(parent) - 1, parent);
-    emit dataChanged(topLeft, bottomRight);
-
-    static const int column = 0;
-    QModelIndex idx;
-    for (int row = 0; row < _rowCount; ++row) {
-        idx = index(row, column, parent);
-        if (hasChildren(idx)) {
-            recolor(idx);
-        }
-    }
-}
-
-QVariant ColoredTreeModel::data(const QModelIndex &index, int role) const
-{
-    if (role != Qt::BackgroundRole || !m_selectionModel || m_selectionModel->selection().indexes().size() != 1) {
-        return DynamicTreeModel::data(index, role);
-    }
-
-    const QModelIndex selectedIndex = m_selectionModel->selection().indexes().first();
-
-    if (index == selectedIndex) {
-        return DynamicTreeModel::data(index, role);
-    }
-
-    if (index < selectedIndex) {
-        return m_lessThanColour;
-    }
-
-    Q_ASSERT(selectedIndex < index);
-
-    return m_greaterThanColour;
-}
-
-void LessThanWidget::insertGrid(QList<int> address)
-{
-    ModelInsertCommand *ins = new ModelInsertCommand(m_coloredTreeModel, this);
-    ins->setAncestorRowNumbers(address);
-    ins->setNumCols(5);
-    ins->setStartRow(0);
-    ins->setEndRow(5);
-    ins->doCommand();
-}
-
-LessThanWidget::LessThanWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QLabel *explanation = new QLabel(this);
-    explanation->setText(QStringLiteral("The yellow items are 'less than' the selected item according to QModelIndex::operator<().\n"
-                         "The red items are greater than the selected item (i.e, not less than and not equal)."));
-
-    m_coloredTreeModel = new ColoredTreeModel(this);
-    QTreeView *treeView = new QTreeView(this);
-    treeView->setModel(m_coloredTreeModel);
-    treeView->setSelectionBehavior(QAbstractItemView::SelectItems);
-    treeView->setSelectionMode(QTreeView::SingleSelection);
-
-    m_coloredTreeModel->setSelectionModel(treeView->selectionModel());
-
-    QVBoxLayout *layout = new QVBoxLayout(this);
-    layout->addWidget(explanation);
-    layout->addWidget(treeView);
-
-    insertGrid(QList<int>());
-    insertGrid(QList<int>() << 2);
-    insertGrid(QList<int>() << 3);
-    insertGrid(QList<int>() << 4);
-    insertGrid(QList<int>() << 3 << 2);
-    insertGrid(QList<int>() << 3 << 3);
-    insertGrid(QList<int>() << 3 << 4);
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/lessthanwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/lessthanwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/lessthanwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/lessthanwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef LESSTHANWIDGET_H
-#define LESSTHANWIDGET_H
-
-#include <QWidget>
-#include <QItemSelectionModel>
-
-#include "dynamictreemodel.h"
-
-class ColoredTreeModel : public DynamicTreeModel
-{
-    Q_OBJECT
-public:
-    ColoredTreeModel(QObject *parent = 0);
-
-    /* reimp */ QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
-
-    void setSelectionModel(QItemSelectionModel *selectionModel);
-
-protected Q_SLOTS:
-    void recolor(const QModelIndex &parent = QModelIndex());
-
-private:
-    QItemSelectionModel *m_selectionModel;
-    QColor m_lessThanColour;
-    QColor m_greaterThanColour;
-};
-
-class LessThanWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    LessThanWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-    void insertGrid(QList<int> address);
-private:
-    ColoredTreeModel *m_coloredTreeModel;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/main.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/main.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/main.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/main.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-/*
- * Copyright 2009 Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mainwindow.h"
-
-#include <qapplication.h>
-
-int main(int argc, char **argv)
-{
-    QApplication app(argc, argv);
-    MainWindow *mw = new MainWindow();
-    mw->show();
-    app.exec();
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/mainwindow.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/mainwindow.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/mainwindow.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/mainwindow.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mainwindow.h"
-
-#include <QSplitter>
-#include <QTabWidget>
-
-#include "dynamictreemodel.h"
-
-#include "breadcrumbswidget.h"
-#include "breadcrumbnavigationwidget.h"
-#include "breadcrumbdirectionwidget.h"
-#include "checkablewidget.h"
-#include "descendantpmwidget.h"
-#include "selectionpmwidget.h"
-// #include "statesaverwidget.h"
-#include "proxymodeltestwidget.h"
-#include "proxyitemselectionwidget.h"
-#ifdef QT_SCRIPT_LIB
-#include "reparentingpmwidget.h"
-#endif
-#include "recursivefilterpmwidget.h"
-#include "lessthanwidget.h"
-#include "matchcheckingwidget.h"
-#include "kidentityproxymodelwidget.h"
-#ifdef QT_QUICKWIDGETS_LIB
-#include "selectioninqmlwidget.h"
-#endif
-
-MainWindow::MainWindow() : QMainWindow()
-{
-
-    QTabWidget *tabWidget = new QTabWidget(this);
-
-    tabWidget->addTab(new MatchCheckingWidget(), QStringLiteral("Match Checking PM"));
-    tabWidget->addTab(new DescendantProxyModelWidget(), QStringLiteral("descendant PM"));
-    tabWidget->addTab(new SelectionProxyWidget(), QStringLiteral("selection PM"));
-#ifdef QT_QUICKWIDGETS_LIB
-    tabWidget->addTab(new SelectionInQmlWidget(), QStringLiteral("selection PM in QML"));
-#endif
-    tabWidget->addTab(new KIdentityProxyModelWidget(), QStringLiteral("Identity PM"));
-    tabWidget->addTab(new CheckableWidget(), QStringLiteral("Checkable"));
-    tabWidget->addTab(new BreadcrumbsWidget(), QStringLiteral("Breadcrumbs"));
-    tabWidget->addTab(new BreadcrumbNavigationWidget(), QStringLiteral("Breadcrumb Navigation"));
-    tabWidget->addTab(new BreadcrumbDirectionWidget(), QStringLiteral("Breadcrumb Direction"));
-    tabWidget->addTab(new ProxyItemSelectionWidget(), QStringLiteral("Proxy Item selection"));
-#ifdef QT_SCRIPT_LIB
-    tabWidget->addTab(new ReparentingProxyModelWidget(), QStringLiteral("reparenting PM"));
-#endif
-    tabWidget->addTab(new RecursiveFilterProxyWidget(), QStringLiteral("Recursive Filter"));
-    tabWidget->addTab(new LessThanWidget(), QStringLiteral("Less Than"));
-    tabWidget->addTab(new ProxyModelTestWidget(), QStringLiteral("Proxy Model Test"));
-//   tabWidget->addTab(new StateSaverWidget(), "State Saver Test");
-
-    setCentralWidget(tabWidget);
-}
-
-MainWindow::~MainWindow()
-{
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/mainwindow.h kitemmodels-5.17.0/autotests/proxymodeltestapp/mainwindow.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/mainwindow.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/mainwindow.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,49 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef TESTAPPLICATION_H
-#define TESTAPPLICATION_H
-
-#include <QMainWindow>
-
-class DynamicTreeModel;
-
-//@cond PRIVATE
-
-/**
- * @internal
- * Test Application for proxy models.
- */
-class MainWindow : public QMainWindow
-{
-    Q_OBJECT
-public:
-    MainWindow();
-    ~MainWindow();
-
-private:
-    DynamicTreeModel *m_rootModel;
-//   ContactsWidget* cw;
-};
-
-//@endcond
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/matchcheckingwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/matchcheckingwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/matchcheckingwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/matchcheckingwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,92 +0,0 @@
-/*
-    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "matchcheckingwidget.h"
-
-#include <QVBoxLayout>
-#include <QLineEdit>
-#include <QSplitter>
-#include <QTreeView>
-#include <QRadioButton>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include <kselectionproxymodel.h>
-
-#include <QDebug>
-
-MatchCheckingWidget::MatchCheckingWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-
-    m_lineEdit = new QLineEdit();
-
-    connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(matchChanged(QString)));
-
-    m_dynamicTreeRadioButton = new QRadioButton(QStringLiteral("Dynamic Tree Model"), this);
-    m_selectionModelRadioButton = new QRadioButton(QStringLiteral("Selection Model"), this);
-
-    layout->addWidget(m_lineEdit);
-    layout->addWidget(m_dynamicTreeRadioButton);
-    layout->addWidget(m_selectionModelRadioButton);
-
-    QSplitter *splitter = new QSplitter(this);
-    layout->addWidget(splitter);
-    DynamicTreeModel *dynamicTreeModel = new DynamicTreeModel(this);
-
-    m_dynamicTreeWidget = new DynamicTreeWidget(dynamicTreeModel, this);
-
-    splitter->addWidget(m_dynamicTreeWidget);
-
-    KSelectionProxyModel *selectionProxyModel = new KSelectionProxyModel(m_dynamicTreeWidget->treeView()->selectionModel(), this);
-    selectionProxyModel->setSourceModel(dynamicTreeModel);
-
-    m_selectionTreeView = new QTreeView(this);
-    m_selectionTreeView->setModel(selectionProxyModel);
-    splitter->addWidget(m_selectionTreeView);
-}
-
-void MatchCheckingWidget::matchChanged(const QString &matchData)
-{
-    bool ok;
-    int id = matchData.toInt(&ok);
-    qDebug() << matchData << id <<  DynamicTreeModel::DynamicTreeModelId;
-    if (!ok) {
-        return;
-    }
-
-    QModelIndexList list;
-    if (m_dynamicTreeRadioButton->isChecked()) {
-        m_dynamicTreeWidget->treeView()->selectionModel()->clearSelection();
-        list = m_dynamicTreeWidget->model()->match(m_dynamicTreeWidget->model()->index(0, 0), DynamicTreeModel::DynamicTreeModelId, id);
-        qDebug() << list;
-        Q_FOREACH (const QModelIndex &idx, list) {
-            m_dynamicTreeWidget->treeView()->selectionModel()->select(idx, QItemSelectionModel::SelectCurrent);
-        }
-    } else if (m_selectionModelRadioButton->isChecked()) {
-        m_selectionTreeView->selectionModel()->clearSelection();
-        list = m_selectionTreeView->model()->match(m_selectionTreeView->model()->index(0, 0), DynamicTreeModel::DynamicTreeModelId, id);
-        qDebug() << list;
-        Q_FOREACH (const QModelIndex &idx, list) {
-            m_selectionTreeView->selectionModel()->select(idx, QItemSelectionModel::SelectCurrent);
-        }
-    }
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/matchcheckingwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/matchcheckingwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/matchcheckingwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/matchcheckingwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,48 +0,0 @@
-/*
-    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef MATCHCHECKINGWIDGET_H343434
-#define MATCHCHECKINGWIDGET_H343434
-
-#include <QWidget>
-
-class QTreeView;
-class QLineEdit;
-class QRadioButton;
-
-class DynamicTreeWidget;
-
-class MatchCheckingWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    MatchCheckingWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-private Q_SLOTS:
-    void matchChanged(const QString &matchData);
-
-private:
-    QLineEdit *m_lineEdit;
-    DynamicTreeWidget *m_dynamicTreeWidget;
-    QTreeView *m_selectionTreeView;
-    QRadioButton *m_dynamicTreeRadioButton;
-    QRadioButton *m_selectionModelRadioButton;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/modelcommanderwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/modelcommanderwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/modelcommanderwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/modelcommanderwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,117 +0,0 @@
-/*
-    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "modelcommanderwidget.h"
-
-#include <QTreeWidget>
-#include <QPushButton>
-#include <QVBoxLayout>
-
-#include "dynamictreemodel.h"
-#include "modelcommander.h"
-#include <QMetaMethod>
-
-ModelCommanderWidget::ModelCommanderWidget(DynamicTreeModel *dynamicTreeModel, QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f),
-      m_dynamicTreeModel(dynamicTreeModel),
-      m_modelCommander(new ModelCommander(m_dynamicTreeModel, this)),
-      m_treeWidget(new QTreeWidget),
-      m_executeButton(new QPushButton(QStringLiteral("Execute")))
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-    layout->addWidget(m_treeWidget);
-    layout->addWidget(m_executeButton);
-
-    init();
-
-    connect(m_treeWidget, SIGNAL(currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)),
-            SLOT(currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)));
-
-    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(executeCurrentTest()));
-}
-
-void ModelCommanderWidget::init()
-{
-    const QMetaObject *mo = m_modelCommander->metaObject();
-    QMetaMethod mm;
-    for (int i = 0; i < mo->methodCount(); ++i) {
-        mm = mo->method(i);
-        QString signature = mm.methodSignature();
-        if (signature.startsWith(QLatin1String("init_")) && signature.endsWith(QLatin1String("(QString)"))) {
-            QTreeWidgetItem *testFunctionItem = new QTreeWidgetItem(m_treeWidget, QStringList() << signature.mid(5, signature.length() - 14));
-            m_treeWidget->addTopLevelItem(testFunctionItem);
-
-            QStringList testData;
-            QMetaObject::invokeMethod(m_modelCommander, QByteArray("execute_" + testFunctionItem->text(0).toLatin1()),
-                                      Q_RETURN_ARG(QStringList, testData),
-                                      Q_ARG(QString, QString()));
-
-            Q_FOREACH (const QString &testRun, testData) {
-              new QTreeWidgetItem(testFunctionItem, QStringList() << testRun);
-            }
-        }
-    }
-}
-
-void ModelCommanderWidget::currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous)
-{
-    Q_UNUSED(previous);
-    initTest(current);
-}
-
-void ModelCommanderWidget::executeCurrentTest()
-{
-    executeTest(m_treeWidget->currentItem());
-
-    disconnect(m_executeButton, SIGNAL(clicked(bool)), this, SLOT(executeCurrentTest()));
-    m_executeButton->setText(QStringLiteral("Reset"));
-    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(resetCurrentTest()));
-}
-
-void ModelCommanderWidget::resetCurrentTest()
-{
-    initTest(m_treeWidget->currentItem());
-
-    disconnect(m_executeButton, SIGNAL(clicked(bool)), this, SLOT(resetCurrentTest()));
-    m_executeButton->setText(QStringLiteral("Execute"));
-    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(executeCurrentTest()));
-}
-
-void ModelCommanderWidget::initTest(QTreeWidgetItem *item)
-{
-    if (!item->parent()) {
-        return;    // m_dynamicTreeModel->clear();
-    }
-    m_dynamicTreeModel->clear();
-    bool success = QMetaObject::invokeMethod(m_modelCommander, QByteArray("init_" + item->parent()->text(0).toLatin1()),
-                   Q_ARG(QString, item->text(0)));
-    Q_ASSERT(success);
-}
-
-void ModelCommanderWidget::executeTest(QTreeWidgetItem *item)
-{
-    if (!item->parent()) {
-        return;
-    }
-
-    bool success = QMetaObject::invokeMethod(m_modelCommander, QByteArray("execute_" + item->parent()->text(0).toLatin1()),
-                   Q_ARG(QString, item->text(0)));
-    Q_ASSERT(success);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/modelcommanderwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/modelcommanderwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/modelcommanderwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/modelcommanderwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,55 +0,0 @@
-/*
-    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef MODELCOMMANDERWIDGET_H
-#define MODELCOMMANDERWIDGET_H
-
-#include <QWidget>
-
-class QTreeWidget;
-class QTreeWidgetItem;
-class QPushButton;
-
-class DynamicTreeModel;
-class ModelCommander;
-
-class ModelCommanderWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    ModelCommanderWidget(DynamicTreeModel *dynamicTreeModel, QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-private Q_SLOTS:
-    void initTest(QTreeWidgetItem *item);
-    void executeTest(QTreeWidgetItem *item);
-    void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous);
-    void executeCurrentTest();
-    void resetCurrentTest();
-
-private:
-    void init();
-
-private:
-    DynamicTreeModel *m_dynamicTreeModel;
-    ModelCommander *m_modelCommander;
-    QTreeWidget *m_treeWidget;
-    QPushButton *m_executeButton;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/proxyitemselectionwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/proxyitemselectionwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/proxyitemselectionwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/proxyitemselectionwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,104 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "proxyitemselectionwidget.h"
-
-#include <QSplitter>
-#include <QHBoxLayout>
-#include <QTreeView>
-#include <QSortFilterProxyModel>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include "klinkitemselectionmodel.h"
-
-#define SON(object) object->setObjectName(#object)
-
-ProxyItemSelectionWidget::ProxyItemSelectionWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QSplitter *splitter = new QSplitter(this);
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    layout->addWidget(splitter);
-
-    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(rootModel, splitter);
-
-    dynamicTreeWidget->setInitialTree(
-        QStringLiteral("- 1"
-        "- 2"
-        "- - 3"
-        "- - - 4"
-        "- 5"
-        "- 6"
-        "- 7")
-    );
-
-    QSplitter *vSplitter = new QSplitter(Qt::Vertical, splitter);
-    QSplitter *hSplitter1 = new QSplitter(vSplitter);
-    QSplitter *hSplitter2 = new QSplitter(vSplitter);
-
-    QSortFilterProxyModel *proxy1 = new QSortFilterProxyModel(this);
-    SON(proxy1);
-    QSortFilterProxyModel *proxy2 = new QSortFilterProxyModel(this);
-    SON(proxy2);
-    QSortFilterProxyModel *proxy3 = new QSortFilterProxyModel(this);
-    SON(proxy3);
-    QSortFilterProxyModel *proxy4 = new QSortFilterProxyModel(this);
-    SON(proxy4);
-    QSortFilterProxyModel *proxy5 = new QSortFilterProxyModel(this);
-    SON(proxy5);
-
-    QTreeView *view1 = new QTreeView(hSplitter1);
-    QTreeView *view2 = new QTreeView(hSplitter1);
-    QTreeView *view3 = new QTreeView(hSplitter2);
-    QTreeView *view4 = new QTreeView(hSplitter2);
-
-    proxy1->setSourceModel(rootModel);
-    proxy2->setSourceModel(proxy1);
-    proxy3->setSourceModel(proxy2);
-
-    proxy4->setSourceModel(rootModel);
-    proxy5->setSourceModel(proxy4);
-
-    view1->setModel(proxy3);
-    view2->setModel(proxy5);
-    view3->setModel(proxy2);
-    view4->setModel(proxy1);
-
-    QItemSelectionModel *rootSelectionModel = dynamicTreeWidget->treeView()->selectionModel();
-
-    KLinkItemSelectionModel *view1SelectionModel = new KLinkItemSelectionModel(view1->model(), rootSelectionModel, this);
-    view1->setSelectionModel(view1SelectionModel);
-
-    KLinkItemSelectionModel *view2SelectionModel = new KLinkItemSelectionModel(view2->model(), view1->selectionModel(), this);
-    view2->setSelectionModel(view2SelectionModel);
-
-    KLinkItemSelectionModel *view3SelectionModel = new KLinkItemSelectionModel(view3->model(), view4->selectionModel(), this);
-    view3->setSelectionModel(view3SelectionModel);
-
-    view1->expandAll();
-    view2->expandAll();
-    view3->expandAll();
-    view4->expandAll();
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/proxyitemselectionwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/proxyitemselectionwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/proxyitemselectionwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/proxyitemselectionwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef PROXYITEMSELECTIONWIDGET_H
-#define PROXYITEMSELECTIONWIDGET_H
-
-#include <QWidget>
-
-class ProxyItemSelectionWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    ProxyItemSelectionWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/proxymodeltestwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/proxymodeltestwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/proxymodeltestwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/proxymodeltestwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,69 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "proxymodeltestwidget.h"
-
-#include <QSplitter>
-#include <QTreeView>
-#include <QHBoxLayout>
-#include <QPushButton>
-
-#include "modelcommander.h"
-#include "dynamictreemodel.h"
-#include "kselectionproxymodel.h"
-#if 0
-#include "kdescendantsproxymodel.h"
-#endif
-#include "modelcommanderwidget.h"
-
-ProxyModelTestWidget::ProxyModelTestWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-    QSplitter *splitter = new QSplitter(this);
-
-    m_rootModel = new DynamicTreeModel(this);
-
-    (void) new ModelCommanderWidget(m_rootModel, splitter);
-
-    QTreeView *rootModelView = new QTreeView(splitter);
-    rootModelView->setModel(m_rootModel);
-    rootModelView->setSelectionMode(QTreeView::ExtendedSelection);
-
-    KSelectionProxyModel *selProxyModel = new KSelectionProxyModel(rootModelView->selectionModel(), this);
-    selProxyModel->setSourceModel(m_rootModel);
-    selProxyModel->setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
-
-    QTreeView *selModelView = new QTreeView(splitter);
-    selModelView->setModel(selProxyModel);
-
-#if 0
-    KDescendantsProxyModel *descProxyModel = new KDescendantsProxyModel(this);
-    descProxyModel->setSourceModel(m_rootModel);
-    QTreeView *descProxyModelView = new QTreeView(splitter);
-    descProxyModelView ->setModel(descProxyModel);
-#endif
-
-    // Your Proxy Here?
-
-    layout->addWidget(splitter);
-
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/proxymodeltestwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/proxymodeltestwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/proxymodeltestwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/proxymodeltestwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,42 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef PROXYMODELTESTWIDGET_H
-#define PROXYMODELTESTWIDGET_H
-
-#include <QWidget>
-
-class DynamicTreeModel;
-class ModelCommander;
-class QPushButton;
-
-class ProxyModelTestWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    explicit ProxyModelTestWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-private:
-    DynamicTreeModel *m_rootModel;
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/recursivefilterpmwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/recursivefilterpmwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/recursivefilterpmwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/recursivefilterpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "recursivefilterpmwidget.h"
-
-#include <QLineEdit>
-#include <QSplitter>
-#include <QTreeView>
-#include <QHBoxLayout>
-#include <QLabel>
-#include <QPlainTextEdit>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-
-RecursiveFilterProxyWidget::RecursiveFilterProxyWidget(QWidget *parent)
-    : QWidget(parent),
-      m_lineEdit(new QLineEdit(this)),
-      m_label(new QLabel(this))
-{
-    m_label->setText(QStringLiteral("Matching filter re: "));
-    m_lineEdit->setText(QStringLiteral("12|13|37|4"));
-
-    QHBoxLayout *hLayout = new QHBoxLayout();
-    QVBoxLayout *vLayout = new QVBoxLayout(this);
-    QSplitter *splitter = new QSplitter(this);
-
-    m_rootModel = new DynamicTreeModel(this);
-    m_recursive = new KRecursiveFilterProxyModel(this);
-    m_recursiveSubclass = new KRecursiveFilterProxyModelSubclass(this);
-
-    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(m_rootModel, splitter);
-
-    QTreeView *recursiveView = new QTreeView(splitter);
-    recursiveView->setModel(m_recursive);
-    QTreeView *recursiveSubclassView = new QTreeView(splitter);
-    recursiveSubclassView->setModel(m_recursiveSubclass);
-
-    hLayout->addWidget(m_label);
-    hLayout->addWidget(m_lineEdit);
-
-    vLayout->addLayout(hLayout);
-    vLayout->addWidget(splitter);
-
-    connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(reset()));
-
-    connect(m_lineEdit, SIGNAL(textChanged(QString)), recursiveView, SLOT(expandAll()));
-    connect(m_lineEdit, SIGNAL(textChanged(QString)), recursiveSubclassView, SLOT(expandAll()));
-    connect(dynamicTreeWidget->textEdit(), SIGNAL(textChanged()), recursiveView, SLOT(expandAll()));
-    connect(dynamicTreeWidget->textEdit(), SIGNAL(textChanged()), recursiveSubclassView, SLOT(expandAll()));
-    connect(m_recursive, SIGNAL(modelReset()), recursiveView, SLOT(expandAll()), Qt::QueuedConnection);
-    connect(m_recursiveSubclass, SIGNAL(modelReset()), recursiveSubclassView, SLOT(expandAll()), Qt::QueuedConnection);
-
-    m_recursive->setSourceModel(m_rootModel);
-    m_recursiveSubclass->setSourceModel(m_rootModel);
-
-    reset();
-}
-
-void RecursiveFilterProxyWidget::reset()
-{
-    m_recursive->setFilterRegExp(m_lineEdit->text());
-    m_recursiveSubclass->setRegExp(QRegExp(m_lineEdit->text()));
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/recursivefilterpmwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/recursivefilterpmwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/recursivefilterpmwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/recursivefilterpmwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef RECURSIVE_PM_WIDGET_H
-#define RECURSIVE_PM_WIDGET_H
-
-#include <QWidget>
-#include <QRegExp>
-
-#include "krecursivefilterproxymodel.h"
-
-class QTreeView;
-class QLineEdit;
-class QLabel;
-class QPushButton;
-
-class DynamicTreeModel;
-
-class KRecursiveFilterProxyModelSubclass : public KRecursiveFilterProxyModel
-{
-    Q_OBJECT
-public:
-    KRecursiveFilterProxyModelSubclass(QObject *parent = 0)
-        : KRecursiveFilterProxyModel(parent)
-    {
-
-    }
-
-    /* reimp */ bool acceptRow(int sourceRow, const QModelIndex &parent_index) const
-    {
-        static const int column = 0;
-        QModelIndex srcIndex = sourceModel()->index(sourceRow, column, parent_index);
-        return srcIndex.data().toString().contains(m_regExp);
-    }
-
-    void setRegExp(const QRegExp &re)
-    {
-        layoutAboutToBeChanged();
-        m_regExp = re;
-        invalidateFilter();
-        layoutChanged();
-    }
-
-private:
-    QRegExp m_regExp;
-};
-
-class RecursiveFilterProxyWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    RecursiveFilterProxyWidget(QWidget *parent = 0);
-
-protected Q_SLOTS:
-    void reset();
-
-private:
-    DynamicTreeModel *m_rootModel;
-    KRecursiveFilterProxyModel *m_recursive;
-    KRecursiveFilterProxyModelSubclass *m_recursiveSubclass;
-
-    QLineEdit *m_lineEdit;
-    QLabel *m_label;
-};
-
-#endif
-
Binary files kitemmodels-5.16.0/autotests/proxymodeltestapp/reparenting1.png and kitemmodels-5.17.0/autotests/proxymodeltestapp/reparenting1.png differ
Binary files kitemmodels-5.16.0/autotests/proxymodeltestapp/reparenting2.png and kitemmodels-5.17.0/autotests/proxymodeltestapp/reparenting2.png differ
Binary files kitemmodels-5.16.0/autotests/proxymodeltestapp/reparenting3.png and kitemmodels-5.17.0/autotests/proxymodeltestapp/reparenting3.png differ
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/reparentingpmwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/reparentingpmwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/reparentingpmwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/reparentingpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "reparentingpmwidget.h"
-
-#include <QTreeView>
-#include <QSplitter>
-#include <QVBoxLayout>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include "scriptablereparentingwidget.h"
-
-ReparentingProxyModelWidget::ReparentingProxyModelWidget(QWidget *parent): QWidget(parent)
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-
-    QSplitter *vSplitter = new QSplitter(this);
-    layout->addWidget(vSplitter);
-
-    m_rootModel = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(m_rootModel, vSplitter);
-    dynamicTreeWidget->setInitialTree(
-        QStringLiteral("- 1"
-        "- 2"
-        "- - 3"
-        "- - - 4"
-        "- 5"
-        "- 6"
-        "- 7")
-    );
-
-    new ScriptableReparentingWidget(m_rootModel, vSplitter);
-
-    setLayout(layout);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/reparentingpmwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/reparentingpmwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/reparentingpmwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/reparentingpmwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef REPARENTINGPM_WIDGET_H
-#define REPARENTINGPM_WIDGET_H
-
-#include <QWidget>
-
-#include "kreparentingproxymodel.h"
-
-class DynamicTreeModel;
-
-class ReparentingProxyModelWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    ReparentingProxyModelWidget(QWidget *parent = 0);
-
-private:
-    DynamicTreeModel *m_rootModel;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/scriptablereparentingwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/scriptablereparentingwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/scriptablereparentingwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/scriptablereparentingwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,143 +0,0 @@
-/*
-    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "scriptablereparentingwidget.h"
-
-#include <QPlainTextEdit>
-#include <QTreeView>
-#include <QVBoxLayout>
-#include <QScriptEngine>
-
-#include <QDebug>
-#include <QLabel>
-#include <QSplitter>
-#include <QComboBox>
-
-static const char *const threadingFunctionNames[] = {
-    "None",
-    "Flat List",
-    "Straight Line Tree",
-    "Dragon Teeth 1",
-    "Dragon Teeth 2",
-    "Specified parents 1"
-};
-
-static const char *const threadingFunctionBodies[] = {
-    "",
-    "return false;",
-    "return true;",
-    "if (descendant % 3 ==1)\n"
-    "    return false;\n"
-    "return true;",
-    "if (descendant % 4 ==1)\n"
-    "    return false;\n"
-    "return true;",
-    "var threaddata = [[1, 2, 3, 4],\n"
-    "                  [13, 14, 15],\n"
-    "                  [13, 16, 17],\n"
-    "                  [5, 6]];\n"
-    "\n"
-    "for (var i = 0; i < threaddata.length; ++i)\n"
-    "{\n"
-    "  var a = threaddata[i].indexOf(ancestor);\n"
-    "  var d = threaddata[i].indexOf(descendant);\n"
-    "  if (a >= 0 && d >= 0)\n"
-    "    return a < d;\n"
-    "}\n"
-    "return false;"
-};
-
-ScriptableReparentingProxyModel::ScriptableReparentingProxyModel(QObject *parent)
-    : KReparentingProxyModel(parent),
-      m_scriptEngine(new QScriptEngine(this))
-{
-}
-
-bool ScriptableReparentingProxyModel::isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const
-{
-    if (!m_implementationFunction.isValid()) {
-        return KReparentingProxyModel::isDescendantOf(ancestor, descendant);
-    }
-
-    QScriptValueList arguments = QScriptValueList() << ancestor.data().toInt() << descendant.data().toInt();
-    QScriptValue returnValue = m_implementationFunction.call(QScriptValue(), arguments);
-
-    if (!returnValue.isBool()) {
-        return KReparentingProxyModel::isDescendantOf(ancestor, descendant);
-    }
-
-    return returnValue.toBool();
-}
-
-void ScriptableReparentingProxyModel::setImplementation(const QString &implementation)
-{
-    beginChangeRule();
-    m_implementationFunction = m_scriptEngine->evaluate(implementation);
-    m_implementationFunction = m_scriptEngine->globalObject().property(QStringLiteral("isDescendantOf"));
-    endChangeRule();
-}
-
-ScriptableReparentingWidget::ScriptableReparentingWidget(QAbstractItemModel *rootModel, QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f),
-      m_reparentingProxyModel(new ScriptableReparentingProxyModel(this))
-{
-    QVBoxLayout *mainLayout = new QVBoxLayout(this);
-    QSplitter *splitter = new QSplitter(Qt::Vertical, this);
-    mainLayout->addWidget(splitter);
-
-    m_treeView = new QTreeView(splitter);
-    QWidget *container = new QWidget(splitter);
-    QVBoxLayout *layout = new QVBoxLayout(container);
-    m_textEdit = new QPlainTextEdit(container);
-    m_textEdit->setFont(QFont(QStringLiteral("monospace")));
-
-    m_comboBox = new QComboBox(container);
-    for (int i = 0; i < int(sizeof threadingFunctionNames / sizeof * threadingFunctionNames); ++i) {
-        m_comboBox->addItem(*(threadingFunctionNames + i), *(threadingFunctionBodies + i));
-    }
-    layout->addWidget(m_comboBox);
-    connect(m_comboBox, SIGNAL(currentIndexChanged(int)), SLOT(setExampleFunction(int)));
-
-    layout->addWidget(new QLabel(QStringLiteral("function isDescendantOf (ancestor, descendant) {"), container));
-    QHBoxLayout *indentedLayout = new QHBoxLayout(container);
-    indentedLayout->addSpacing(30);
-    indentedLayout->addWidget(m_textEdit);
-    layout->addLayout(indentedLayout);
-    layout->addWidget(new QLabel(QStringLiteral("}"), container));
-
-    m_reparentingProxyModel->setSourceModel(rootModel);
-    m_treeView->setModel(m_reparentingProxyModel);
-
-    splitter->setStretchFactor(0, 100);
-
-    connect(m_textEdit, SIGNAL(textChanged()), SLOT(textChanged()));
-    textChanged();
-}
-
-void ScriptableReparentingWidget::setExampleFunction(int index)
-{
-    m_textEdit->setPlainText(m_comboBox->itemData(index).toString());
-}
-
-void ScriptableReparentingWidget::textChanged()
-{
-    m_reparentingProxyModel->setImplementation("function isDescendantOf (ancestor, descendant) { " + m_textEdit->toPlainText()  + " }");
-    m_treeView->expandAll();
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/scriptablereparentingwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/scriptablereparentingwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/scriptablereparentingwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/scriptablereparentingwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
-/*
-    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef SCRIPTABLEREPARENTINGWIDGET_H
-#define SCRIPTABLEREPARENTINGWIDGET_H
-
-#include <QWidget>
-#include <QScriptValue>
-
-#include "kreparentingproxymodel.h"
-
-class QComboBox;
-class QTreeView;
-class QPlainTextEdit;
-class QScriptEngine;
-
-class ScriptableReparentingProxyModel : public KReparentingProxyModel
-{
-    Q_OBJECT
-public:
-    ScriptableReparentingProxyModel(QObject *parent = 0);
-
-    /* reimp */ bool isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const;
-
-    void setImplementation(const QString &implementation);
-
-private:
-    QScriptEngine *m_scriptEngine;
-    mutable QScriptValue m_implementationFunction;
-};
-
-class ScriptableReparentingWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    ScriptableReparentingWidget(QAbstractItemModel *rootModel, QWidget *parent = 0, Qt::WindowFlags f = 0);
-
-private Q_SLOTS:
-    void textChanged();
-    void setExampleFunction(int index);
-
-private:
-    QComboBox *m_comboBox;
-    ScriptableReparentingProxyModel *m_reparentingProxyModel;
-    QTreeView *m_treeView;
-    QPlainTextEdit *m_textEdit;
-};
-
-#endif // SCRIPTABLEREPARENTINGWIDGET_H
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/selectioninqmlwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/selectioninqmlwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/selectioninqmlwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/selectioninqmlwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2015 Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "selectioninqmlwidget.h"
-
-#include <QSplitter>
-#include <QTreeView>
-#include <QQuickWidget>
-#include <QHBoxLayout>
-#include <QLabel>
-#include <QtQml>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include "kselectionproxymodel.h"
-
-SelectionInQmlWidget::SelectionInQmlWidget(QWidget *parent): QWidget(parent)
-{
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *splitter = new QSplitter(this);
-    layout->addWidget(splitter);
-
-    m_rootModel = new DynamicTreeModel(this);
-
-    new DynamicTreeWidget(m_rootModel, splitter);
-
-    QTreeView *selectionTree = new QTreeView(splitter);
-    selectionTree->setSelectionMode(QAbstractItemView::ExtendedSelection);
-    selectionTree->setModel(m_rootModel);
-    selectionTree->expandAll();
-
-    qmlRegisterType<KSelectionProxyModel>("KF5ItemModels", 1, 0, "SelectionProxyModel");
-
-    QQuickWidget *quickView = new QQuickWidget(splitter);
-
-    quickView->engine()->rootContext()->setContextProperty(QStringLiteral("_model"), m_rootModel);
-    quickView->engine()->rootContext()->setContextProperty(QStringLiteral("_selectionModel"), selectionTree->selectionModel());
-
-    quickView->setSource(QUrl(SRC_DIR "/selection.qml"));
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/selectioninqmlwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/selectioninqmlwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/selectioninqmlwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/selectioninqmlwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2015 Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef SELECTIONINQML_WIDGET_H
-#define SELECTIONINQML_WIDGET_H
-
-#include <QWidget>
-
-class QTreeView;
-
-class DynamicTreeModel;
-
-class SelectionInQmlWidget : public QWidget
-{
-public:
-    SelectionInQmlWidget(QWidget *parent = 0);
-
-private:
-    DynamicTreeModel *m_rootModel;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/selectionpmwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/selectionpmwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/selectionpmwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/selectionpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,163 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "selectionpmwidget.h"
-
-#include <QSplitter>
-#include <QTreeView>
-#include <QHBoxLayout>
-#include <QLabel>
-
-#include "dynamictreemodel.h"
-#include "dynamictreewidget.h"
-#include "kselectionproxymodel.h"
-
-SelectionProxyWidget::SelectionProxyWidget(QWidget *parent): QWidget(parent)
-{
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    QSplitter *splitter = new QSplitter(this);
-    layout->addWidget(splitter);
-
-    m_rootModel = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *dynTreeWidget = new DynamicTreeWidget(m_rootModel, splitter);
-
-    dynTreeWidget->setInitialTree(
-        QStringLiteral("- 1"
-        "- 2"
-        "- - 3"
-        "- - 3"
-        "- - - 4"
-        "- - - 4"
-        "- - - - 4"
-        "- - 4"
-        "- - 5"
-        "- - - 4"
-        "- - - - 4"
-        "- - 5"
-        "- 6"
-        "- 7"
-        "- - 8"
-        "- - - 9"
-        "- - - 10"
-        "- - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - - - - 9"
-        "- - - - - - - - 10"
-        "- - - - - - - - 9"
-        "- - - - - - - 10"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 9"
-        "- - - - - 10"
-        "- - - - - - 9"
-        "- - - - - - 10"
-        "- - - - 10"
-        "- - 11"
-        "- - 12"
-        "- 13"
-        "- 14"
-        "- 15"
-        "- - 16"
-        "- - - 17"
-        "- - - 18"
-        "- 19"
-        "- 20"
-        "- 21"));
-
-    QTreeView *selectionTree = createLabelledView(QStringLiteral("Selection"), splitter);
-    selectionTree->setSelectionMode(QAbstractItemView::ExtendedSelection);
-    selectionTree->setModel(m_rootModel);
-    selectionTree->expandAll();
-
-#define SUBTREES
-#define SUBTREEROOTS
-#define SUBTREESWITHOUTROOTS
-#define EXACTSELECTION
-#define CHILDRENOFEXACTSELECTION
-
-#ifdef SUBTREES
-    KSelectionProxyModel *selectedBranchesModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
-    selectedBranchesModel->setSourceModel(m_rootModel);
-    selectedBranchesModel->setFilterBehavior(KSelectionProxyModel::SubTrees);
-
-    QTreeView *selectedBranchesView = createLabelledView(QStringLiteral("SubTrees"), splitter);
-    selectedBranchesView->setModel(selectedBranchesModel);
-#endif
-
-#ifdef SUBTREEROOTS
-    KSelectionProxyModel *selectedBranchesRootsModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
-    selectedBranchesRootsModel->setSourceModel(m_rootModel);
-    selectedBranchesRootsModel->setFilterBehavior(KSelectionProxyModel::SubTreeRoots);
-
-    QTreeView *selectedBranchesRootsView = createLabelledView(QStringLiteral("SubTreeRoots"), splitter);
-    selectedBranchesRootsView->setModel(selectedBranchesRootsModel);
-#endif
-
-#ifdef SUBTREESWITHOUTROOTS
-    KSelectionProxyModel *selectedBranchesChildrenModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
-    selectedBranchesChildrenModel->setSourceModel(m_rootModel);
-    selectedBranchesChildrenModel->setFilterBehavior(KSelectionProxyModel::SubTreesWithoutRoots);
-
-    QTreeView *selectedBranchesChildrenView = createLabelledView(QStringLiteral("SubTreesWithoutRoots"), splitter);
-    selectedBranchesChildrenView->setModel(selectedBranchesChildrenModel);
-#endif
-
-#ifdef EXACTSELECTION
-    KSelectionProxyModel *onlySelectedModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
-    onlySelectedModel->setSourceModel(m_rootModel);
-    onlySelectedModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
-
-    QTreeView *onlySelectedView = createLabelledView(QStringLiteral("ExactSelection"), splitter);
-    onlySelectedView->setModel(onlySelectedModel);
-#endif
-
-#ifdef CHILDRENOFEXACTSELECTION
-    KSelectionProxyModel *onlySelectedChildrenModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
-    onlySelectedChildrenModel->setSourceModel(m_rootModel);
-    onlySelectedChildrenModel->setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
-
-    QTreeView *onlySelectedChildrenView = createLabelledView(QStringLiteral("ChildrenOfExactSelection"), splitter);
-    onlySelectedChildrenView->setModel(onlySelectedChildrenModel);
-#endif
-}
-
-QTreeView *SelectionProxyWidget::createLabelledView(const QString &labelText, QWidget *parent)
-{
-    QWidget *labelledTreeWidget = new QWidget(parent);
-    QVBoxLayout *layout = new QVBoxLayout(labelledTreeWidget);
-
-    QLabel *label = new QLabel(labelText, labelledTreeWidget);
-    QTreeView *treeview = new QTreeView(labelledTreeWidget);
-
-    layout->addWidget(label);
-    layout->addWidget(treeview);
-    return treeview;
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/selectionpmwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/selectionpmwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/selectionpmwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/selectionpmwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,45 +0,0 @@
-/*
- * This file is part of the proxy model test suite.
- *
- * Copyright 2009  Stephen Kelly <steveire@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef SELECTION_PM_WIDGET_H
-#define SELECTION_PM_WIDGET_H
-
-#include <QWidget>
-
-class QTreeView;
-
-class DynamicTreeModel;
-
-class SelectionProxyWidget : public QWidget
-{
-public:
-    SelectionProxyWidget(QWidget *parent = 0);
-
-protected:
-    QTreeView *createLabelledView(const QString &labelText, QWidget *parent);
-
-private:
-    DynamicTreeModel *m_rootModel;
-
-};
-
-#endif
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/selection.qml kitemmodels-5.17.0/autotests/proxymodeltestapp/selection.qml
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/selection.qml	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/selection.qml	1970-01-01 08:00:00.000000000 +0800
@@ -1,138 +0,0 @@
-/*
-    Copyright (c) 2015 Stephen Kelly <steveire@gmail.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-import QtQuick 2.4
-
-import KF5ItemModels 1.0
-
-Item {
-  width: 600
-  height: 500
-
-  Component {
-    id: labelledSelectionView
-
-    Column {
-      id: column
-      width : 200
-      property var filterBehavior
-      property var filterBehaviorName
-      Text {
-        id: label
-        width: parent.width
-        horizontalAlignment: Text.AlignHCenter
-        font.bold: true
-        font.pointSize: 10
-        text: column.filterBehaviorName
-      }
-      SelectionProxyModel {
-        id: selection
-        sourceModel: _model
-        selectionModel: _selectionModel
-        filterBehavior: column.filterBehavior
-      }
-      Rectangle {
-        height: parent.height - label.height
-        width: parent.width
-        border.width : 1
-        border.color: "black"
-        radius: 5
-        ListView {
-          width: parent.width
-          height: parent.height
-          y: 5
-          x: 5
-          model: selection
-          delegate: Rectangle {
-            x: 1
-            y: 1
-            height: 30
-            width: 100
-            color: model.index % 2 == 0 ? "lightsteelblue" : "white"
-            Text {
-              x: 5
-              y: 5
-              text: model.display
-            }
-          }
-        }
-      }
-    }
-  }
-
-  Loader {
-    id: loaderExactSelection
-    width : 200
-    height: 300
-    sourceComponent: labelledSelectionView
-    Binding {
-      target: loaderExactSelection.item
-      property: "filterBehavior"
-      value: SelectionProxyModel.ExactSelection
-      when: loaderExactSelection.status == Loader.Ready
-    }
-    Binding {
-      target: loaderExactSelection.item
-      property: "filterBehaviorName"
-      value: "ExactSelection"
-      when: loaderExactSelection.status == Loader.Ready
-    }
-  }
-
-  Loader {
-    id: loaderChildrenOfExactSelection
-    x: 200
-    width : 200
-    height: 300
-    sourceComponent: labelledSelectionView
-    Binding {
-      target: loaderChildrenOfExactSelection.item
-      property: "filterBehavior"
-      value: SelectionProxyModel.ChildrenOfExactSelection
-      when: loaderChildrenOfExactSelection.status == Loader.Ready
-    }
-    Binding {
-      target: loaderChildrenOfExactSelection.item
-      property: "filterBehaviorName"
-      value: "ChildrenOfExactSelection"
-      when: loaderChildrenOfExactSelection.status == Loader.Ready
-    }
-  }
-
-  Loader {
-    id: loaderSubTreeRoots
-    x: 400
-    width : 200
-    height: 300
-    sourceComponent: labelledSelectionView
-    Binding {
-      target: loaderSubTreeRoots.item
-      property: "filterBehavior"
-      value: SelectionProxyModel.SubTreeRoots
-      when: loaderSubTreeRoots.status == Loader.Ready
-    }
-    Binding {
-      target: loaderSubTreeRoots.item
-      property: "filterBehaviorName"
-      value: "SubTreeRoots"
-      when: loaderSubTreeRoots.status == Loader.Ready
-    }
-  }
-
-}
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/statesaverwidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestapp/statesaverwidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/statesaverwidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/statesaverwidget.cpp	1970-01-01 08:00:00.000000000 +0800
@@ -1,99 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#include "statesaverwidget.h"
-
-#include <QSplitter>
-#include <QBoxLayout>
-#include <QTreeView>
-#include <QApplication>
-
-#include <kconfig.h>
-#include <kconfiggroup.h>
-#include <ksharedconfig.h>
-
-#include "dynamictreewidget.h"
-#include "dynamictreemodel.h"
-
-QModelIndex DynamicTreeStateSaver::indexFromConfigString(const QAbstractItemModel *model, const QString &key) const
-{
-    QModelIndexList list = model->match(model->index(0, 0), DynamicTreeModel::DynamicTreeModelId, key.toInt(), 1, Qt::MatchRecursive);
-    if (list.isEmpty()) {
-        return QModelIndex();
-    }
-    return list.first();
-}
-
-QString DynamicTreeStateSaver::indexToConfigString(const QModelIndex &index) const
-{
-    return index.data(DynamicTreeModel::DynamicTreeModelId).toString();
-}
-
-DynamicTreeStateSaver::DynamicTreeStateSaver(QObject *parent)
-    : KViewStateSaver(parent)
-{
-}
-
-StateSaverWidget::StateSaverWidget(QWidget *parent, Qt::WindowFlags f)
-    : QWidget(parent, f)
-{
-    QSplitter *splitter = new QSplitter(this);
-    QHBoxLayout *layout = new QHBoxLayout(this);
-    layout->addWidget(splitter);
-
-    DynamicTreeModel *model = new DynamicTreeModel(this);
-
-    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(model, splitter);
-
-    m_view = new QTreeView(splitter);
-    m_view->setSelectionMode(QAbstractItemView::ExtendedSelection);
-    m_view->setModel(model);
-
-    connect(model, SIGNAL(modelAboutToBeReset()), SLOT(saveState()));
-    connect(model, SIGNAL(modelReset()), SLOT(restoreState()));
-    connect(qApp, SIGNAL(aboutToQuit()), SLOT(saveState()));
-
-    restoreState();
-}
-
-StateSaverWidget::~StateSaverWidget()
-{
-    saveState();
-}
-
-void StateSaverWidget::saveState()
-{
-    DynamicTreeStateSaver saver;
-    saver.setView(m_view);
-
-    KConfigGroup cfg(KSharedConfig::openConfig(), "ExampleViewState");
-    saver.saveState(cfg);
-    cfg.sync();
-}
-
-void StateSaverWidget::restoreState()
-{
-    DynamicTreeStateSaver *saver = new DynamicTreeStateSaver;
-    saver->setView(m_view);
-    KConfigGroup cfg(KSharedConfig::openConfig(), "ExampleViewState");
-    saver->restoreState(cfg);
-}
-
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestapp/statesaverwidget.h kitemmodels-5.17.0/autotests/proxymodeltestapp/statesaverwidget.h
--- kitemmodels-5.16.0/autotests/proxymodeltestapp/statesaverwidget.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestapp/statesaverwidget.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-/*
-    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
-        a KDAB Group company, info@kdab.net,
-        author Stephen Kelly <stephen@kdab.com>
-
-    This library is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Library General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or (at your
-    option) any later version.
-
-    This library is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
-    License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to the
-    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301, USA.
-*/
-
-#ifndef STATESAVERWIDGET_H
-#define STATESAVERWIDGET_H
-
-#include <QWidget>
-
-#include "kviewstatesaver.h"
-
-class QTreeView;
-
-class DynamicTreeWidget;
-
-class DynamicTreeStateSaver : public KViewStateSaver
-{
-    Q_OBJECT
-public:
-    DynamicTreeStateSaver(QObject *parent = 0);
-
-protected:
-    /* reimp */ QModelIndex indexFromConfigString(const QAbstractItemModel *model, const QString &key) const;
-    /* reimp */ QString indexToConfigString(const QModelIndex &index) const;
-};
-
-class StateSaverWidget : public QWidget
-{
-    Q_OBJECT
-public:
-    StateSaverWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
-    ~StateSaverWidget();
-
-private Q_SLOTS:
-    void saveState();
-    void restoreState();
-
-private:
-    DynamicTreeWidget *m_dynamicTreeWidget;
-    QTreeView *m_view;
-};
-
-#endif
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestsuite/dynamictreemodel.h kitemmodels-5.17.0/autotests/proxymodeltestsuite/dynamictreemodel.h
--- kitemmodels-5.16.0/autotests/proxymodeltestsuite/dynamictreemodel.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestsuite/dynamictreemodel.h	2015-12-06 22:07:13.000000000 +0800
@@ -83,7 +83,7 @@
     qint64 newId()
     {
         return nextId++;
-    };
+    }
 
     QModelIndex m_nextParentIndex;
     int m_nextRow;
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestsuite/dynamictreewidget.cpp kitemmodels-5.17.0/autotests/proxymodeltestsuite/dynamictreewidget.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestsuite/dynamictreewidget.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestsuite/dynamictreewidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -245,7 +245,7 @@
 
     connect(tabWidget, SIGNAL(currentChanged(int)), SLOT(currentChanged(int)));
     stringToModel(
-        QStringLiteral(" - 1"
+        QString(" - 1"
         " - 2"
         " - - 3"
         " - - 4"
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestsuite/modelcommander.cpp kitemmodels-5.17.0/autotests/proxymodeltestsuite/modelcommander.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestsuite/modelcommander.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestsuite/modelcommander.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -47,7 +47,7 @@
     } else if (dataTag == testData.at(2)) {
         // Insert 5 items, some of which are parents
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
@@ -138,7 +138,7 @@
     ModelInsertCommand *ins = new ModelInsertCommand(m_model, this);
     ins->setStartRow(0);
     ins->interpret(
-        QStringLiteral(" - 1"
+        QString(" - 1"
         " - 2"
         " - - 3"
         " - - 4"
@@ -458,7 +458,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(0);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - - - 3"
             " - - - - 4"
@@ -469,7 +469,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(m_model->rowCount());
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - - - 3"
             " - - - - 4"
@@ -480,7 +480,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(4);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - - - 3"
             " - - - - 4"
@@ -491,7 +491,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(0);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
@@ -507,7 +507,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(m_model->rowCount());
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
@@ -523,7 +523,7 @@
         ins->setAncestorRowNumbers(rowAncestors);
         ins->setStartRow(4);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
@@ -549,7 +549,7 @@
         ins->setAncestorRowNumbers(rowAncestors << 0);
         ins->setStartRow(0);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
@@ -575,7 +575,7 @@
         ins->setAncestorRowNumbers(rowAncestors << 9);
         ins->setStartRow(0);
         ins->interpret(
-            QStringLiteral(" - 1"
+            QString(" - 1"
             " - - 2"
             " - 3"
             " - 4"
diff -Nur kitemmodels-5.16.0/autotests/proxymodeltestsuite/proxymodeltest.cpp kitemmodels-5.17.0/autotests/proxymodeltestsuite/proxymodeltest.cpp
--- kitemmodels-5.16.0/autotests/proxymodeltestsuite/proxymodeltest.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/proxymodeltestsuite/proxymodeltest.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -303,7 +303,7 @@
     ModelInsertCommand *ins = new ModelInsertCommand(m_rootModel, this);
     ins->setStartRow(0);
     ins->interpret(
-        QStringLiteral("- 1"
+        QString("- 1"
         "- 2"
         "- - 3"
         "- - 4"
@@ -334,7 +334,7 @@
     ModelInsertCommand *ins = new ModelInsertCommand(rootModel, this);
     ins->setStartRow(0);
     ins->interpret(
-        QStringLiteral(" - 1"
+        QString(" - 1"
         " - 1"
         " - - 1"
         " - 1"
@@ -684,34 +684,24 @@
     switch (var.type()) {
     case QVariant::Int:
         return qHash(var.toInt());
-        break;
     case QVariant::UInt:
         return qHash(var.toUInt());
-        break;
     case QVariant::Bool:
         return qHash(var.toUInt());
-        break;
     case QVariant::Double:
         return qHash(var.toUInt());
-        break;
     case QVariant::LongLong:
         return qHash(var.toLongLong());
-        break;
     case QVariant::ULongLong:
         return qHash(var.toULongLong());
-        break;
     case QVariant::String:
         return qHash(var.toString());
-        break;
     case QVariant::Char:
         return qHash(var.toChar());
-        break;
     case QVariant::StringList:
         return qHash(var.toString());
-        break;
     case QVariant::ByteArray:
         return qHash(var.toByteArray());
-        break;
     case QVariant::Date:
     case QVariant::Time:
     case QVariant::DateTime:
@@ -719,7 +709,6 @@
     case QVariant::Locale:
     case QVariant::RegExp:
         return qHash(var.toString());
-        break;
     case QVariant::Map:
     case QVariant::List:
     case QVariant::BitArray:
diff -Nur kitemmodels-5.16.0/autotests/test_model_helpers.h kitemmodels-5.17.0/autotests/test_model_helpers.h
--- kitemmodels-5.16.0/autotests/test_model_helpers.h	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/autotests/test_model_helpers.h	2015-12-06 22:07:13.000000000 +0800
@@ -19,6 +19,7 @@
 */
 
 #include <QString>
+#include <QStandardItem>
 
 namespace TestModelHelpers
 {
diff -Nur kitemmodels-5.16.0/CMakeLists.txt kitemmodels-5.17.0/CMakeLists.txt
--- kitemmodels-5.16.0/CMakeLists.txt	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/CMakeLists.txt	2015-12-06 22:07:13.000000000 +0800
@@ -34,6 +34,7 @@
 add_subdirectory(src)
 if (BUILD_TESTING)
     add_subdirectory(autotests)
+    add_subdirectory(tests)
 endif()
 
 
diff -Nur kitemmodels-5.16.0/src/krecursivefilterproxymodel.cpp kitemmodels-5.17.0/src/krecursivefilterproxymodel.cpp
--- kitemmodels-5.16.0/src/krecursivefilterproxymodel.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/src/krecursivefilterproxymodel.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -336,26 +336,28 @@
 
 void KRecursiveFilterProxyModel::setSourceModel(QAbstractItemModel *model)
 {
-    // Standard disconnect.
-    if (passRolesToDataChanged()) {
-        disconnect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
-                   this, SLOT(sourceDataChanged(QModelIndex,QModelIndex,QVector<int>)));
-    } else {
-        disconnect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
-                   this, SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
-    }
-
-    disconnect(model, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
-               this, SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
+    // Standard disconnect of the previous source model, if present
+    if (sourceModel()) {
+        if (passRolesToDataChanged()) {
+            disconnect(sourceModel(), SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
+                    this, SLOT(sourceDataChanged(QModelIndex,QModelIndex,QVector<int>)));
+        } else {
+            disconnect(sourceModel(), SIGNAL(dataChanged(QModelIndex,QModelIndex)),
+                    this, SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
+        }
+
+        disconnect(sourceModel(), SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
+                this, SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
 
-    disconnect(model, SIGNAL(rowsInserted(QModelIndex,int,int)),
-               this, SLOT(sourceRowsInserted(QModelIndex,int,int)));
+        disconnect(sourceModel(), SIGNAL(rowsInserted(QModelIndex,int,int)),
+                this, SLOT(sourceRowsInserted(QModelIndex,int,int)));
 
-    disconnect(model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-               this, SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
+        disconnect(sourceModel(), SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+                this, SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
 
-    disconnect(model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
-               this, SLOT(sourceRowsRemoved(QModelIndex,int,int)));
+        disconnect(sourceModel(), SIGNAL(rowsRemoved(QModelIndex,int,int)),
+                this, SLOT(sourceRowsRemoved(QModelIndex,int,int)));
+    }
 
     QSortFilterProxyModel::setSourceModel(model);
 
@@ -423,6 +425,10 @@
     // to see if H matches the filter (which it now does as L now exists).
     // That is done in sourceRowsInserted.
 
+    if (!model) {
+        return;
+    }
+
     if (passRolesToDataChanged()) {
         disconnect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                    this, SLOT(_q_sourceDataChanged(QModelIndex,QModelIndex,QVector<int>)));
diff -Nur kitemmodels-5.16.0/src/kselectionproxymodel.cpp kitemmodels-5.17.0/src/kselectionproxymodel.cpp
--- kitemmodels-5.16.0/src/kselectionproxymodel.cpp	2015-11-08 19:09:57.000000000 +0800
+++ kitemmodels-5.17.0/src/kselectionproxymodel.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -34,9 +34,6 @@
 typedef KBiHash<void *, QModelIndex> ParentMapping;
 typedef KHash2Map<QPersistentModelIndex, int> SourceIndexProxyRowMapping;
 
-#define KDO(object) qDebug() << #object << object
-#define SON(object) object->setObjectName(#object)
-
 /**
   Return true if @p idx is a descendant of one of the indexes in @p list.
   Note that this returns false if @p list contains @p idx.
@@ -394,7 +391,7 @@
     return result;
 }
 
-QItemSelection kNormalizeSelection(QItemSelection selection)
+static QItemSelection kNormalizeSelection(QItemSelection selection)
 {
     if (selection.size() <= 1) {
         return selection;
@@ -2439,16 +2436,7 @@
 
 int KSelectionProxyModel::columnCount(const QModelIndex &index) const
 {
-    Q_D(const KSelectionProxyModel);
-
-    if (!sourceModel() || index.column() > 0
-            // Qt 4.6 doesn't notice changes in columnCount, so we can't return 0 when
-            // it's actually 0 ,but must return what the source model says, even if we
-            // have no rows or columns.
-#if QT_VERSION >= 0x040700
-            || d->m_rootIndexList.isEmpty()
-#endif
-       ) {
+    if (!sourceModel() || index.column() > 0) {
         return 0;
     }
 
diff -Nur kitemmodels-5.16.0/tests/CMakeLists.txt kitemmodels-5.17.0/tests/CMakeLists.txt
--- kitemmodels-5.16.0/tests/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/CMakeLists.txt	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,4 @@
+remove_definitions(-DQT_NO_CAST_TO_ASCII)
+remove_definitions(-DQT_NO_CAST_FROM_ASCII)
+
+add_subdirectory(proxymodeltestapp)
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,107 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "breadcrumbdirectionwidget.h"
+
+#include <dynamictreemodel.h>
+#include <kbreadcrumbselectionmodel.h>
+#include <QBoxLayout>
+#include <QSplitter>
+#include <QTreeView>
+#include <QEvent>
+
+BreadcrumbDirectionWidget::BreadcrumbDirectionWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+
+    ModelInsertCommand ins(rootModel);
+    ins.setStartRow(0);
+    ins.interpret(
+        QString("- 1"
+        "- 2"
+        "- - 3"
+        "- - 3"
+        "- - - 4"
+        "- - - 4"
+        "- - - - 4"
+        "- - 4"
+        "- - 5"
+        "- - - 4"
+        "- - - - 4"
+        "- - 5"
+        "- 6"
+        "- 7"
+        "- - 8"
+        "- - - 9"
+        "- - - 10"
+        "- - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - - - - 9"
+        "- - - - - - - - 10"
+        "- - - - - - - - 9"
+        "- - - - - - - 10"
+        "- 20"
+        "- 21"));
+    ins.doCommand();
+
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *splitter1 = new QSplitter(Qt::Vertical, this);
+    layout->addWidget(splitter1);
+    QSplitter *splitter2 = new QSplitter(splitter1);
+    QSplitter *splitter3 = new QSplitter(splitter1);
+
+    QTreeView *view1 = new QTreeView(splitter2);
+    view1->setModel(rootModel);
+    view1->expandAll();
+    view1->viewport()->setBackgroundRole(QPalette::Button);
+    QTreeView *view2 = new QTreeView(splitter2);
+    view2->setModel(rootModel);
+    view2->expandAll();
+    view2->viewport()->installEventFilter(this);
+    QTreeView *view3 = new QTreeView(splitter3);
+    view3->setModel(rootModel);
+    view3->expandAll();
+    QTreeView *view4 = new QTreeView(splitter3);
+    view4->setModel(rootModel);
+    view4->expandAll();
+    view4->viewport()->installEventFilter(this);
+    view4->viewport()->setBackgroundRole(QPalette::Button);
+
+    KBreadcrumbSelectionModel *breadcrumbSelection1 = new KBreadcrumbSelectionModel(view2->selectionModel(), this);
+    view1->setSelectionModel(breadcrumbSelection1);
+
+    KBreadcrumbSelectionModel *breadcrumbSelection2 = new KBreadcrumbSelectionModel(view3->selectionModel(),
+            KBreadcrumbSelectionModel::MakeBreadcrumbSelectionInOther, this);
+    view4->setSelectionModel(breadcrumbSelection2);
+}
+
+bool BreadcrumbDirectionWidget::eventFilter(QObject *o, QEvent *e)
+{
+    if (e->type() == QEvent::MouseButtonPress || e->type() == QEvent::MouseButtonDblClick || e->type() == QEvent::MouseButtonRelease) {
+        return true;
+    }
+    return QObject::eventFilter(o, e);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbdirectionwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,38 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef BREADCRUMBDIRECTIONWIDGET_H
+#define BREADCRUMBDIRECTIONWIDGET_H
+
+#include <QWidget>
+
+class BreadcrumbDirectionWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    BreadcrumbDirectionWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+protected:
+    virtual bool eventFilter(QObject *, QEvent *);
+
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,289 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "breadcrumbnavigationwidget.h"
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+
+#include <QSplitter>
+#include <QListView>
+#include <QTreeView>
+#include <QBoxLayout>
+
+#include "kselectionproxymodel.h"
+#include "kbreadcrumbselectionmodel.h"
+
+#define SON(object) object->setObjectName(#object)
+
+CurrentItemLabel::CurrentItemLabel(QAbstractItemModel *model, QWidget *parent, Qt::WindowFlags f)
+    : QLabel(parent, f), m_model(model)
+{
+    connect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), SLOT(dataChanged(QModelIndex,QModelIndex)));
+    connect(model, SIGNAL(rowsInserted(QModelIndex,int,int)), SLOT(rowsInserted(QModelIndex,int,int)));
+    connect(model, SIGNAL(rowsRemoved(QModelIndex,int,int)), SLOT(rowsRemoved(QModelIndex,int,int)));
+    connect(model, SIGNAL(modelReset()), SLOT(modelReset()));
+
+    if (!m_model->hasChildren()) {
+        setText(QStringLiteral("No selection"));
+    }
+}
+
+void CurrentItemLabel::dataChanged(const QModelIndex &, const QModelIndex &)
+{
+    setText(m_model->index(0, 0).data().toString());
+}
+
+void CurrentItemLabel::rowsInserted(const QModelIndex &, int, int)
+{
+    setText(m_model->index(0, 0).data().toString());
+}
+
+void CurrentItemLabel::rowsRemoved(const QModelIndex &, int, int)
+{
+    if (!m_model->hasChildren()) {
+        setText(QStringLiteral("No selection"));
+        return;
+    }
+    setText(m_model->index(0, 0).data().toString());
+}
+
+void CurrentItemLabel::modelReset()
+{
+    if (!m_model->hasChildren()) {
+        setText(QStringLiteral("No selection"));
+    }
+    setText(m_model->index(0, 0).data().toString());
+}
+
+KBreadcrumbNavigationProxyModel::KBreadcrumbNavigationProxyModel(QItemSelectionModel *selectionModel, QObject *parent)
+    : KSelectionProxyModel(selectionModel, parent)
+{
+
+}
+
+QVariant KBreadcrumbNavigationProxyModel::data(const QModelIndex &index, int role) const
+{
+    if (rowCount() > 2 && index.row() == 0 && role == Qt::DisplayRole) {
+        QModelIndex sourceIndex = mapToSource(index);
+        QStringList dataList;
+        while (sourceIndex.isValid()) {
+            dataList.prepend(sourceIndex.data().toString());
+            sourceIndex = sourceIndex.parent();
+        }
+        return dataList.join(QStringLiteral(" > "));
+    }
+    return KSelectionProxyModel::data(index, role);
+}
+
+void KBreadcrumbNavigationProxyModel::setShowHiddenAscendantData(bool showHiddenAscendantData)
+{
+    m_showHiddenAscendantData = showHiddenAscendantData;
+}
+
+bool KBreadcrumbNavigationProxyModel::showHiddenAscendantData() const
+{
+    return m_showHiddenAscendantData;
+}
+
+KNavigatingProxyModel::KNavigatingProxyModel(QItemSelectionModel *selectionModel, QObject *parent)
+    : KSelectionProxyModel(selectionModel, parent), m_selectionModel(selectionModel)
+{
+
+}
+
+void KNavigatingProxyModel::setSourceModel(QAbstractItemModel *sourceModel)
+{
+    connect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
+            SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
+
+    KSelectionProxyModel::setSourceModel(sourceModel);
+    updateNavigation();
+}
+
+void KNavigatingProxyModel::navigationSelectionChanged(const QItemSelection &, const QItemSelection &)
+{
+    updateNavigation();
+}
+
+void KNavigatingProxyModel::updateNavigation()
+{
+    if (!sourceModel()) {
+        return;
+    }
+
+    if (m_selectionModel->selection().isEmpty()) {
+        setFilterBehavior(KSelectionProxyModel::ExactSelection);
+        QModelIndex top = sourceModel()->index(0, 0);
+        QModelIndex bottom = sourceModel()->index(sourceModel()->rowCount() - 1, 0);
+
+        disconnect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
+                   this, SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
+        m_selectionModel->select(QItemSelection(top, bottom), QItemSelectionModel::Select);
+        connect(m_selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
+                SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
+    } else if (filterBehavior() != KSelectionProxyModel::ChildrenOfExactSelection) {
+        setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
+    }
+}
+
+void KNavigatingProxyModel::modelReset()
+{
+    updateNavigation();
+}
+
+QVariant KNavigatingProxyModel::data(const QModelIndex &index, int role) const
+{
+    if (role == Qt::DisplayRole && sourceModel()->hasChildren(mapToSource(index))) {
+        return QString("+ " + KSelectionProxyModel::data(index, role).toString());
+    }
+    return KSelectionProxyModel::data(index, role);
+}
+
+KForwardingItemSelectionModel::KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, QObject *parent)
+    : QItemSelectionModel(model, parent), m_selectionModel(selectionModel), m_direction(Forward)
+{
+    Q_ASSERT(model == selectionModel->model());
+    connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
+            SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
+}
+
+KForwardingItemSelectionModel::KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, Direction direction, QObject *parent)
+    : QItemSelectionModel(model, parent), m_selectionModel(selectionModel), m_direction(direction)
+{
+    Q_ASSERT(model == selectionModel->model());
+    if (m_direction == Forward)
+        connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)),
+                SLOT(navigationSelectionChanged(QItemSelection,QItemSelection)));
+}
+
+void KForwardingItemSelectionModel::select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
+{
+    if (m_direction == Reverse) {
+        m_selectionModel->select(index, command);
+    } else {
+        QItemSelectionModel::select(index, command);
+    }
+}
+
+void KForwardingItemSelectionModel::select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command)
+{
+    if (m_direction == Reverse) {
+        m_selectionModel->select(selection, command);
+    } else {
+        QItemSelectionModel::select(selection, command);
+    }
+}
+
+void KForwardingItemSelectionModel::navigationSelectionChanged(const QItemSelection &selected, const QItemSelection &)
+{
+    select(selected, ClearAndSelect);
+}
+
+BreadcrumbNavigationWidget::BreadcrumbNavigationWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+    QSplitter *splitter = new QSplitter(this);
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->addWidget(splitter);
+
+    DynamicTreeWidget *dynamicTree = new DynamicTreeWidget(rootModel, splitter);
+    dynamicTree->treeView()->setSelectionMode(QAbstractItemView::SingleSelection);
+    dynamicTree->setInitialTree(
+        QString("- 1"
+        "- - 2"
+        "- - 2"
+        "- - - 3"
+        "- - - - 4"
+        "- - - - - 5"
+        "- - 2"
+        "- 6"
+        "- 6"
+        "- 6"
+        "- - 7"
+        "- - - 8"
+        "- - - 8"
+        "- - - - 9"
+        "- - - - - 10"
+        "- - - 8"
+        "- - - 8"
+        "- - 8"
+        "- 16"
+        "- - 17"
+        "- - - 18"
+        "- - - - 19"
+        "- - - - - 20"));
+
+    QList<QItemSelectionModel *> selectionModelList;
+
+    QSplitter *vSplitter = new QSplitter(Qt::Vertical, splitter);
+
+    QItemSelectionModel *rootSelectionModel = new QItemSelectionModel(rootModel, this);
+    SON(rootSelectionModel);
+
+    dynamicTree->treeView()->setSelectionModel(rootSelectionModel);
+
+    KBreadcrumbSelectionModel *breadcrumbOnlyProxySelector2 = new KBreadcrumbSelectionModel(rootSelectionModel, KBreadcrumbSelectionModel::MakeBreadcrumbSelectionInOther, this);
+    SON(breadcrumbOnlyProxySelector2);
+    breadcrumbOnlyProxySelector2->setActualSelectionIncluded(false);
+
+    KBreadcrumbNavigationProxyModel *breadcrumbNavigationModel = new KBreadcrumbNavigationProxyModel(breadcrumbOnlyProxySelector2, this);
+    SON(breadcrumbNavigationModel);
+    breadcrumbNavigationModel->setSourceModel(rootModel);
+    breadcrumbNavigationModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QListView *breadcrumbView = new QListView(vSplitter);
+//   SON(breadcrumbNavigationModel);
+    breadcrumbView->setModel(breadcrumbNavigationModel);
+
+    // This shouldn't operate on rootSelectionModel. It should operate on oneway instead?
+    KLinkItemSelectionModel *breadcrumbViewSelectionModel = new KLinkItemSelectionModel(breadcrumbNavigationModel, rootSelectionModel, this);
+    SON(breadcrumbViewSelectionModel);
+
+    KForwardingItemSelectionModel *oneway2 = new KForwardingItemSelectionModel(breadcrumbNavigationModel, breadcrumbViewSelectionModel, KForwardingItemSelectionModel::Reverse);
+    SON(oneway2);
+
+    breadcrumbView->setSelectionModel(oneway2);
+
+    KSelectionProxyModel *currentItemSelectionModel = new KSelectionProxyModel(rootSelectionModel, this);
+    currentItemSelectionModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+    currentItemSelectionModel->setSourceModel(rootModel);
+    SON(currentItemSelectionModel);
+
+    new CurrentItemLabel(currentItemSelectionModel, vSplitter);
+
+    QListView *selectionView = new QListView(vSplitter);
+
+    // Need a one-way connection from rootSelectionModel to rootSelectionModel2
+
+    KForwardingItemSelectionModel *oneway = new KForwardingItemSelectionModel(rootModel, rootSelectionModel);
+
+    KNavigatingProxyModel *navigatingProxyModel = new KNavigatingProxyModel(oneway, this);
+    SON(navigatingProxyModel);
+    navigatingProxyModel->setSourceModel(rootModel);
+    selectionView->setModel(navigatingProxyModel);
+
+    KLinkItemSelectionModel *selectedChildrenSelectionModel = new KLinkItemSelectionModel(navigatingProxyModel, rootSelectionModel, this);
+
+    selectionView->setSelectionModel(selectedChildrenSelectionModel);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbnavigationwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,120 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef BREADCRUMBNAVIGATION_WIDGET_H
+#define BREADCRUMBNAVIGATION_WIDGET_H
+
+#include <QWidget>
+#include <QItemSelection>
+#include <QLabel>
+#include <QListView>
+#include <kselectionproxymodel.h>
+
+#include "klinkitemselectionmodel.h"
+
+class CurrentItemLabel : public QLabel
+{
+    Q_OBJECT
+public:
+    CurrentItemLabel(QAbstractItemModel *model, QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+private Q_SLOTS:
+    void rowsInserted(const QModelIndex &parent, int start, int end);
+    void rowsRemoved(const QModelIndex &parent, int start, int end);
+    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
+    void modelReset();
+
+private:
+    QAbstractItemModel *m_model;
+};
+
+class KBreadcrumbNavigationProxyModel : public KSelectionProxyModel
+{
+    Q_OBJECT
+public:
+    KBreadcrumbNavigationProxyModel(QItemSelectionModel *selectionModel, QObject *parent = 0);
+
+    void setShowHiddenAscendantData(bool showHiddenAscendantData);
+    bool showHiddenAscendantData() const;
+
+    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+
+private:
+    bool m_showHiddenAscendantData;
+
+};
+
+class KNavigatingProxyModel : public KSelectionProxyModel
+{
+    Q_OBJECT
+public:
+    KNavigatingProxyModel(QItemSelectionModel *selectionModel, QObject *parent = 0);
+
+    virtual void setSourceModel(QAbstractItemModel *sourceModel);
+
+    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+
+private Q_SLOTS:
+    void modelReset();
+    void updateNavigation();
+    void navigationSelectionChanged(const QItemSelection &, const QItemSelection &);
+
+private:
+
+private:
+    using KSelectionProxyModel::setFilterBehavior;
+
+    QItemSelectionModel *m_selectionModel;
+
+};
+
+class KForwardingItemSelectionModel : public QItemSelectionModel
+{
+    Q_OBJECT
+public:
+    enum Direction {
+        Forward,
+        Reverse
+    };
+    KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, QObject *parent = 0);
+    KForwardingItemSelectionModel(QAbstractItemModel *model, QItemSelectionModel *selectionModel, Direction direction, QObject *parent = 0);
+
+    virtual void select(const QModelIndex &index, SelectionFlags command);
+    virtual void select(const QItemSelection &selection, SelectionFlags command);
+
+private Q_SLOTS:
+    void navigationSelectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
+
+private:
+    QItemSelectionModel *m_selectionModel;
+    Direction m_direction;
+};
+
+class BreadcrumbNavigationWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    BreadcrumbNavigationWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbswidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbswidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbswidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbswidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,150 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "breadcrumbswidget.h"
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+
+#include <QSplitter>
+#include <QListView>
+#include <QTreeView>
+#include <QBoxLayout>
+
+#include "kselectionproxymodel.h"
+#include "kbreadcrumbselectionmodel.h"
+
+MultiSelectionModel::MultiSelectionModel(QAbstractItemModel *model, QList< QItemSelectionModel * > selectionModels, QObject *parent)
+    : QItemSelectionModel(model, parent), m_selectionModels(selectionModels)
+{
+
+}
+
+void MultiSelectionModel::select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
+{
+    Q_FOREACH (QItemSelectionModel *selectionModel, m_selectionModels) {
+        selectionModel->select(index, command);
+    }
+    QItemSelectionModel::select(index, command);
+}
+
+void MultiSelectionModel::select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command)
+{
+    Q_FOREACH (QItemSelectionModel *selectionModel, m_selectionModels) {
+        selectionModel->select(selection, command);
+    }
+    QItemSelectionModel::select(selection, command);
+}
+
+BreadcrumbsWidget::BreadcrumbsWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+    QSplitter *splitter = new QSplitter(this);
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->addWidget(splitter);
+
+    DynamicTreeWidget *dynamicTree = new DynamicTreeWidget(rootModel, splitter);
+    dynamicTree->treeView()->setSelectionMode(QAbstractItemView::SingleSelection);
+    dynamicTree->setInitialTree(
+        QString("- 1"
+        "- - 2"
+        "- - 2"
+        "- - - 3"
+        "- - - - 4"
+        "- - - - - 5"
+        "- - 2"
+        "- 6"
+        "- 6"
+        "- 6"
+        "- - 7"
+        "- - - 8"
+        "- - - 8"
+        "- - - - 9"
+        "- - - - - 10"
+        "- - - 8"
+        "- - - 8"
+        "- - 8"
+        "- 16"
+        "- - 17"
+        "- - - 18"
+        "- - - - 19"
+        "- - - - - 20"));
+
+    QList<QItemSelectionModel *> selectionModelList;
+    QItemSelectionModel *fullBreadcrumbSelectionModel = new QItemSelectionModel(rootModel, this);
+
+    KBreadcrumbSelectionModel *fullBreadcrumbProxySelector = new KBreadcrumbSelectionModel(fullBreadcrumbSelectionModel, this);
+    selectionModelList << fullBreadcrumbProxySelector;
+
+    KSelectionProxyModel *fullBreadCrumbSelectionProxyModel = new KSelectionProxyModel(fullBreadcrumbSelectionModel, this);
+    fullBreadCrumbSelectionProxyModel->setSourceModel(rootModel);
+    fullBreadCrumbSelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QListView *fullBreadcrumbProxyView = new QListView(splitter);
+    fullBreadcrumbProxyView->setModel(fullBreadCrumbSelectionProxyModel);
+
+    QItemSelectionModel *breadcrumbOnlySelectionModel = new QItemSelectionModel(rootModel, this);
+
+    KBreadcrumbSelectionModel *breadcrumbOnlyProxySelector = new KBreadcrumbSelectionModel(breadcrumbOnlySelectionModel, this);
+    breadcrumbOnlyProxySelector->setActualSelectionIncluded(false);
+    selectionModelList << breadcrumbOnlyProxySelector;
+
+    KSelectionProxyModel *breadcrumbOnlySelectionProxyModel = new KSelectionProxyModel(breadcrumbOnlySelectionModel, this);
+    breadcrumbOnlySelectionProxyModel->setSourceModel(rootModel);
+    breadcrumbOnlySelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QListView *breadcrumbOnlyProxyView = new QListView(splitter);
+    breadcrumbOnlyProxyView->setModel(breadcrumbOnlySelectionProxyModel);
+
+    int selectionDepth = 2;
+
+    QItemSelectionModel *thisAndAscendantsSelectionModel = new QItemSelectionModel(rootModel, this);
+
+    KBreadcrumbSelectionModel *thisAndAscendantsProxySelector = new KBreadcrumbSelectionModel(thisAndAscendantsSelectionModel, this);
+    thisAndAscendantsProxySelector->setBreadcrumbLength(selectionDepth);
+    selectionModelList << thisAndAscendantsProxySelector;
+
+    KSelectionProxyModel *thisAndAscendantsSelectionProxyModel = new KSelectionProxyModel(thisAndAscendantsSelectionModel, this);
+    thisAndAscendantsSelectionProxyModel->setSourceModel(rootModel);
+    thisAndAscendantsSelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QListView *thisAndAscendantsProxyView = new QListView(splitter);
+    thisAndAscendantsProxyView->setModel(thisAndAscendantsSelectionProxyModel);
+
+    QItemSelectionModel *ascendantsOnlySelectionModel = new QItemSelectionModel(rootModel, this);
+
+    KBreadcrumbSelectionModel *ascendantsOnlyProxySelector = new KBreadcrumbSelectionModel(ascendantsOnlySelectionModel, this);
+    ascendantsOnlyProxySelector->setActualSelectionIncluded(false);
+    ascendantsOnlyProxySelector->setBreadcrumbLength(selectionDepth);
+    selectionModelList << ascendantsOnlyProxySelector;
+
+    KSelectionProxyModel *ascendantsOnlySelectionProxyModel = new KSelectionProxyModel(ascendantsOnlySelectionModel, this);
+    ascendantsOnlySelectionProxyModel->setSourceModel(rootModel);
+    ascendantsOnlySelectionProxyModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QListView *ascendantsOnlyProxyView = new QListView(splitter);
+    ascendantsOnlyProxyView->setModel(ascendantsOnlySelectionProxyModel);
+
+    MultiSelectionModel *multiSelectionModel = new MultiSelectionModel(rootModel, selectionModelList, this);
+    dynamicTree->treeView()->setSelectionModel(multiSelectionModel);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbswidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbswidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/breadcrumbswidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/breadcrumbswidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,56 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef BREADCRUBS_WIDGET_H
+#define BREADCRUBS_WIDGET_H
+
+#include <QWidget>
+#include <QItemSelection>
+#include <QLabel>
+#include <QListView>
+#include <kselectionproxymodel.h>
+
+#include "klinkitemselectionmodel.h"
+
+class MultiSelectionModel : public QItemSelectionModel
+{
+    Q_OBJECT
+public:
+    MultiSelectionModel(QAbstractItemModel *model, QList<QItemSelectionModel *> selectionModels, QObject *parent = 0);
+
+public:
+    virtual void select(const QModelIndex &index, SelectionFlags command);
+    virtual void select(const QItemSelection &selection, SelectionFlags command);
+
+private:
+    QList<QItemSelectionModel *> m_selectionModels;
+};
+
+class BreadcrumbsWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    BreadcrumbsWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/checkablewidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/checkablewidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/checkablewidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/checkablewidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "checkablewidget.h"
+
+#include <QTreeView>
+#include <QHBoxLayout>
+#include <QSplitter>
+
+#include <kselectionproxymodel.h>
+#include <kcheckableproxymodel.h>
+#include "dynamictreemodel.h"
+
+CheckableWidget::CheckableWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *vSplitter = new QSplitter(this);
+    layout->addWidget(vSplitter);
+
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+
+    ModelInsertCommand *insert = new ModelInsertCommand(rootModel, this);
+    insert->setStartRow(0);
+    insert->interpret(
+        QString("- 1"
+        "- 1"
+        "- 1"
+        "- - 2"
+        "- - 2"
+        "- - 2"
+        "- - 2"
+        "- 1"
+        "- 1"
+        "- 1"
+        "- - 2"
+        "- - - 3"
+        "- - - - 4"
+        "- - - - 4"
+        "- - - 3"
+        "- - - 3"
+        "- - - 3"
+        "- - 2"
+        "- - 2"
+        "- - 2"
+        "- 1"
+        "- 1")
+    );
+    insert->doCommand();
+
+    QItemSelectionModel *checkModel = new QItemSelectionModel(rootModel, this);
+    KCheckableProxyModel *checkable = new KCheckableProxyModel(this);
+    checkable->setSourceModel(rootModel);
+    checkable->setSelectionModel(checkModel);
+
+    QTreeView *tree1 = new QTreeView(vSplitter);
+    tree1->setModel(checkable);
+    tree1->expandAll();
+
+    KSelectionProxyModel *selectionProxy = new KSelectionProxyModel(checkModel, this);
+    selectionProxy->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+    selectionProxy->setSourceModel(rootModel);
+
+    QTreeView *tree2 = new QTreeView(vSplitter);
+    tree2->setModel(selectionProxy);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/checkablewidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/checkablewidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/checkablewidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/checkablewidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,36 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef CHECKABLEWIDGET_H
+#define CHECKABLEWIDGET_H
+
+#include <QWidget>
+
+class CheckableWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    CheckableWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/CMakeLists.txt kitemmodels-5.17.0/tests/proxymodeltestapp/CMakeLists.txt
--- kitemmodels-5.16.0/tests/proxymodeltestapp/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/CMakeLists.txt	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,55 @@
+
+set(proxymodeltestapp_SRCS
+    main.cpp
+    mainwindow.cpp
+    breadcrumbswidget.cpp
+    breadcrumbnavigationwidget.cpp
+    breadcrumbdirectionwidget.cpp
+    checkablewidget.cpp
+    selectionpmwidget.cpp
+#     statesaverwidget.cpp
+    kidentityproxymodelwidget.cpp
+    recursivefilterpmwidget.cpp
+    descendantpmwidget.cpp
+    kreparentingproxymodel.cpp
+    proxymodeltestwidget.cpp
+    proxyitemselectionwidget.cpp
+    lessthanwidget.cpp
+    modelcommanderwidget.cpp
+    matchcheckingwidget.cpp
+)
+
+find_package(Qt5Script ${REQUIRED_QT_VERSION} QUIET CONFIG)
+if (Qt5Script_FOUND)
+  list(APPEND proxymodeltestapp_SRCS
+    reparentingpmwidget.cpp
+    scriptablereparentingwidget.cpp
+  )
+endif()
+
+find_package(Qt5QuickWidgets ${REQUIRED_QT_VERSION} CONFIG)
+if (Qt5QuickWidgets_FOUND AND NOT Qt5QuickWidgets_VERSION VERSION_LESS 5.5)
+  list(APPEND proxymodeltestapp_SRCS
+    selectioninqmlwidget.cpp
+  )
+  add_definitions(-DSRC_DIR="${CMAKE_CURRENT_SOURCE_DIR}")
+endif()
+
+add_executable(proxymodeltestapp ${proxymodeltestapp_SRCS})
+
+target_link_libraries(proxymodeltestapp
+   KF5::ItemModels
+   proxymodeltestsuite
+   Qt5::Widgets
+)
+
+if (Qt5Script_FOUND)
+  target_link_libraries(proxymodeltestapp
+    Qt5::Script
+  )
+endif()
+if (Qt5QuickWidgets_FOUND AND NOT Qt5QuickWidgets_VERSION VERSION_LESS 5.5)
+  target_link_libraries(proxymodeltestapp
+    Qt5::QuickWidgets
+  )
+endif()
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/descendantpmwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/descendantpmwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/descendantpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/descendantpmwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,165 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "descendantpmwidget.h"
+
+#include <QTreeView>
+#include <QSplitter>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include "kdescendantsproxymodel.h"
+#include <QHBoxLayout>
+#include <QLineEdit>
+#include <QApplication>
+
+#include "modeleventlogger.h"
+
+DescendantProxyModelWidget::DescendantProxyModelWidget(QWidget *parent): QWidget(parent)
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *vSplitter = new QSplitter(this);
+    layout->addWidget(vSplitter);
+
+    m_rootModel = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *dynTreeWidget = new DynamicTreeWidget(m_rootModel, vSplitter);
+
+    dynTreeWidget->setInitialTree(
+        QString("- 1"
+        "- 2"
+        "- - 3"
+        "- - 3"
+        "- - - 4"
+        "- - - 4"
+        "- - - - 4"
+        "- - 4"
+        "- - 5"
+        "- - - 4"
+        "- - - - 4"
+        "- - 5"
+        "- 6"
+        "- 7"
+        "- - 8"
+        "- - - 9"
+        "- - - 10"
+        "- - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - - - - 9"
+        "- - - - - - - - 10"
+        "- - - - - - - - 9"
+        "- - - - - - - 10"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - 10"
+        "- - 11"
+        "- - 12"
+        "- 13"
+        "- 14"
+        "- 15"
+        "- - 16"
+        "- - - 17"
+        "- - - 18"
+        "- 19"
+        "- 20"
+        "- 21"));
+
+    m_eventLogger = new ModelEventLogger(m_rootModel, this);
+
+    m_descProxyModel = new KDescendantsProxyModel(this);
+    m_descProxyModel->setSourceModel(m_rootModel);
+
+//   KDescendantsProxyModel *descProxyModel2 = new KDescendantsProxyModel(this);
+//   descProxyModel2->setSourceModel(m_rootModel);
+//   descProxyModel2->setDisplayAncestorData(true);
+
+//   QTreeView *treeview = new QTreeView( vSplitter );
+//   treeview->setModel(m_rootModel);
+//   treeview->setSelectionMode(QAbstractItemView::ExtendedSelection);
+
+    m_descView = new QTreeView(vSplitter);
+    m_descView->setModel(m_descProxyModel);
+
+//   QTreeView *descView2 = new QTreeView( vSplitter );
+//   descView2->setModel(descProxyModel2);
+
+//   QWidget *w = new QWidget(vSplitter);
+//   QVBoxLayout *vLayout = new QVBoxLayout(w);
+//   QTreeView *matchView = new QTreeView(w);
+//   matchView->setModel(m_selectionProxyModel);
+//   m_lineEdit = new QLineEdit(w);
+//   connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(doMatch(QString)));
+//   connect(m_descView->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)), SLOT(refreshMatch()));
+
+//   vLayout->addWidget(m_lineEdit);
+//   vLayout->addWidget(matchView);
+
+    setLayout(layout);
+}
+
+DescendantProxyModelWidget::~DescendantProxyModelWidget()
+{
+}
+
+void DescendantProxyModelWidget::doMatch(const QString &matchData)
+{
+    Q_UNUSED(matchData);
+#if 0
+    m_itemSelectionModel->clearSelection();
+
+    if (matchData.isEmpty()) {
+        return;
+    }
+
+    QModelIndex start = m_descView->currentIndex();
+
+    if (!start.isValid()) {
+        start = m_descProxyModel->index(0, 0);
+    }
+
+    // TODO: get from user.
+    int hits = -1;
+
+    QModelIndexList matches = m_descProxyModel->match(start, Qt::DisplayRole, matchData, hits, Qt::MatchContains);
+
+    Q_FOREACH (const QModelIndex &matchingIndex, matches) {
+        m_itemSelectionModel->select(matchingIndex, QItemSelectionModel::Select | QItemSelectionModel::Rows);
+    }
+#endif
+}
+
+void DescendantProxyModelWidget::refreshMatch()
+{
+    doMatch(m_lineEdit->text());
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/descendantpmwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/descendantpmwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/descendantpmwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/descendantpmwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,59 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef DESCENDANTPM_WIDGET_H
+#define DESCENDANTPM_WIDGET_H
+
+#include <QWidget>
+
+class DynamicTreeModel;
+class QTreeView;
+class QLineEdit;
+class QItemSelectionModel;
+
+class KDescendantsProxyModel;
+class KSelectionProxyModel;
+
+class ModelEventLogger;
+
+class DescendantProxyModelWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    DescendantProxyModelWidget(QWidget *parent = 0);
+    virtual ~DescendantProxyModelWidget();
+
+protected Q_SLOTS:
+    void doMatch(const QString &matchData);
+    void refreshMatch();
+
+private:
+    DynamicTreeModel *m_rootModel;
+    ModelEventLogger *m_eventLogger;
+    KDescendantsProxyModel *m_descProxyModel;
+    KSelectionProxyModel *m_selectionProxyModel;
+    QItemSelectionModel *m_itemSelectionModel;
+    QTreeView *m_descView;
+    QLineEdit *m_lineEdit;
+
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/kidentityproxymodelwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/kidentityproxymodelwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/kidentityproxymodelwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/kidentityproxymodelwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,76 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "kidentityproxymodelwidget.h"
+
+#include <dynamictreemodel.h>
+#include <kbreadcrumbselectionmodel.h>
+#include <QBoxLayout>
+#include <QSplitter>
+#include <QTreeView>
+#include <QEvent>
+#include <QIdentityProxyModel>
+
+#include "dynamictreewidget.h"
+
+#include "modeltest.h"
+
+KIdentityProxyModelWidget::KIdentityProxyModelWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *splitter = new QSplitter(this);
+    layout->addWidget(splitter);
+
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *treeWidget = new DynamicTreeWidget(rootModel, splitter);
+    treeWidget->setInitialTree(
+        QString(" - 1"
+        " - 2"
+        " - - 3"
+        " - - 4"
+        " - - 5"
+        " - 6"
+        " - 7"
+        " - - 8"
+        " - - - 9"
+        " - - - 10"
+        " - - 11")
+//     " - - 12"
+//     " - 13"
+//     " - 14"
+//     " - 15"
+//     " - - 16"
+//     " - - - 17"
+//     " - - - 18"
+//     " - 19"
+//     " - 20"
+//     " - 21"
+    );
+
+    QIdentityProxyModel *proxy = new QIdentityProxyModel(this);
+    proxy->setSourceModel(rootModel);
+
+    QTreeView *view1 = new QTreeView(splitter);
+    view1->setModel(proxy);
+    view1->expandAll();
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/kidentityproxymodelwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/kidentityproxymodelwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/kidentityproxymodelwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/kidentityproxymodelwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,34 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef KIDENTITYPROXYMODELWIDGET_H
+#define KIDENTITYPROXYMODELWIDGET_H
+
+#include <QWidget>
+
+class KIdentityProxyModelWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    KIdentityProxyModelWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/kreparentingproxymodel.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/kreparentingproxymodel.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/kreparentingproxymodel.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/kreparentingproxymodel.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,1529 @@
+/*
+    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "kreparentingproxymodel.h"
+#include <QDebug>
+#include <QStack>
+
+#include <functional>
+#include <algorithm>
+
+class KReparentingProxyModelPrivate
+{
+    KReparentingProxyModelPrivate(KReparentingProxyModel *proxyModel)
+        : m_nextId(0), q_ptr(proxyModel)
+    {
+
+    }
+
+    qint64 newId() const
+    {
+        return m_nextId++;
+    }
+
+    enum MapStrategy {
+        MapDescendants,
+        MapChildrenOnly
+    };
+
+    /**
+      Creates mappings of indexes in the source model between @p start
+      and @p end which should be represented in the proxy model as descendants
+      of @p parent.
+    */
+    QHash<QModelIndex, QModelIndexList> recreateMappings(const QModelIndex &parent, int start, int end = -1, int strategy = MapChildrenOnly) const;
+
+    /**
+      Merges all indexes from @p mappings which are descendants of @p parent into the model.
+      Returns the remaining mappings.
+
+      Note that this changes the internal model structure and must only be called between begin/end insert/remove/move/reset calls.
+    */
+    QHash<QModelIndex, QModelIndexList> mergeDescendants(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent, int start);
+
+    /**
+      Verifies that the indexes below @p parent between @p start and rowCount(parent)
+      are in the correct positions in the proxy model. Repositions them if not.
+    */
+    void verifyStructure(const QModelIndex &parent, int start);
+
+    /**
+      Returns the index vertically below index in the model @p model.
+      If @p model is 0, the sourceModel is used
+      Returns an invalid index if there is no index below @p index.
+    */
+    QModelIndex getIndexBelow(const QModelIndex &index, QAbstractItemModel *model = 0) const;
+
+    /**
+      Returns the last descendant of @p index or itself if it has no children
+    */
+    QModelIndex getLastDescendant(const QModelIndex &index) const;
+
+    bool isDescendantInModel(const QModelIndex &ancestor, const QModelIndex &descendant) const;
+
+    /**
+      Returns the ancestors of @p descendant that are already in the proxy model.
+
+      Note that @p descendant does not have to be in the proxy yet, and it is not part of the
+      result list.
+    */
+    QVector<QModelIndex> getExistingAncestors(const QModelIndex &descendant) const;
+
+    void sourceRowsAboutToBeInserted(const QModelIndex &parent, int start, int end);
+    void sourceRowsInserted(const QModelIndex &parent, int start, int end);
+    void sourceRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);
+    void sourceRowsRemoved(const QModelIndex &parent, int start, int end);
+    void sourceRowsAboutToBeMoved(const QModelIndex &parent, int start, int end, const QModelIndex &destParent, int destRow);
+    void sourceRowsMoved(const QModelIndex &parent, int start, int end, const QModelIndex &destParent, int destRow);
+    void sourceModelAboutToBeReset();
+    void endResetProxy();
+    void sourceModelReset();
+    void sourceLayoutAboutToBeChanged();
+    void sourceLayoutChanged();
+    void sourceDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
+
+    mutable QHash<qint64, QPersistentModelIndex> m_parents;
+    mutable QHash<QPersistentModelIndex, QList<QPersistentModelIndex> > m_childIndexes;
+
+    struct PendingInsertion {
+        PendingInsertion()
+            : parentId(-1), start(-1), end(-1)
+        { }
+
+        PendingInsertion(const QModelIndex &_index, int _start, int _end)
+            : index(_index), start(_start), end(_end)
+        { }
+
+        QPersistentModelIndex index;
+        QModelIndex sourceIndex;
+        qint64 parentId;
+        int start;
+        int end;
+    };
+
+    struct PendingRemoval : PendingInsertion {
+        int numTrailing;
+    };
+    // Needed between the beginRemoveRows and endRemoveRows signals.
+    mutable QHash<qint64, QPersistentModelIndex> m_pendingRemovalParents;
+    mutable QHash<QPersistentModelIndex, QList<QPersistentModelIndex> > m_pendingRemovalChildIndexes;
+
+    QHash<QModelIndex, QModelIndexList> insertTree(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent);
+
+    void handleInsertion(const PendingInsertion &pendingInsertion);
+
+    void handleRemoval(const PendingRemoval &pendingRemoval);
+
+    mutable QHash<QModelIndex, PendingInsertion> m_pendingInsertions;
+    mutable QVector<PendingRemoval> m_pendingRemovals;
+
+    mutable qint64 m_nextId;
+
+    Q_DECLARE_PUBLIC(KReparentingProxyModel)
+    KReparentingProxyModel *q_ptr;
+
+    QList<QPersistentModelIndex> m_layoutChangePersistentIndexes;
+    QModelIndexList m_proxyIndexes;
+
+    void emitDataChangedSignals(const QModelIndex &parent, int maxChanged);
+
+    /**
+      Given @p parent in the proxy model, return the last index lying between @p start and @p end
+      which is also a descendant of @p parent.
+    */
+    QModelIndex findLastInParent(QModelIndex parent, int start, int end);
+
+    /**
+      Removes @P idx (which is a source model index) and its children from the model data structures.
+    */
+    void removeTree(const QPersistentModelIndex &idx, int start = 0, int end = -1);
+
+    int pendingRemovalRowCount(const QModelIndex &sourceIndex) const;
+
+};
+
+class LessThan
+{
+    const KReparentingProxyModel *m_model;
+public:
+    LessThan(const KReparentingProxyModel *model) : m_model(model) {}
+    bool operator()(const QModelIndex &ancestor, const QModelIndex &descendant)
+    {
+        return m_model->isDescendantOf(ancestor, descendant);
+    }
+};
+
+QModelIndex KReparentingProxyModelPrivate::getIndexBelow(const QModelIndex &index, QAbstractItemModel *model) const
+{
+    Q_Q(const KReparentingProxyModel);
+
+//   qDebug() << index.data() << index;
+
+    if (!model) {
+        model = q->sourceModel();
+    }
+
+    if (model->hasChildren(index)) {
+        return model->index(0, 0, index);
+    }
+
+    QModelIndex sibling = index.sibling(index.row() + 1, index.column());
+    if (sibling.isValid()) {
+        return sibling;
+    }
+
+    QModelIndex parent = index.parent();
+
+    if (!parent.isValid()) {
+        return QModelIndex();
+    }
+
+    int affectedRow = index.row();
+    const int column = 0;
+
+    while (parent.isValid()) {
+//     qDebug() << "parent" << parent.data() << model->rowCount(parent) << affectedRow;
+        if (affectedRow < model->rowCount(parent) - 1) {
+            return model->index(affectedRow + 1, column, parent);
+        }
+
+        affectedRow = parent.row();
+        parent = parent.parent();
+    }
+
+    if (model->rowCount(parent) >= affectedRow) {
+        return model->index(affectedRow + 1, column, parent);
+    }
+
+    return QModelIndex();
+}
+
+QModelIndex KReparentingProxyModelPrivate::getLastDescendant(const QModelIndex &index) const
+{
+    Q_Q(const KReparentingProxyModel);
+
+    QModelIndex proxyIndex = q->mapFromSource(index);
+
+    while (q->hasChildren(proxyIndex)) {
+        proxyIndex = proxyIndex.child(q->rowCount(proxyIndex), proxyIndex.column());
+        if (!proxyIndex.isValid()) {
+            break;
+        }
+    }
+    return q->mapToSource(proxyIndex);
+}
+
+QVector<QModelIndex> KReparentingProxyModelPrivate::getExistingAncestors(const QModelIndex &descendant) const
+{
+    Q_Q(const KReparentingProxyModel);
+
+    QVector<QModelIndex> vector;
+    if (!descendant.isValid()) {
+        return vector;
+    }
+
+    QModelIndex parent = q->mapFromSource(descendant).parent();
+    QModelIndex sourceParent = q->mapToSource(parent);
+    if (!sourceParent.isValid()) {
+        return vector;
+    }
+
+    vector.append(sourceParent);
+    while (parent.isValid()) {
+        parent = parent.parent();
+        sourceParent = q->mapToSource(parent);
+        if (!sourceParent.isValid()) {
+            return vector;
+        }
+        vector.prepend(sourceParent);
+    }
+    return vector;
+}
+
+QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::recreateMappings(const QModelIndex &ancestor, int start, int end, int strategy) const
+{
+    Q_Q(const KReparentingProxyModel);
+    const int column = 0;
+
+    QHash<QModelIndex, QModelIndexList> mappings;
+    // Handle listing the root QModelIndex().
+    if (!ancestor.isValid() && !q->sourceModel()->hasChildren())
+        // Empty model. Nothing to do.
+    {
+        return mappings;
+    }
+
+    // A
+    // - B
+    // - - C
+    // - D
+    // If start refers to D, existing ancestors will contain only A.
+    // We need to go 'up' to C and get its ancestors in case D is to be made a child of B or C (for example if B and C have just been inserted)
+    QModelIndex indexAbove;
+    if (start > 0) {
+        indexAbove = getLastDescendant(q->sourceModel()->index(start - 1, column, ancestor));
+    } else {
+        indexAbove = ancestor;
+    }
+
+    QVector<QModelIndex> ancestors = getExistingAncestors(indexAbove);
+
+//   ancestors.append(indexAbove);
+//   qDebug() << ancestors;
+    QModelIndex nextIndex = ancestor;
+
+    for (int row = start; (row <= end || end == -1);) {
+        // A
+        // - B
+        // - - C
+        // - D
+        // The nextIndex of the invalid QModelIndex is A,
+        // The nextIndex of A is B,
+        // The nextIndex of B is C,
+        // The nextIndex of C is D,
+        // The nextIndex of D is invalid,
+        // When the nextIndex is invalid we're finished creating mappings.
+        if (MapDescendants == strategy) {
+            nextIndex = getIndexBelow(nextIndex);
+        } else {
+            nextIndex = q->sourceModel()->index(row, column, ancestor);
+        }
+
+        if (!nextIndex.isValid()) {
+            break;
+        }
+
+        const QVector<QModelIndex>::iterator ancestorIt = qLowerBound(ancestors.begin(), ancestors.end(), nextIndex, LessThan(q));
+
+        ancestors.erase(ancestorIt, ancestors.end());
+
+        QModelIndex parent;
+        if (ancestorIt != ancestors.begin()) {
+            parent = *(ancestorIt - 1);
+        }
+
+        ancestors.append(nextIndex);
+
+        mappings[parent].append(nextIndex);
+    }
+
+    return mappings;
+}
+
+void KReparentingProxyModelPrivate::verifyStructure(const QModelIndex &sourceParent, int sourceStart)
+{
+    Q_Q(KReparentingProxyModel);
+
+    // If the start structure is:
+
+    // C
+    // D
+    // E
+
+    // and then A and B are inserted, we may need to move C D and E. Not all of the siblings will
+    // necessarily be moved to the same destination parent.
+    // Some example finished scenarios depending on the outcome of isDescendantOf:
+
+    // A
+    // B
+    // C
+    // D
+    // E
+
+    // A
+    // B
+    // - C
+    // - D
+    // - E
+
+    // A
+    // - B
+    // - C
+    // - D
+    // - E
+
+    // A
+    // - B
+    // - - C
+    // - D
+    // E
+
+    // Local variable mappings now contains all the information about finished state
+    // When we locate the first child to be moved, we process it and its siblings
+
+    QHash<QModelIndex, QModelIndexList> mappings = recreateMappings(sourceParent, sourceStart, -1);
+
+    if (mappings.isEmpty()) {
+        return;
+    }
+
+    QModelIndex sourceFirstIndex = q->sourceModel()->index(sourceStart, 0, sourceParent);
+
+    QModelIndex destinationParent;
+    QModelIndexList movedIndexes;
+
+    QHashIterator<QModelIndex, QModelIndexList> it(mappings);
+    while (it.hasNext()) {
+        it.next();
+//     qDebug() << it.key() << it.key().data() << it.value();
+        if (it.value().at(0) == sourceFirstIndex) {
+            destinationParent = it.key();
+            movedIndexes = it.value();
+            break;
+        }
+    }
+
+    Q_FOREVER {
+
+    if (destinationParent == sourceParent)
+            // No indexes moved
+        {
+            return;
+        }
+
+        Q_ASSERT(destinationParent.isValid());
+        Q_ASSERT(!movedIndexes.isEmpty());
+
+        // It's only possible for things to move right, and even that's only an option
+        // for children of parent, but not their descendants. ie, children of C D and E will not need to be reparented.
+        // They are already in the correct positions.
+
+        QList<QPersistentModelIndex> &existingSourceIndexes = m_childIndexes[sourceParent];
+        QList<QPersistentModelIndex> existingDestinationIndexes = m_childIndexes[destinationParent];
+
+        QModelIndex proxySourceParent = q->mapFromSource(sourceParent);
+        QModelIndex proxyDestinationParent = q->mapFromSource(destinationParent);
+
+        // That is, start position of indexes to be moved from the source parent.
+        int proxySourceStart = m_childIndexes.value(sourceParent).indexOf(movedIndexes.at(0));
+        int proxySourceEnd = proxySourceStart + movedIndexes.size() - 1;
+
+        // The moved indexes are appended to the destinationParent. Nothing else is possible.
+        // If they were to be inserted in the middle somewhere, they would already be there.
+
+        int destinationRow = existingDestinationIndexes.size();
+
+        bool allowMove = q->beginMoveRows(proxySourceParent, proxySourceStart, proxySourceEnd, proxyDestinationParent, destinationRow);
+        Q_ASSERT(allowMove);
+
+        for (int row = proxySourceEnd; row >= proxySourceStart; --row)
+        {
+            existingSourceIndexes.removeAt(row);
+        }
+
+        QHash<QModelIndex, QModelIndexList> mapping;
+        mapping.insert(destinationParent, movedIndexes);
+        mergeDescendants(mapping, destinationParent, existingDestinationIndexes.size());
+
+        q->endMoveRows();
+
+        if (!mappings.contains(q->mapToSource(proxyDestinationParent.parent())))
+        {
+            break;
+        }
+
+        destinationParent = q->mapToSource(proxyDestinationParent.parent());
+        movedIndexes = mappings.value(destinationParent);
+    }
+}
+
+KReparentingProxyModel::KReparentingProxyModel(QObject *parent)
+    : QAbstractProxyModel(parent), d_ptr(new KReparentingProxyModelPrivate(this))
+{
+
+}
+
+KReparentingProxyModel::~KReparentingProxyModel()
+{
+    delete d_ptr;
+}
+
+bool KReparentingProxyModelPrivate::isDescendantInModel(const QModelIndex &ancestor, const QModelIndex &descendant) const
+{
+//   qDebug() << ancestor.data() << descendant.data();
+
+//   if (!ancestor.isValid())
+//     return true;
+
+    QModelIndex _ancestor = descendant.parent();
+    while (_ancestor.isValid()) {
+        if (_ancestor == ancestor) {
+            return true;
+        }
+        _ancestor = _ancestor.parent();
+    }
+    return (!ancestor.isValid() && descendant.isValid());
+}
+
+bool KReparentingProxyModel::isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const
+{
+    Q_D(const KReparentingProxyModel);
+    return d->isDescendantInModel(ancestor, descendant);
+//   return (!ancestor.isValid() && descendant.isValid());
+}
+
+QModelIndex KReparentingProxyModel::mapFromSource(const QModelIndex &sourceIndex) const
+{
+    Q_D(const KReparentingProxyModel);
+    if (!sourceIndex.isValid()) {
+        return QModelIndex();
+    }
+
+    QModelIndex sourceIndexFirstColumn = sourceIndex.sibling(sourceIndex.row(), 0);
+
+    QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator it;
+    const QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator begin = d->m_childIndexes.constBegin();
+    const QHash<QPersistentModelIndex, QList<QPersistentModelIndex> >::const_iterator end = d->m_childIndexes.constEnd();
+
+    for (it = begin; it != end; ++it) {
+        QList<QPersistentModelIndex> list = it.value();
+        if (list.contains(sourceIndexFirstColumn)) {
+            QModelIndex sourceParent = it.key();
+            int row = list.indexOf(sourceIndexFirstColumn);
+
+            // There must have been a mapping made for it.
+            Q_ASSERT(d->m_parents.values().contains(sourceParent));
+
+            qint64 id = d->m_parents.key(sourceParent);
+
+            // id refers to the parent.
+            return createIndex(row, sourceIndex.column(), reinterpret_cast<void *>(id));
+        }
+    }
+    return QModelIndex();
+}
+
+QModelIndex KReparentingProxyModel::mapToSource(const QModelIndex &proxyIndex) const
+{
+    Q_D(const KReparentingProxyModel);
+
+//   qDebug() << "MMMMMM" << proxyIndex;
+
+    if (!proxyIndex.isValid()) {
+        return QModelIndex();
+    }
+
+    qint64 id = reinterpret_cast<qint64>(proxyIndex.internalPointer());
+
+//   if (!d->m_parents.contains(id))
+//     qDebug() << d->m_parents << id;
+
+    QModelIndex sourceParent;
+    if (d->m_pendingRemovalParents.contains(id)) {
+//     qDebug() << "pending";
+        sourceParent = d->m_pendingRemovalParents.value(id);
+    } else {
+        Q_ASSERT(d->m_parents.contains(id));
+        sourceParent = d->m_parents.value(id);
+    }
+
+// qDebug() <<  sourceParent << sourceParent.data();
+
+    QModelIndex sourceIndexFirstColumn;
+    if (d->m_pendingRemovalChildIndexes.contains(sourceParent)) {
+//     qDebug() << "#############";
+
+        Q_FOREACH (KReparentingProxyModelPrivate::PendingRemoval pendingRemoval, d->m_pendingRemovals) {
+//       qDebug() << "In" << pendingRemoval.index << pendingRemoval.sourceIndex << sourceParent;
+            if (pendingRemoval.sourceIndex == sourceParent) {
+//         qDebug() << "Out" << pendingRemoval.sourceIndex << sourceParent;
+                int proxyRow = proxyIndex.row();
+                int row = proxyRow - pendingRemoval.start;
+
+//         qDebug() << d->m_pendingRemovalChildIndexes.value(sourceParent) << proxyRow << row << pendingRemoval.end;
+
+                if (proxyRow > pendingRemoval.end) {
+                    Q_ASSERT(d->m_childIndexes.contains(sourceParent));
+                    row = proxyRow - (pendingRemoval.end - pendingRemoval.start + 1);
+//           qDebug() << "new row" << row;
+                    sourceIndexFirstColumn = d->m_childIndexes.value(sourceParent).at(row);
+                } else {
+                    sourceIndexFirstColumn = d->m_pendingRemovalChildIndexes.value(sourceParent).at(row);
+                }
+                break;
+            }
+        }
+    } else {
+        Q_ASSERT(d->m_childIndexes.contains(sourceParent));
+        sourceIndexFirstColumn = d->m_childIndexes.value(sourceParent).at(proxyIndex.row());
+    }
+
+    Q_ASSERT(sourceIndexFirstColumn.isValid());
+
+    return sourceIndexFirstColumn.sibling(sourceIndexFirstColumn.row(), proxyIndex.column());
+}
+
+int KReparentingProxyModel::columnCount(const QModelIndex &parent) const
+{
+    Q_D(const KReparentingProxyModel);
+
+    if (!sourceModel()) {
+        return 0;
+    }
+
+    if (!parent.isValid()) {
+        return sourceModel()->columnCount();
+    }
+
+    if (parent.column() > 0) {
+        return 0;
+    }
+    QModelIndex sourceIndex = mapToSource(parent);
+
+    return (d->m_childIndexes.value(sourceIndex).size() > 0)
+           ? sourceModel()->columnCount() : 0;
+}
+
+QVariant KReparentingProxyModel::data(const QModelIndex &proxyIndex, int role) const
+{
+    return QAbstractProxyModel::data(proxyIndex, role);
+}
+
+QModelIndex KReparentingProxyModel::index(int row, int column, const QModelIndex &parent) const
+{
+    Q_D(const KReparentingProxyModel);
+
+    if (!hasIndex(row, column, parent)) {
+        return QModelIndex();
+    }
+
+    QModelIndex sourceParent = mapToSource(parent);
+
+//   if (!d->m_pendingRemovals.isEmpty())
+//     qDebug() << sourceParent << sourceParent.data();
+
+    // ### This is where we need to have the children of removed indexes stored.
+
+//   if (!d->m_parents.values().contains(sourceParent))
+//   {
+//     qDebug() << d->m_pendingRemovalParents.values() << sourceParent << d->m_pendingRemovalParents.values().contains(sourceParent);
+//   }
+
+    qint64 id;
+    if (d->m_pendingRemovalParents.values().contains(sourceParent)) {
+        id = d->m_pendingRemovalParents.key(sourceParent);
+    } else {
+        // There must have been a mapping made for it.
+        Q_ASSERT(d->m_parents.values().contains(sourceParent));
+        id = d->m_parents.key(sourceParent);
+    }
+    return createIndex(row, column, reinterpret_cast<void *>(id));
+}
+
+QModelIndex KReparentingProxyModel::parent(const QModelIndex &child) const
+{
+    Q_D(const KReparentingProxyModel);
+
+    if (!child.isValid()) {
+        return QModelIndex();
+    }
+
+    QModelIndex sourceIndex = mapToSource(child);
+
+    QModelIndex firstColumnChild = sourceIndex;
+    if (sourceIndex.column() > 0) {
+        firstColumnChild = sourceIndex.sibling(sourceIndex.row(), 0);
+    }
+
+    QHashIterator<QPersistentModelIndex, QList<QPersistentModelIndex> > itPending(d->m_pendingRemovalChildIndexes);
+
+    while (itPending.hasNext()) {
+        itPending.next();
+
+        if (itPending.value().contains(firstColumnChild)) {
+            return mapFromSource(itPending.key());
+        }
+    }
+
+    QHashIterator<QPersistentModelIndex, QList<QPersistentModelIndex> > it(d->m_childIndexes);
+
+    while (it.hasNext()) {
+        it.next();
+
+        if (it.value().contains(firstColumnChild)) {
+            return mapFromSource(it.key());
+        }
+    }
+    return QModelIndex();
+}
+
+int KReparentingProxyModelPrivate::pendingRemovalRowCount(const QModelIndex &sourceIndex) const
+{
+
+    Q_FOREACH (const PendingRemoval &pendingRemoval, m_pendingRemovals) {
+//     qDebug() << pendingRemoval.sourceIndex;
+        if (pendingRemoval.sourceIndex == sourceIndex) {
+            return pendingRemoval.end - pendingRemoval.start + 1;
+        }
+    }
+    return 0;
+}
+
+int KReparentingProxyModel::rowCount(const QModelIndex &parent) const
+{
+    Q_D(const KReparentingProxyModel);
+
+    if (parent.column() > 0) {
+        return 0;
+    }
+
+    QModelIndex sourceIndex = mapToSource(parent);
+
+    int size = d->m_childIndexes.value(sourceIndex).size() + d->m_pendingRemovalChildIndexes.value(sourceIndex).size();
+
+//   qDebug() << d->m_pendingRemovalChildIndexes.value(sourceIndex).size();
+
+//   if (!d->m_pendingRemovals.isEmpty())
+//   {
+//     qDebug() << "SIZE" << sourceIndex << sourceIndex.data() << size << d->m_pendingRemovals.size() << d->pendingRemovalRowCount(sourceIndex);
+//   }
+
+    return size;
+}
+
+bool KReparentingProxyModel::hasChildren(const QModelIndex &parent) const
+{
+    return rowCount(parent) > 0;
+}
+
+void KReparentingProxyModel::setSourceModel(QAbstractItemModel *sourceModel)
+{
+    Q_D(KReparentingProxyModel);
+
+    beginResetModel();
+
+    disconnect(sourceModel, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
+               this, SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
+    disconnect(sourceModel, SIGNAL(rowsInserted(QModelIndex,int,int)),
+               this, SLOT(sourceRowsInserted(QModelIndex,int,int)));
+    disconnect(sourceModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+               this, SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
+    disconnect(sourceModel, SIGNAL(rowsRemoved(QModelIndex,int,int)),
+               this, SLOT(sourceRowsRemoved(QModelIndex,int,int)));
+    disconnect(sourceModel, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
+               this, SLOT(sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
+    disconnect(sourceModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
+               this, SLOT(sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
+    disconnect(sourceModel, SIGNAL(modelAboutToBeReset()),
+               this, SLOT(sourceModelAboutToBeReset()));
+    disconnect(sourceModel, SIGNAL(modelReset()),
+               this, SLOT(sourceModelReset()));
+    disconnect(sourceModel, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
+               this, SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
+    disconnect(sourceModel, SIGNAL(layoutAboutToBeChanged()),
+               this, SLOT(sourceLayoutAboutToBeChanged()));
+    disconnect(sourceModel, SIGNAL(layoutChanged()),
+               this, SLOT(sourceLayoutChanged()));
+
+    QAbstractProxyModel::setSourceModel(sourceModel);
+
+//   qDebug() << "set";
+    QHash<QModelIndex, QModelIndexList> mappings = d->recreateMappings(QModelIndex(), 0, sourceModel->rowCount() - 1, KReparentingProxyModelPrivate::MapDescendants);
+//   qDebug() << "begin";
+    d->mergeDescendants(mappings, QModelIndex(), 0);
+
+    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
+            SLOT(sourceRowsAboutToBeInserted(QModelIndex,int,int)));
+    connect(sourceModel, SIGNAL(rowsInserted(QModelIndex,int,int)),
+            SLOT(sourceRowsInserted(QModelIndex,int,int)));
+    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+            SLOT(sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
+    connect(sourceModel, SIGNAL(rowsRemoved(QModelIndex,int,int)),
+            SLOT(sourceRowsRemoved(QModelIndex,int,int)));
+    connect(sourceModel, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
+            SLOT(sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
+    connect(sourceModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
+            SLOT(sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
+    connect(sourceModel, SIGNAL(modelAboutToBeReset()),
+            SLOT(sourceModelAboutToBeReset()));
+    connect(sourceModel, SIGNAL(modelReset()),
+            SLOT(sourceModelReset()));
+    connect(sourceModel, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
+            SLOT(sourceDataChanged(QModelIndex,QModelIndex)));
+    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()),
+            SLOT(sourceLayoutAboutToBeChanged()));
+    connect(sourceModel, SIGNAL(layoutChanged()),
+            SLOT(sourceLayoutChanged()));
+
+    endResetModel();
+}
+
+void KReparentingProxyModelPrivate::sourceRowsAboutToBeInserted(const QModelIndex &parent, int start, int end)
+{
+    Q_UNUSED(parent);
+    Q_UNUSED(start);
+    Q_UNUSED(end);
+
+    Q_Q(KReparentingProxyModel);
+    return q->beginResetModel();
+#if 0
+    // We can't figure out the structure until the indexes are in the model.
+    // Store the signal until the new rows are actually there in sourceRowsInserted.
+    PendingInsertion pendingInsertion(parent, start, end);
+    m_pendingInsertions.insert(parent, pendingInsertion);
+#endif
+}
+
+QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::mergeDescendants(QHash<QModelIndex, QModelIndexList> mappings, const QModelIndex &parent, int start)
+{
+    QModelIndexList childIndexes = mappings.take(parent);
+//   qDebug() << childIndexes;
+    if (!childIndexes.isEmpty()) {
+        if (!m_parents.values().contains(parent)) {
+            m_parents.insert(newId(), QPersistentModelIndex(parent));
+        }
+    }
+    int row = start;
+    Q_FOREACH (const QModelIndex &idx, childIndexes) {
+        m_childIndexes[parent].insert(row++, QPersistentModelIndex(idx));
+        mappings = mergeDescendants(mappings, idx, 0);
+    }
+    return mappings;
+}
+
+QHash<QModelIndex, QModelIndexList> KReparentingProxyModelPrivate::insertTree(QHash<QModelIndex, QModelIndexList>, const QModelIndex &)
+{
+    return QHash<QModelIndex, QModelIndexList>();
+
+}
+
+void KReparentingProxyModelPrivate::handleInsertion(const PendingInsertion &pendingInsertion)
+{
+    Q_Q(KReparentingProxyModel);
+    QModelIndex parent = pendingInsertion.index;
+    int start = pendingInsertion.start;
+    int end = pendingInsertion.end;
+
+//   qDebug() << parent << parent.data() << start << end;
+
+//   for (int i = start; i < end; ++i)
+//   {
+//     QModelIndex idx = q->sourceModel()->index(i, 0, parent);
+//     qDebug() << idx << idx.data();
+//   }
+
+    QHash<QModelIndex, QModelIndexList> newItemMappings = recreateMappings(parent, start, end, KReparentingProxyModelPrivate::MapDescendants);
+
+    // iterate over keys. if key in keys iterate up. This gives list of top level parents.
+    // Pick the one whoes parent is @p parent. Insert it. Look up until find the parent of another one and insert that.
+    // If one of the parents is invalid it is necessarily the last one to be processed (if there are more to process, they'll be children of it)
+    // That case should work too.
+
+//   qDebug() << "new item mappings" << newItemMappings;
+
+    const int column = 0;
+
+//   qDebug() << m_childIndexes.contains(parent);
+
+    if (newItemMappings.contains(parent)) {
+        QModelIndexList newItemList = newItemMappings.value(parent);
+//     qDebug() << "newItemList" << newItemList;
+        int proxyStart = 0;
+
+        // A single insertion in the source model might be multiple insertions in the proxy model.
+        Q_FOREVER {
+        if (newItemList.isEmpty())
+            {
+                if (!newItemMappings.contains(parent.parent())) {
+                    break;
+                }
+
+                newItemList = newItemMappings.value(parent.parent());
+                continue;
+            }
+
+            proxyStart = 0;
+
+            QModelIndex proxyParent = q->mapFromSource(parent);
+            if (start > 0)
+            {
+                QModelIndex lastDesc = q->mapFromSource(getLastDescendant(q->sourceModel()->index(start - 1, column, parent)));
+
+                while (lastDesc.parent() != proxyParent) {
+                    lastDesc = lastDesc.parent();
+                }
+                proxyStart = lastDesc.row() + 1;
+            }
+
+            q->beginInsertRows(proxyParent, proxyStart, proxyStart + newItemList.size() - 1);
+
+            newItemMappings = mergeDescendants(newItemMappings, parent, proxyStart);
+
+            q->endInsertRows();
+
+            if (!newItemMappings.contains(parent.parent()))
+            {
+                break;
+            }
+
+            newItemList = newItemMappings.value(parent.parent());
+        }
+    }
+
+//   // The rest are not descendants of pendingInsertion.index in the proxy model, but are elsewhere.
+//   Q_FOREACH(const QModelIndex &parent, newItemMappings.keys())
+//   {
+//
+//   }
+
+    return;
+}
+
+void KReparentingProxyModelPrivate::sourceRowsInserted(const QModelIndex &parent, int, int end)
+{
+    Q_UNUSED(parent);
+    Q_UNUSED(end);
+
+    return endResetProxy();
+
+#if 0
+    Q_Q(KReparentingProxyModel);
+    if (m_pendingInsertions.contains(parent)) {
+        PendingInsertion pendingInsertion = m_pendingInsertions.value(parent);
+        handleInsertion(pendingInsertion);
+
+        if (q->sourceModel()->rowCount(parent) <= (end + 1)) {
+            return;
+        }
+
+        // The presence of new rows might affect the structure of indexes below.
+        verifyStructure(parent, end + 1);
+    }
+#endif
+}
+
+void KReparentingProxyModelPrivate::removeTree(const QPersistentModelIndex &idxToRemove, int start, int end)
+{
+    if (!m_childIndexes.contains(idxToRemove)) {
+        return;
+    }
+
+//   qDebug() << "idxToRemove" << idxToRemove << start << end;
+
+    QList<QPersistentModelIndex> &toRemove = m_childIndexes[ idxToRemove ];
+//   qDebug() << toRemove << toRemove.size();
+
+//   QList<int> intList;
+//   intList << 1 << 2 << 3 << 4 << 5;
+//
+//   QList<int>::iterator intit = intList.begin();
+//   QList<int>::iterator intendIt = intList.end();
+//
+//   if (end == 0)
+//     intendIt = intit + 1;
+//
+//   if (end > 0)
+//   {
+//     intendIt = intit + (end - start + 1) + 1;
+//     qDebug() << "intend" << *intendIt;
+//   }
+//   intit += start;
+//
+//   while (intit != intendIt)
+//   {
+//     int i = *intit;
+//     qDebug() << i;
+//     intit = intList.erase(intit);
+//   }
+
+    QList<QPersistentModelIndex>::iterator it = toRemove.begin();
+    QList<QPersistentModelIndex>::iterator endIt = toRemove.end();
+
+    if (end == 0) {
+        endIt = it + 1;
+    }
+
+    if (end > 0) {
+        endIt = it + (end - start + 1) + 1;
+    }
+    it += start;
+
+    int i = start;
+    while (it != endIt) {
+        QPersistentModelIndex idx = *it;
+//     qDebug() << "removing" << idx << idx.data();
+
+        if (m_parents.values().contains(idx)) {
+            qint64 key = m_parents.key(idx);
+            QPersistentModelIndex value = m_parents.take(key);
+            m_pendingRemovalParents.insert(key, value);
+//       qDebug() << "take from parent" << value;
+        }
+        removeTree(idx);
+
+        ++i;
+
+        m_pendingRemovalChildIndexes[idxToRemove].append(idx);
+//     qDebug() << idxToRemove << idxToRemove.data() << idx << idx.data();
+
+        it = toRemove.erase(it);
+//     qDebug() << (it == endIt);
+//     if (i > end)
+//       break;
+
+//     if (it == toRemove.end())
+//       break;
+
+    }
+
+//   qDebug() << "toRemove" << toRemove;
+
+//   for(int i = start; (i <= end || (end == -1 && toRemove.size() > i)); )
+//   {
+//     qDebug() << i;
+//     QPersistentModelIndex idx = toRemove.takeAt(i);
+//     --end;
+//
+//     qDebug() << "removing" << idx.data();
+//
+//     if (m_parents.values().contains(idx))
+//     {
+//       QPersistentModelIndex bah = m_parents.take(m_parents.key(idx));
+// //       qDebug() << "take from parent" << bah;
+//     }
+//     removeTree(idx);
+//   }
+}
+
+void KReparentingProxyModelPrivate::sourceRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end)
+{
+    Q_UNUSED(parent);
+    Q_UNUSED(start);
+    Q_UNUSED(end);
+
+    Q_Q(KReparentingProxyModel);
+    q->beginResetModel();
+
+    return;
+#if 0
+//   qDebug() << parent << start << end;
+
+    // This is really tricky.
+    //
+    // We could have something like:
+    //
+    //   A              A
+    //   B              - B
+    //   C    ->        - - C
+    //   D              D
+    //   E              - E
+    //
+    // And have to remove something like B to D. That would mean a remove signal for B, move E to its grandparent, remove D.
+
+//   QHashIterator<QPersistentModelIndex, QList< QPersistentModelIndex> > it(m_childIndexes);
+//   while (it.hasNext())
+//   {
+//     it.next();
+//     qDebug() << it.key() << it.key().data();
+//     qDebug() << it.value();
+//   }
+
+    const int column = 0;
+
+    QModelIndex firstAffectedIndex = q->mapFromSource(q->sourceModel()->index(start, column, parent));
+    QModelIndex lastAffectedIndex = q->mapFromSource(q->sourceModel()->index(end, column, parent));
+
+//   qDebug() << "firstAffectedIndex" << firstAffectedIndex.data();
+//   qDebug() << "lastAffectedIndex" << lastAffectedIndex.data();
+
+    QModelIndex proxyParent = firstAffectedIndex.parent();
+
+    Q_ASSERT(firstAffectedIndex.isValid() && lastAffectedIndex.isValid());
+
+    Q_FOREVER {
+    if (isDescendantInModel(proxyParent, lastAffectedIndex))
+        {
+            // They share a common ancestor.
+
+            QModelIndex _parent = lastAffectedIndex.parent();
+            QModelIndex lastAffectedAncestor = lastAffectedIndex;
+//       qDebug() << "last affected ancestor" << lastAffectedAncestor.data();
+            while (_parent != proxyParent) {
+                lastAffectedAncestor = _parent;
+                _parent = _parent.parent();
+            }
+
+            if (q->hasChildren(lastAffectedAncestor)) {
+                QModelIndex next = q->index(0, 0, lastAffectedAncestor);
+
+                QModelIndex proxySourceParent = lastAffectedAncestor;
+                int startRow = next.row();
+                int lastRow = q->rowCount(lastAffectedAncestor) - 1;
+
+                QList<QPersistentModelIndex> &existingSourceIndexes = m_childIndexes[q->mapToSource(proxySourceParent)];
+                QList<QPersistentModelIndex> &existingDestinationIndexes = m_childIndexes[q->mapToSource(proxyParent)];
+
+                int destRow = lastAffectedAncestor.row() + 1;
+
+//         qDebug() << "Move from" << lastAffectedAncestor.data() << startRow << lastRow << " To " << proxyParent.data() << destRow;
+                bool allowMove = q->beginMoveRows(lastAffectedAncestor, startRow, lastRow, proxyParent, destRow);
+                Q_ASSERT(allowMove);
+
+                for (int i = startRow; i <= lastRow; ++i) {
+                    QPersistentModelIndex movingIdx = existingSourceIndexes.takeAt(startRow);
+                    existingDestinationIndexes.insert(destRow + (i - startRow), movingIdx);
+                }
+
+                // TODO: If source was a parent before, it might not be now.
+                // dest was already a parent.
+
+                q->endMoveRows();
+            }
+            PendingRemoval removal;
+            removal.index = proxyParent;
+            removal.start = firstAffectedIndex.row();
+            removal.end = lastAffectedAncestor.row();
+            removal.parentId = proxyParent.internalId();
+            removal.sourceIndex = q->mapToSource(proxyParent);
+            m_pendingRemovals.append(removal);
+
+            removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
+
+//       qDebug() << "beg rem 1";
+            q->beginRemoveRows(proxyParent, removal.start, removal.end);
+
+            return;
+
+        } else {
+            QModelIndex next = getIndexBelow(firstAffectedIndex);
+
+            proxyParent = next.parent();
+
+            while (isDescendantInModel(proxyParent, next))
+            {
+                next = getIndexBelow(next);
+            }
+            QModelIndex _parent = next.parent();
+            QModelIndex lastAffectedAncestor = next;
+
+            while (_parent != proxyParent)
+            {
+                lastAffectedAncestor = _parent;
+                _parent = _parent.parent();
+            }
+
+            PendingRemoval removal;
+            removal.index = proxyParent;
+            removal.start = firstAffectedIndex.row();
+            removal.end = lastAffectedAncestor.row();
+            removal.parentId = proxyParent.internalId();
+            removal.sourceIndex = q->mapToSource(proxyParent);
+            m_pendingRemovals.append(removal);
+
+            removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
+
+//       qDebug() << "beg rem 1";
+            q->beginRemoveRows(proxyParent, removal.start, removal.end);
+
+            proxyParent = next.parent();
+        }
+    }
+
+// //   qDebug() << proxyParent.data() << lastAffectedIndex.parent().data() << proxyParent << lastAffectedIndex.parent();
+//   if (proxyParent == lastAffectedIndex.parent())
+//   {
+//     PendingRemoval removal;
+//     removal.index = proxyParent;
+//     removal.start = firstAffectedIndex.row();
+//     removal.end = lastAffectedIndex.row();
+//     removal.parentId = proxyParent.internalId();
+//     removal.sourceIndex = q->mapToSource(proxyParent);
+//     m_pendingRemovals.append(removal);
+//
+//     // Also need to store a removal object for each of the descendants.
+//
+//     removeTree(q->mapToSource(proxyParent), removal.start, removal.end);
+//
+// //     qDebug() << "beg rem 1";
+//     q->beginRemoveRows(proxyParent, removal.start, removal.end);
+//     return;
+//   }
+//
+//   QModelIndex lastParent = lastAffectedIndex.parent();
+//   while (lastParent.parent().isValid())
+//   {
+//     if (lastParent.parent() == proxyParent)
+//     {
+//       PendingRemoval removal;
+//       removal.index = proxyParent;
+//       removal.start = firstAffectedIndex.row();
+//       removal.end = lastParent.row();
+//       removal.parentId = proxyParent.internalId();
+//       removal.sourceIndex = q->mapToSource(proxyParent);
+//       m_pendingRemovals.append(removal);
+//
+// //       qDebug() << "beg rem 2";
+//       q->beginRemoveRows(proxyParent, removal.start, removal.end);
+//       return;
+//     }
+//     lastParent = lastParent.parent();
+//   }
+//
+//   // Several blocks need to be removed from the proxy model.
+//   // Divide and conquer to find them.
+//
+//   int proxyStart = firstAffectedIndex.row();
+//   int proxyEnd = proxyStart + (end - start);
+//   int processedUntil = start;
+//
+//   while (processedUntil <= end)
+//   {
+//     QModelIndex lastInParent = findLastInParent(proxyParent, proxyStart, proxyEnd);
+//     qDebug() << "lastInParent" << lastInParent;
+//
+//     QModelIndex sourceLast = q->mapToSource(lastInParent);
+//     processedUntil = sourceLast.row();
+//
+//     PendingRemoval removal;
+//     removal.index = proxyParent;
+//     removal.start = proxyStart;
+//     removal.end = lastInParent.row();
+//     removal.parentId = proxyParent.internalId();
+//     removal.sourceIndex = q->mapToSource(proxyParent);
+//     m_pendingRemovals.append(removal);
+//
+//     qDebug() << "beg rem 3";
+//     q->beginRemoveRows(proxyParent, removal.start, removal.end);
+//
+//     QModelIndex proxyIndexBelow = getIndexBelow(lastInParent, q);
+//
+//     if (!proxyIndexBelow.isValid())
+//       return;
+//
+//     proxyParent = proxyIndexBelow.parent();
+//     proxyStart = proxyIndexBelow.row();
+//   }
+#endif
+}
+
+QModelIndex KReparentingProxyModelPrivate::findLastInParent(QModelIndex parent, int start, int end)
+{
+    Q_Q(KReparentingProxyModel);
+
+    const int column = 0;
+
+    if (start == end) {
+        return q->index(start, column, parent);
+    }
+
+    int middle = start + (end - start / 2);
+
+    QModelIndex sourceParent = q->mapToSource(parent);
+    QModelIndex middleIndex = q->mapFromSource(q->sourceModel()->index(middle, column, sourceParent));
+
+    if (middleIndex.parent() == parent) {
+        return findLastInParent(parent, middle, end);
+    } else {
+        return findLastInParent(parent, start + ((middle - start) / 2), middle);
+    }
+}
+
+//   qDebug() << affectedIndex << affectedIndex.data() << proxyParent;
+//
+//   QHash<QModelIndex, PendingRemoval> pendingRemovals;
+//
+//   int i = start;
+//   while (i <= end)
+//   {
+//     affectedIndex = affectedIndex.sibling(i, column);
+//
+// //     affectedIndex = getIndexBelow(affectedIndex, q);
+//     if (!affectedIndex.isValid())
+//       break;
+// //     Q_ASSERT(affectedIndex.isValid());
+//
+//     if (affectedIndex.parent() != proxyParent)
+//     {
+//       // affectedIndex.parent() must be left of proxyParent
+//
+//       PendingRemoval removal;
+//       removal.index = proxyParent;
+//       removal.start = start;
+//       removal.end = i;
+//       pendingRemovals.insert(proxyParent, removal);
+//
+//       emit q->rowsAboutToBeRemoved(proxyParent, start, i);
+//       proxyParent = affectedIndex.parent();
+//
+//       end -= (i - start + 1);
+//       start = affectedIndex.row();
+//       i = start;
+//     }
+//
+//     ++i;
+//   }
+
+// Move younger siblings out of the way so that the rows can be removed easily
+// No. It's easier to use verifyStructure afterward.
+
+//   // Removing rows in the source model could require sending the children to their grandparents.
+//
+//   QHash<QModelIndex, QModelIndexList> mappings;
+//   recreateMappings(parent, start, end);
+//
+//   QHashIterator<QModelIndex, QModelIndexList> it(mappings);
+//   while (it.hasNext())
+//   {
+//     it.next();
+//     QModelIndexList removedList = it.value();
+//     PendingRemoval pendingRemoval;
+//     pendingRemoval.index = it.key();
+//     pendingRemoval.start = q->mapFromSource(removedList.at(0)).row();
+//     pendingRemoval.end = pendingRemoval.start + removedList.size() - 1;
+//     m_pendingRemovals.insert(parent, pendingRemoval);
+//   }
+// }
+
+void KReparentingProxyModelPrivate::handleRemoval(const PendingRemoval &pendingRemoval)
+{
+  Q_UNUSED(pendingRemoval)
+//   Q_Q(KReparentingProxyModel);
+//   q->beginRemoveRows(pendingRemoval.index, pendingRemoval.start, pendingRemoval.end);
+//   m_childIndexes.remove(pendingRemoval.index);
+//   // Remove stuff from m_parents.
+//   q->endRemoveRows();
+}
+
+void KReparentingProxyModelPrivate::sourceRowsRemoved(const QModelIndex &parent, int, int)
+{
+    return endResetProxy();
+
+    Q_Q(KReparentingProxyModel);
+
+    // loop over pending removals and process each one. Then look after the last one
+    // to move displaced rows to where they should be.
+
+    int lastAffectedRow = m_pendingRemovals.last().end;
+    QModelIndex lastAffectedIndex = m_pendingRemovals.last().index;
+
+    QMutableVectorIterator<PendingRemoval> it(m_pendingRemovals);
+
+    while (it.hasNext()) {
+        PendingRemoval removal = it.next();
+        m_pendingRemovalChildIndexes.remove(removal.sourceIndex);
+        m_pendingRemovalParents.remove(parent.internalId());
+        it.remove();
+
+        emit q->endRemoveRows();
+    }
+//   qDebug() << "Remove done ##########";
+
+//   qDebug() << lastAffectedIndex << lastAffectedIndex.data() << lastAffectedRow;
+
+    verifyStructure(lastAffectedIndex, lastAffectedRow - 1);
+}
+
+void KReparentingProxyModelPrivate::sourceRowsAboutToBeMoved(const QModelIndex &parent, int start, int end, const QModelIndex &, int)
+{
+    // This could be several individual moves in the proxy model, or it could be no moves at all.
+    // We can get the top indexes of the moved list and move those.
+    // because their children won't be moved anywhere different.
+
+    // I could look at the indexes between start and end (proxied could be several blocks), and move them to dest.
+    // Then verify structure.
+    // This could lead to an illegal move.
+    // If we have
+    //
+    // Source:        Proxy:
+    // A              A
+    // B              B
+    // C              - C
+    // D              - D
+    // E              E
+    //
+    // then source can legally move B to between C and D, however, implemented naively the proxymodel would attempt an illegal move.
+    // We must first reparent everything below destRow in the proxy to the parent of parent in this case, then perform the move, then
+    // verifyStructure.
+    //
+    // Moving B C and D to below E would be a legal move in the proxy model.
+    //
+    // Children of moved indexes which are not themselves moved must be first sent to their grandparents.
+    // So if B and C were moved in the source model above to below E, D would first be moved to its grandparent, then B would be moved below E,
+    // then the structure would need to be verified.
+    //
+    // Proxy start state:     Intermediate state:   Intermediate or final state:   Possible alternative final state:
+    //       A                      A                     A                              A
+    //       B                      B                     E                              E
+    //       - C                    - C                   D                              - D
+    //       - D                    D                     B                              B
+    //       E                      E                     - C                            - C
+
+    // So, I could iterate from start to end in proxySourceParent and if the depth goes less than parent, emit a block move, then start again.
+
+    QHash<QModelIndex, QModelIndexList> newMappings = recreateMappings(parent, start, end);
+
+}
+
+void KReparentingProxyModelPrivate::sourceRowsMoved(const QModelIndex &, int, int, const QModelIndex &, int)
+{
+
+}
+
+void KReparentingProxyModelPrivate::sourceLayoutAboutToBeChanged()
+{
+    Q_Q(KReparentingProxyModel);
+
+    q->beginResetModel();
+    return;
+#if 0
+
+    emit q->layoutAboutToBeChanged();
+
+    Q_FOREACH (QPersistentModelIndex proxyPersistentIndex, q->persistentIndexList()) {
+        m_proxyIndexes << proxyPersistentIndex;
+        m_layoutChangePersistentIndexes << QPersistentModelIndex(q->mapToSource(proxyPersistentIndex));
+    }
+#endif
+}
+
+void KReparentingProxyModelPrivate::sourceLayoutChanged()
+{
+    endResetProxy();
+    return;
+#if 0
+    Q_Q(KReparentingProxyModel);
+
+    for (int i = 0; i < m_proxyIndexes.size(); ++i) {
+        q->changePersistentIndex(m_proxyIndexes.at(i), q->mapFromSource(m_layoutChangePersistentIndexes.at(i)));
+    }
+
+    m_layoutChangePersistentIndexes.clear();
+    m_proxyIndexes.clear();
+
+    emit q->layoutChanged();
+#endif
+}
+
+void KReparentingProxyModelPrivate::sourceModelAboutToBeReset()
+{
+    Q_Q(KReparentingProxyModel);
+    q->beginResetModel();
+}
+
+void KReparentingProxyModelPrivate::endResetProxy()
+{
+    Q_Q(KReparentingProxyModel);
+
+    m_parents.clear();
+    m_childIndexes.clear();
+    m_nextId = 0;
+    m_pendingInsertions.clear();
+    m_pendingRemovals.clear();
+    m_pendingRemovalChildIndexes.clear();
+    m_pendingRemovalParents.clear();
+//   qDebug() << q->sourceModel()->rowCount();
+    QHash<QModelIndex, QModelIndexList> mappings = recreateMappings(QModelIndex(), 0, q->sourceModel()->rowCount() - 1, KReparentingProxyModelPrivate::MapDescendants);
+    qDebug() << mappings;
+
+    mergeDescendants(mappings, QModelIndex(), 0);
+    q->endResetModel();
+}
+
+void KReparentingProxyModelPrivate::sourceModelReset()
+{
+    endResetProxy();
+}
+
+void KReparentingProxyModelPrivate::emitDataChangedSignals(const QModelIndex &startIndex, int maxChanged)
+{
+    Q_Q(KReparentingProxyModel);
+
+    QModelIndex proxyParent = startIndex.parent();
+
+    int numChanged = 1;
+
+    QModelIndex lastAffectedSibling = startIndex;
+    QModelIndex proxySibling = getIndexBelow(startIndex, q);
+
+    Q_FOREVER {
+    if (proxySibling.parent() != proxyParent || numChanged >= maxChanged)
+        {
+            break;
+        }
+
+        numChanged++;
+        lastAffectedSibling = proxySibling;
+
+        proxySibling = getIndexBelow(proxySibling);
+    }
+
+    emit q->dataChanged(startIndex, lastAffectedSibling);
+    if (numChanged < maxChanged) {
+        emitDataChangedSignals(proxySibling, maxChanged - numChanged);
+    }
+}
+
+void KReparentingProxyModelPrivate::sourceDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)
+{
+    Q_UNUSED(topLeft);
+    Q_UNUSED(bottomRight);
+
+    Q_Q(KReparentingProxyModel);
+
+    q->beginResetModel();
+    endResetProxy();
+    return;
+#if 0
+    QModelIndex parent = topLeft.parent();
+    const int start = topLeft.row();
+    const int end = bottomRight.row();
+    const int column = 0;
+    const int maxChanged = end - start + 1;
+
+    // Create mappings to the end because changing data can affect structure of siblings.
+    verifyStructure(parent, start);
+
+    // mapFromSource and emit signals.
+
+    QModelIndex proxyStartIndex = q->mapFromSource(q->sourceModel()->index(start, column, parent));
+
+    emitDataChangedSignals(proxyStartIndex, maxChanged);
+#endif
+}
+
+Qt::DropActions KReparentingProxyModel::supportedDropActions() const
+{
+    Q_ASSERT(sourceModel());
+    return sourceModel()->supportedDropActions();
+}
+
+void KReparentingProxyModel::beginChangeRule()
+{
+    Q_D(KReparentingProxyModel);
+    d->sourceModelAboutToBeReset();
+//   beginResetModel();
+//   d->m_childIndexes.clear();
+//   d->m_layoutChangePersistentIndexes.clear();
+//   d->m_nextId = 1;
+//   d->m_parents.clear();
+//   d->m_pendingInsertions.clear();
+//   d->m_pendingRemovalChildIndexes.clear();
+//   d->m_pendingRemovalParents.clear();
+//   d->m_pendingRemovals.clear();
+//   d->m_proxyIndexes.clear();
+}
+
+void KReparentingProxyModel::endChangeRule()
+{
+    Q_D(KReparentingProxyModel);
+    d->endResetProxy();
+    return;
+}
+
+#include "moc_kreparentingproxymodel.cpp"
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/kreparentingproxymodel.h kitemmodels-5.17.0/tests/proxymodeltestapp/kreparentingproxymodel.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/kreparentingproxymodel.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/kreparentingproxymodel.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,157 @@
+/*
+    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef KREPARENTINGPROXYMODEL_H
+#define KREPARENTINGPROXYMODEL_H
+
+#include <QAbstractProxyModel>
+
+class KReparentingProxyModelPrivate;
+
+/**
+  @brief Restructures a source model, changing the parents of items.
+
+  Subclasses can change the structure of a source model by reimplementing
+  the isDescendantOf method.
+
+  For example, if the source model is a list,
+
+  @verbatim
+  0
+  - A
+  - B
+  - C
+  - D
+  - E
+  @endverbatim
+
+  It could be converted to a tree by an implementation something like:
+
+  @code
+  bool MyReparentingModel::isDescedantOf(const QModelIndex& ancestor, const QModelIndex& descendant ) const
+  {
+     return (
+             (ancestor.data().toString() == "A" && descendant.data().toString() == "B")
+          || (ancestor.data().toString() == "A" && descendant.data().toString() == "C")
+          || (ancestor.data().toString() == "B" && descendant.data().toString() == "C")
+          || (ancestor.data().toString() == "A" && descendant.data().toString() == "D")
+          )
+    ? true : KReparentingProxyModel::isDescendantOf(ancestor, descendant);
+  }
+  @endcode
+
+  to get this result:
+
+  @verbatim
+  0
+  - A
+  - - B
+  - - - C
+  - - D
+  - E
+  @endverbatim
+
+  Note that the implementation returns true for a query if "C" is a descendant of "A".
+  The implementation must return the correct value for all of its descendants, not only its direct parent.
+  The actual location to insert the descendant in the tree is determined internally by a binary find algorithm.
+
+  The KReparentingProxyModel performs movement of items in the left-right directions, but not the up-down directions.
+
+  \image html reparenting1.png "KReparentingProxyModel moving rows left to right"
+
+  \image html reparenting2.png "KReparentingProxyModel can not move items both left-right and up-down"
+
+  Reordering the rows in a model is the domain of QSortFilterProxyModel. An intermediate QSortFilterProxyModel
+  can be used to achieve the desired result.
+
+  \image html reparenting3.png "KReparentingProxyModel and QSortFilterProxyModel working in concert to move items both left-right and up-down"
+
+  @code
+    QAbstractItemModel *model = getModel();
+
+    QSortFilterProxyModel *sorter = getSorter();
+    sorter->setSourceModel(model);
+
+    KReparentingProxyModel *reparenter = getReparenter();
+    reparenter->setSourceModel(sorter);
+
+    QTreeView *view = getView();
+    view->setModel(reparenter);
+  @endcode
+
+*/
+class KReparentingProxyModel : public QAbstractProxyModel
+{
+    Q_OBJECT
+public:
+    KReparentingProxyModel(QObject *parent = 0);
+
+    virtual ~KReparentingProxyModel();
+
+    virtual QModelIndex mapFromSource(const QModelIndex &sourceIndex) const;
+
+    virtual QModelIndex mapToSource(const QModelIndex &proxyIndex) const;
+
+    virtual void setSourceModel(QAbstractItemModel *sourceModel);
+
+    /**
+      Reimplement this to return whether @p descendant is a descendant of @p ancestor.
+    */
+    virtual bool isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const;
+
+    virtual int columnCount(const QModelIndex &parent = QModelIndex()) const;
+
+    virtual QVariant data(const QModelIndex &proxyIndex, int role = Qt::DisplayRole) const;
+
+    virtual QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
+
+    virtual QModelIndex parent(const QModelIndex &child) const;
+
+    virtual int rowCount(const QModelIndex &parent = QModelIndex()) const;
+
+    virtual bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
+
+    virtual Qt::DropActions supportedDropActions() const;
+
+protected:
+    void beginChangeRule();
+    void endChangeRule();
+
+private:
+    Q_DECLARE_PRIVATE(KReparentingProxyModel)
+    //@cond PRIVATE
+    KReparentingProxyModelPrivate *d_ptr;
+
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeInserted(const QModelIndex &, int, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsInserted(const QModelIndex &, int, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeRemoved(const QModelIndex &, int, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsRemoved(const QModelIndex &, int, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsAboutToBeMoved(const QModelIndex &, int, int, const QModelIndex &, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceRowsMoved(const QModelIndex &, int, int, const QModelIndex &, int))
+    Q_PRIVATE_SLOT(d_func(), void sourceModelAboutToBeReset())
+    Q_PRIVATE_SLOT(d_func(), void sourceModelReset())
+    Q_PRIVATE_SLOT(d_func(), void sourceLayoutAboutToBeChanged())
+    Q_PRIVATE_SLOT(d_func(), void sourceLayoutChanged())
+    Q_PRIVATE_SLOT(d_func(), void sourceDataChanged(const QModelIndex &, const QModelIndex &))
+
+    //@endcond
+
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/lessthanwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/lessthanwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/lessthanwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/lessthanwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,116 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "lessthanwidget.h"
+
+#include <QLabel>
+#include <QTreeView>
+#include <QVBoxLayout>
+
+ColoredTreeModel::ColoredTreeModel(QObject *parent)
+    : DynamicTreeModel(parent),
+      m_selectionModel(0),
+      m_lessThanColour(Qt::yellow),
+      m_greaterThanColour(Qt::red)
+{
+}
+
+void ColoredTreeModel::setSelectionModel(QItemSelectionModel *selectionModel)
+{
+    m_selectionModel = selectionModel;
+    connect(selectionModel, SIGNAL(selectionChanged(QItemSelection,QItemSelection)), SLOT(recolor()));
+}
+
+void ColoredTreeModel::recolor(const QModelIndex &parent)
+{
+    const QModelIndex topLeft = index(0, 0, parent);
+    const int _rowCount = rowCount(parent);
+    const QModelIndex bottomRight = index(_rowCount - 1, columnCount(parent) - 1, parent);
+    emit dataChanged(topLeft, bottomRight);
+
+    static const int column = 0;
+    QModelIndex idx;
+    for (int row = 0; row < _rowCount; ++row) {
+        idx = index(row, column, parent);
+        if (hasChildren(idx)) {
+            recolor(idx);
+        }
+    }
+}
+
+QVariant ColoredTreeModel::data(const QModelIndex &index, int role) const
+{
+    if (role != Qt::BackgroundRole || !m_selectionModel || m_selectionModel->selection().indexes().size() != 1) {
+        return DynamicTreeModel::data(index, role);
+    }
+
+    const QModelIndex selectedIndex = m_selectionModel->selection().indexes().first();
+
+    if (index == selectedIndex) {
+        return DynamicTreeModel::data(index, role);
+    }
+
+    if (index < selectedIndex) {
+        return m_lessThanColour;
+    }
+
+    Q_ASSERT(selectedIndex < index);
+
+    return m_greaterThanColour;
+}
+
+void LessThanWidget::insertGrid(QList<int> address)
+{
+    ModelInsertCommand *ins = new ModelInsertCommand(m_coloredTreeModel, this);
+    ins->setAncestorRowNumbers(address);
+    ins->setNumCols(5);
+    ins->setStartRow(0);
+    ins->setEndRow(5);
+    ins->doCommand();
+}
+
+LessThanWidget::LessThanWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QLabel *explanation = new QLabel(this);
+    explanation->setText(QString("The yellow items are 'less than' the selected item according to QModelIndex::operator<().\n"
+                         "The red items are greater than the selected item (i.e, not less than and not equal)."));
+
+    m_coloredTreeModel = new ColoredTreeModel(this);
+    QTreeView *treeView = new QTreeView(this);
+    treeView->setModel(m_coloredTreeModel);
+    treeView->setSelectionBehavior(QAbstractItemView::SelectItems);
+    treeView->setSelectionMode(QTreeView::SingleSelection);
+
+    m_coloredTreeModel->setSelectionModel(treeView->selectionModel());
+
+    QVBoxLayout *layout = new QVBoxLayout(this);
+    layout->addWidget(explanation);
+    layout->addWidget(treeView);
+
+    insertGrid(QList<int>());
+    insertGrid(QList<int>() << 2);
+    insertGrid(QList<int>() << 3);
+    insertGrid(QList<int>() << 4);
+    insertGrid(QList<int>() << 3 << 2);
+    insertGrid(QList<int>() << 3 << 3);
+    insertGrid(QList<int>() << 3 << 4);
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/lessthanwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/lessthanwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/lessthanwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/lessthanwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,60 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef LESSTHANWIDGET_H
+#define LESSTHANWIDGET_H
+
+#include <QWidget>
+#include <QItemSelectionModel>
+
+#include "dynamictreemodel.h"
+
+class ColoredTreeModel : public DynamicTreeModel
+{
+    Q_OBJECT
+public:
+    ColoredTreeModel(QObject *parent = 0);
+
+    /* reimp */ QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+
+    void setSelectionModel(QItemSelectionModel *selectionModel);
+
+protected Q_SLOTS:
+    void recolor(const QModelIndex &parent = QModelIndex());
+
+private:
+    QItemSelectionModel *m_selectionModel;
+    QColor m_lessThanColour;
+    QColor m_greaterThanColour;
+};
+
+class LessThanWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    LessThanWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+    void insertGrid(QList<int> address);
+private:
+    ColoredTreeModel *m_coloredTreeModel;
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/main.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/main.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/main.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/main.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2009 Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mainwindow.h"
+
+#include <qapplication.h>
+
+int main(int argc, char **argv)
+{
+    QApplication app(argc, argv);
+    MainWindow *mw = new MainWindow();
+    mw->show();
+    app.exec();
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/mainwindow.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/mainwindow.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/mainwindow.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/mainwindow.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,80 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mainwindow.h"
+
+#include <QSplitter>
+#include <QTabWidget>
+
+#include "dynamictreemodel.h"
+
+#include "breadcrumbswidget.h"
+#include "breadcrumbnavigationwidget.h"
+#include "breadcrumbdirectionwidget.h"
+#include "checkablewidget.h"
+#include "descendantpmwidget.h"
+#include "selectionpmwidget.h"
+// #include "statesaverwidget.h"
+#include "proxymodeltestwidget.h"
+#include "proxyitemselectionwidget.h"
+#ifdef QT_SCRIPT_LIB
+#include "reparentingpmwidget.h"
+#endif
+#include "recursivefilterpmwidget.h"
+#include "lessthanwidget.h"
+#include "matchcheckingwidget.h"
+#include "kidentityproxymodelwidget.h"
+#ifdef QT_QUICKWIDGETS_LIB
+#include "selectioninqmlwidget.h"
+#endif
+
+MainWindow::MainWindow() : QMainWindow()
+{
+
+    QTabWidget *tabWidget = new QTabWidget(this);
+
+    tabWidget->addTab(new MatchCheckingWidget(), QStringLiteral("Match Checking PM"));
+    tabWidget->addTab(new DescendantProxyModelWidget(), QStringLiteral("descendant PM"));
+    tabWidget->addTab(new SelectionProxyWidget(), QStringLiteral("selection PM"));
+#ifdef QT_QUICKWIDGETS_LIB
+    tabWidget->addTab(new SelectionInQmlWidget(), QStringLiteral("selection PM in QML"));
+#endif
+    tabWidget->addTab(new KIdentityProxyModelWidget(), QStringLiteral("Identity PM"));
+    tabWidget->addTab(new CheckableWidget(), QStringLiteral("Checkable"));
+    tabWidget->addTab(new BreadcrumbsWidget(), QStringLiteral("Breadcrumbs"));
+    tabWidget->addTab(new BreadcrumbNavigationWidget(), QStringLiteral("Breadcrumb Navigation"));
+    tabWidget->addTab(new BreadcrumbDirectionWidget(), QStringLiteral("Breadcrumb Direction"));
+    tabWidget->addTab(new ProxyItemSelectionWidget(), QStringLiteral("Proxy Item selection"));
+#ifdef QT_SCRIPT_LIB
+    tabWidget->addTab(new ReparentingProxyModelWidget(), QStringLiteral("reparenting PM"));
+#endif
+    tabWidget->addTab(new RecursiveFilterProxyWidget(), QStringLiteral("Recursive Filter"));
+    tabWidget->addTab(new LessThanWidget(), QStringLiteral("Less Than"));
+    tabWidget->addTab(new ProxyModelTestWidget(), QStringLiteral("Proxy Model Test"));
+//   tabWidget->addTab(new StateSaverWidget(), "State Saver Test");
+
+    setCentralWidget(tabWidget);
+}
+
+MainWindow::~MainWindow()
+{
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/mainwindow.h kitemmodels-5.17.0/tests/proxymodeltestapp/mainwindow.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/mainwindow.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/mainwindow.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,49 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef TESTAPPLICATION_H
+#define TESTAPPLICATION_H
+
+#include <QMainWindow>
+
+class DynamicTreeModel;
+
+//@cond PRIVATE
+
+/**
+ * @internal
+ * Test Application for proxy models.
+ */
+class MainWindow : public QMainWindow
+{
+    Q_OBJECT
+public:
+    MainWindow();
+    ~MainWindow();
+
+private:
+    DynamicTreeModel *m_rootModel;
+//   ContactsWidget* cw;
+};
+
+//@endcond
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/matchcheckingwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/matchcheckingwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/matchcheckingwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/matchcheckingwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,92 @@
+/*
+    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "matchcheckingwidget.h"
+
+#include <QVBoxLayout>
+#include <QLineEdit>
+#include <QSplitter>
+#include <QTreeView>
+#include <QRadioButton>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include <kselectionproxymodel.h>
+
+#include <QDebug>
+
+MatchCheckingWidget::MatchCheckingWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QVBoxLayout *layout = new QVBoxLayout(this);
+
+    m_lineEdit = new QLineEdit();
+
+    connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(matchChanged(QString)));
+
+    m_dynamicTreeRadioButton = new QRadioButton(QStringLiteral("Dynamic Tree Model"), this);
+    m_selectionModelRadioButton = new QRadioButton(QStringLiteral("Selection Model"), this);
+
+    layout->addWidget(m_lineEdit);
+    layout->addWidget(m_dynamicTreeRadioButton);
+    layout->addWidget(m_selectionModelRadioButton);
+
+    QSplitter *splitter = new QSplitter(this);
+    layout->addWidget(splitter);
+    DynamicTreeModel *dynamicTreeModel = new DynamicTreeModel(this);
+
+    m_dynamicTreeWidget = new DynamicTreeWidget(dynamicTreeModel, this);
+
+    splitter->addWidget(m_dynamicTreeWidget);
+
+    KSelectionProxyModel *selectionProxyModel = new KSelectionProxyModel(m_dynamicTreeWidget->treeView()->selectionModel(), this);
+    selectionProxyModel->setSourceModel(dynamicTreeModel);
+
+    m_selectionTreeView = new QTreeView(this);
+    m_selectionTreeView->setModel(selectionProxyModel);
+    splitter->addWidget(m_selectionTreeView);
+}
+
+void MatchCheckingWidget::matchChanged(const QString &matchData)
+{
+    bool ok;
+    int id = matchData.toInt(&ok);
+    qDebug() << matchData << id <<  DynamicTreeModel::DynamicTreeModelId;
+    if (!ok) {
+        return;
+    }
+
+    QModelIndexList list;
+    if (m_dynamicTreeRadioButton->isChecked()) {
+        m_dynamicTreeWidget->treeView()->selectionModel()->clearSelection();
+        list = m_dynamicTreeWidget->model()->match(m_dynamicTreeWidget->model()->index(0, 0), DynamicTreeModel::DynamicTreeModelId, id);
+        qDebug() << list;
+        Q_FOREACH (const QModelIndex &idx, list) {
+            m_dynamicTreeWidget->treeView()->selectionModel()->select(idx, QItemSelectionModel::SelectCurrent);
+        }
+    } else if (m_selectionModelRadioButton->isChecked()) {
+        m_selectionTreeView->selectionModel()->clearSelection();
+        list = m_selectionTreeView->model()->match(m_selectionTreeView->model()->index(0, 0), DynamicTreeModel::DynamicTreeModelId, id);
+        qDebug() << list;
+        Q_FOREACH (const QModelIndex &idx, list) {
+            m_selectionTreeView->selectionModel()->select(idx, QItemSelectionModel::SelectCurrent);
+        }
+    }
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/matchcheckingwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/matchcheckingwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/matchcheckingwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/matchcheckingwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,48 @@
+/*
+    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef MATCHCHECKINGWIDGET_H343434
+#define MATCHCHECKINGWIDGET_H343434
+
+#include <QWidget>
+
+class QTreeView;
+class QLineEdit;
+class QRadioButton;
+
+class DynamicTreeWidget;
+
+class MatchCheckingWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    MatchCheckingWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+private Q_SLOTS:
+    void matchChanged(const QString &matchData);
+
+private:
+    QLineEdit *m_lineEdit;
+    DynamicTreeWidget *m_dynamicTreeWidget;
+    QTreeView *m_selectionTreeView;
+    QRadioButton *m_dynamicTreeRadioButton;
+    QRadioButton *m_selectionModelRadioButton;
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/modelcommanderwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/modelcommanderwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/modelcommanderwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/modelcommanderwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,117 @@
+/*
+    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "modelcommanderwidget.h"
+
+#include <QTreeWidget>
+#include <QPushButton>
+#include <QVBoxLayout>
+
+#include "dynamictreemodel.h"
+#include "modelcommander.h"
+#include <QMetaMethod>
+
+ModelCommanderWidget::ModelCommanderWidget(DynamicTreeModel *dynamicTreeModel, QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f),
+      m_dynamicTreeModel(dynamicTreeModel),
+      m_modelCommander(new ModelCommander(m_dynamicTreeModel, this)),
+      m_treeWidget(new QTreeWidget),
+      m_executeButton(new QPushButton(QStringLiteral("Execute")))
+{
+    QVBoxLayout *layout = new QVBoxLayout(this);
+    layout->addWidget(m_treeWidget);
+    layout->addWidget(m_executeButton);
+
+    init();
+
+    connect(m_treeWidget, SIGNAL(currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)),
+            SLOT(currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)));
+
+    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(executeCurrentTest()));
+}
+
+void ModelCommanderWidget::init()
+{
+    const QMetaObject *mo = m_modelCommander->metaObject();
+    QMetaMethod mm;
+    for (int i = 0; i < mo->methodCount(); ++i) {
+        mm = mo->method(i);
+        QString signature = mm.methodSignature();
+        if (signature.startsWith(QLatin1String("init_")) && signature.endsWith(QLatin1String("(QString)"))) {
+            QTreeWidgetItem *testFunctionItem = new QTreeWidgetItem(m_treeWidget, QStringList() << signature.mid(5, signature.length() - 14));
+            m_treeWidget->addTopLevelItem(testFunctionItem);
+
+            QStringList testData;
+            QMetaObject::invokeMethod(m_modelCommander, QByteArray("execute_" + testFunctionItem->text(0).toLatin1()).constData(),
+                                      Q_RETURN_ARG(QStringList, testData),
+                                      Q_ARG(QString, QString()));
+
+            Q_FOREACH (const QString &testRun, testData) {
+              new QTreeWidgetItem(testFunctionItem, QStringList() << testRun);
+            }
+        }
+    }
+}
+
+void ModelCommanderWidget::currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous)
+{
+    Q_UNUSED(previous);
+    initTest(current);
+}
+
+void ModelCommanderWidget::executeCurrentTest()
+{
+    executeTest(m_treeWidget->currentItem());
+
+    disconnect(m_executeButton, SIGNAL(clicked(bool)), this, SLOT(executeCurrentTest()));
+    m_executeButton->setText(QStringLiteral("Reset"));
+    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(resetCurrentTest()));
+}
+
+void ModelCommanderWidget::resetCurrentTest()
+{
+    initTest(m_treeWidget->currentItem());
+
+    disconnect(m_executeButton, SIGNAL(clicked(bool)), this, SLOT(resetCurrentTest()));
+    m_executeButton->setText(QStringLiteral("Execute"));
+    connect(m_executeButton, SIGNAL(clicked(bool)), SLOT(executeCurrentTest()));
+}
+
+void ModelCommanderWidget::initTest(QTreeWidgetItem *item)
+{
+    if (!item->parent()) {
+        return;    // m_dynamicTreeModel->clear();
+    }
+    m_dynamicTreeModel->clear();
+    bool success = QMetaObject::invokeMethod(m_modelCommander, QByteArray("init_" + item->parent()->text(0).toLatin1()).constData(),
+                   Q_ARG(QString, item->text(0)));
+    Q_ASSERT(success);
+}
+
+void ModelCommanderWidget::executeTest(QTreeWidgetItem *item)
+{
+    if (!item->parent()) {
+        return;
+    }
+
+    bool success = QMetaObject::invokeMethod(m_modelCommander, QByteArray("execute_" + item->parent()->text(0).toLatin1()).constData(),
+                   Q_ARG(QString, item->text(0)));
+    Q_ASSERT(success);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/modelcommanderwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/modelcommanderwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/modelcommanderwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/modelcommanderwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+    Copyright (c) 2010 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef MODELCOMMANDERWIDGET_H
+#define MODELCOMMANDERWIDGET_H
+
+#include <QWidget>
+
+class QTreeWidget;
+class QTreeWidgetItem;
+class QPushButton;
+
+class DynamicTreeModel;
+class ModelCommander;
+
+class ModelCommanderWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    ModelCommanderWidget(DynamicTreeModel *dynamicTreeModel, QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+private Q_SLOTS:
+    void initTest(QTreeWidgetItem *item);
+    void executeTest(QTreeWidgetItem *item);
+    void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous);
+    void executeCurrentTest();
+    void resetCurrentTest();
+
+private:
+    void init();
+
+private:
+    DynamicTreeModel *m_dynamicTreeModel;
+    ModelCommander *m_modelCommander;
+    QTreeWidget *m_treeWidget;
+    QPushButton *m_executeButton;
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/proxyitemselectionwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/proxyitemselectionwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/proxyitemselectionwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/proxyitemselectionwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,104 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "proxyitemselectionwidget.h"
+
+#include <QSplitter>
+#include <QHBoxLayout>
+#include <QTreeView>
+#include <QSortFilterProxyModel>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include "klinkitemselectionmodel.h"
+
+#define SON(object) object->setObjectName(#object)
+
+ProxyItemSelectionWidget::ProxyItemSelectionWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QSplitter *splitter = new QSplitter(this);
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->addWidget(splitter);
+
+    DynamicTreeModel *rootModel = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(rootModel, splitter);
+
+    dynamicTreeWidget->setInitialTree(
+        QString("- 1"
+        "- 2"
+        "- - 3"
+        "- - - 4"
+        "- 5"
+        "- 6"
+        "- 7")
+    );
+
+    QSplitter *vSplitter = new QSplitter(Qt::Vertical, splitter);
+    QSplitter *hSplitter1 = new QSplitter(vSplitter);
+    QSplitter *hSplitter2 = new QSplitter(vSplitter);
+
+    QSortFilterProxyModel *proxy1 = new QSortFilterProxyModel(this);
+    SON(proxy1);
+    QSortFilterProxyModel *proxy2 = new QSortFilterProxyModel(this);
+    SON(proxy2);
+    QSortFilterProxyModel *proxy3 = new QSortFilterProxyModel(this);
+    SON(proxy3);
+    QSortFilterProxyModel *proxy4 = new QSortFilterProxyModel(this);
+    SON(proxy4);
+    QSortFilterProxyModel *proxy5 = new QSortFilterProxyModel(this);
+    SON(proxy5);
+
+    QTreeView *view1 = new QTreeView(hSplitter1);
+    QTreeView *view2 = new QTreeView(hSplitter1);
+    QTreeView *view3 = new QTreeView(hSplitter2);
+    QTreeView *view4 = new QTreeView(hSplitter2);
+
+    proxy1->setSourceModel(rootModel);
+    proxy2->setSourceModel(proxy1);
+    proxy3->setSourceModel(proxy2);
+
+    proxy4->setSourceModel(rootModel);
+    proxy5->setSourceModel(proxy4);
+
+    view1->setModel(proxy3);
+    view2->setModel(proxy5);
+    view3->setModel(proxy2);
+    view4->setModel(proxy1);
+
+    QItemSelectionModel *rootSelectionModel = dynamicTreeWidget->treeView()->selectionModel();
+
+    KLinkItemSelectionModel *view1SelectionModel = new KLinkItemSelectionModel(view1->model(), rootSelectionModel, this);
+    view1->setSelectionModel(view1SelectionModel);
+
+    KLinkItemSelectionModel *view2SelectionModel = new KLinkItemSelectionModel(view2->model(), view1->selectionModel(), this);
+    view2->setSelectionModel(view2SelectionModel);
+
+    KLinkItemSelectionModel *view3SelectionModel = new KLinkItemSelectionModel(view3->model(), view4->selectionModel(), this);
+    view3->setSelectionModel(view3SelectionModel);
+
+    view1->expandAll();
+    view2->expandAll();
+    view3->expandAll();
+    view4->expandAll();
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/proxyitemselectionwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/proxyitemselectionwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/proxyitemselectionwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/proxyitemselectionwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,36 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef PROXYITEMSELECTIONWIDGET_H
+#define PROXYITEMSELECTIONWIDGET_H
+
+#include <QWidget>
+
+class ProxyItemSelectionWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    ProxyItemSelectionWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/proxymodeltestwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/proxymodeltestwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/proxymodeltestwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/proxymodeltestwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,69 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "proxymodeltestwidget.h"
+
+#include <QSplitter>
+#include <QTreeView>
+#include <QHBoxLayout>
+#include <QPushButton>
+
+#include "modelcommander.h"
+#include "dynamictreemodel.h"
+#include "kselectionproxymodel.h"
+#if 0
+#include "kdescendantsproxymodel.h"
+#endif
+#include "modelcommanderwidget.h"
+
+ProxyModelTestWidget::ProxyModelTestWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QVBoxLayout *layout = new QVBoxLayout(this);
+    QSplitter *splitter = new QSplitter(this);
+
+    m_rootModel = new DynamicTreeModel(this);
+
+    (void) new ModelCommanderWidget(m_rootModel, splitter);
+
+    QTreeView *rootModelView = new QTreeView(splitter);
+    rootModelView->setModel(m_rootModel);
+    rootModelView->setSelectionMode(QTreeView::ExtendedSelection);
+
+    KSelectionProxyModel *selProxyModel = new KSelectionProxyModel(rootModelView->selectionModel(), this);
+    selProxyModel->setSourceModel(m_rootModel);
+    selProxyModel->setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
+
+    QTreeView *selModelView = new QTreeView(splitter);
+    selModelView->setModel(selProxyModel);
+
+#if 0
+    KDescendantsProxyModel *descProxyModel = new KDescendantsProxyModel(this);
+    descProxyModel->setSourceModel(m_rootModel);
+    QTreeView *descProxyModelView = new QTreeView(splitter);
+    descProxyModelView ->setModel(descProxyModel);
+#endif
+
+    // Your Proxy Here?
+
+    layout->addWidget(splitter);
+
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/proxymodeltestwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/proxymodeltestwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/proxymodeltestwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/proxymodeltestwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,42 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef PROXYMODELTESTWIDGET_H
+#define PROXYMODELTESTWIDGET_H
+
+#include <QWidget>
+
+class DynamicTreeModel;
+class ModelCommander;
+class QPushButton;
+
+class ProxyModelTestWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    explicit ProxyModelTestWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+private:
+    DynamicTreeModel *m_rootModel;
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/recursivefilterpmwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/recursivefilterpmwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/recursivefilterpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/recursivefilterpmwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,82 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "recursivefilterpmwidget.h"
+
+#include <QLineEdit>
+#include <QSplitter>
+#include <QTreeView>
+#include <QHBoxLayout>
+#include <QLabel>
+#include <QPlainTextEdit>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+
+RecursiveFilterProxyWidget::RecursiveFilterProxyWidget(QWidget *parent)
+    : QWidget(parent),
+      m_lineEdit(new QLineEdit(this)),
+      m_label(new QLabel(this))
+{
+    m_label->setText(QStringLiteral("Matching filter re: "));
+    m_lineEdit->setText(QStringLiteral("12|13|37|4"));
+
+    QHBoxLayout *hLayout = new QHBoxLayout();
+    QVBoxLayout *vLayout = new QVBoxLayout(this);
+    QSplitter *splitter = new QSplitter(this);
+
+    m_rootModel = new DynamicTreeModel(this);
+    m_recursive = new KRecursiveFilterProxyModel(this);
+    m_recursiveSubclass = new KRecursiveFilterProxyModelSubclass(this);
+
+    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(m_rootModel, splitter);
+
+    QTreeView *recursiveView = new QTreeView(splitter);
+    recursiveView->setModel(m_recursive);
+    QTreeView *recursiveSubclassView = new QTreeView(splitter);
+    recursiveSubclassView->setModel(m_recursiveSubclass);
+
+    hLayout->addWidget(m_label);
+    hLayout->addWidget(m_lineEdit);
+
+    vLayout->addLayout(hLayout);
+    vLayout->addWidget(splitter);
+
+    connect(m_lineEdit, SIGNAL(textChanged(QString)), SLOT(reset()));
+
+    connect(m_lineEdit, SIGNAL(textChanged(QString)), recursiveView, SLOT(expandAll()));
+    connect(m_lineEdit, SIGNAL(textChanged(QString)), recursiveSubclassView, SLOT(expandAll()));
+    connect(dynamicTreeWidget->textEdit(), SIGNAL(textChanged()), recursiveView, SLOT(expandAll()));
+    connect(dynamicTreeWidget->textEdit(), SIGNAL(textChanged()), recursiveSubclassView, SLOT(expandAll()));
+    connect(m_recursive, SIGNAL(modelReset()), recursiveView, SLOT(expandAll()), Qt::QueuedConnection);
+    connect(m_recursiveSubclass, SIGNAL(modelReset()), recursiveSubclassView, SLOT(expandAll()), Qt::QueuedConnection);
+
+    m_recursive->setSourceModel(m_rootModel);
+    m_recursiveSubclass->setSourceModel(m_rootModel);
+
+    reset();
+}
+
+void RecursiveFilterProxyWidget::reset()
+{
+    m_recursive->setFilterRegExp(m_lineEdit->text());
+    m_recursiveSubclass->setRegExp(QRegExp(m_lineEdit->text()));
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/recursivefilterpmwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/recursivefilterpmwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/recursivefilterpmwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/recursivefilterpmwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef RECURSIVE_PM_WIDGET_H
+#define RECURSIVE_PM_WIDGET_H
+
+#include <QWidget>
+#include <QRegExp>
+
+#include "krecursivefilterproxymodel.h"
+
+class QTreeView;
+class QLineEdit;
+class QLabel;
+class QPushButton;
+
+class DynamicTreeModel;
+
+class KRecursiveFilterProxyModelSubclass : public KRecursiveFilterProxyModel
+{
+    Q_OBJECT
+public:
+    KRecursiveFilterProxyModelSubclass(QObject *parent = 0)
+        : KRecursiveFilterProxyModel(parent)
+    {
+
+    }
+
+    /* reimp */ bool acceptRow(int sourceRow, const QModelIndex &parent_index) const
+    {
+        static const int column = 0;
+        QModelIndex srcIndex = sourceModel()->index(sourceRow, column, parent_index);
+        return srcIndex.data().toString().contains(m_regExp);
+    }
+
+    void setRegExp(const QRegExp &re)
+    {
+        layoutAboutToBeChanged();
+        m_regExp = re;
+        invalidateFilter();
+        layoutChanged();
+    }
+
+private:
+    QRegExp m_regExp;
+};
+
+class RecursiveFilterProxyWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    RecursiveFilterProxyWidget(QWidget *parent = 0);
+
+protected Q_SLOTS:
+    void reset();
+
+private:
+    DynamicTreeModel *m_rootModel;
+    KRecursiveFilterProxyModel *m_recursive;
+    KRecursiveFilterProxyModelSubclass *m_recursiveSubclass;
+
+    QLineEdit *m_lineEdit;
+    QLabel *m_label;
+};
+
+#endif
+
Binary files kitemmodels-5.16.0/tests/proxymodeltestapp/reparenting1.png and kitemmodels-5.17.0/tests/proxymodeltestapp/reparenting1.png differ
Binary files kitemmodels-5.16.0/tests/proxymodeltestapp/reparenting2.png and kitemmodels-5.17.0/tests/proxymodeltestapp/reparenting2.png differ
Binary files kitemmodels-5.16.0/tests/proxymodeltestapp/reparenting3.png and kitemmodels-5.17.0/tests/proxymodeltestapp/reparenting3.png differ
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/reparentingpmwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/reparentingpmwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/reparentingpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/reparentingpmwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,56 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "reparentingpmwidget.h"
+
+#include <QTreeView>
+#include <QSplitter>
+#include <QVBoxLayout>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include "scriptablereparentingwidget.h"
+
+ReparentingProxyModelWidget::ReparentingProxyModelWidget(QWidget *parent): QWidget(parent)
+{
+    QVBoxLayout *layout = new QVBoxLayout(this);
+
+    QSplitter *vSplitter = new QSplitter(this);
+    layout->addWidget(vSplitter);
+
+    m_rootModel = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(m_rootModel, vSplitter);
+    dynamicTreeWidget->setInitialTree(
+        QString("- 1"
+        "- 2"
+        "- - 3"
+        "- - - 4"
+        "- 5"
+        "- 6"
+        "- 7")
+    );
+
+    new ScriptableReparentingWidget(m_rootModel, vSplitter);
+
+    setLayout(layout);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/reparentingpmwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/reparentingpmwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/reparentingpmwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/reparentingpmwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,41 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef REPARENTINGPM_WIDGET_H
+#define REPARENTINGPM_WIDGET_H
+
+#include <QWidget>
+
+#include "kreparentingproxymodel.h"
+
+class DynamicTreeModel;
+
+class ReparentingProxyModelWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    ReparentingProxyModelWidget(QWidget *parent = 0);
+
+private:
+    DynamicTreeModel *m_rootModel;
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/scriptablereparentingwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/scriptablereparentingwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/scriptablereparentingwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/scriptablereparentingwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,143 @@
+/*
+    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "scriptablereparentingwidget.h"
+
+#include <QPlainTextEdit>
+#include <QTreeView>
+#include <QVBoxLayout>
+#include <QScriptEngine>
+
+#include <QDebug>
+#include <QLabel>
+#include <QSplitter>
+#include <QComboBox>
+
+static const char *const threadingFunctionNames[] = {
+    "None",
+    "Flat List",
+    "Straight Line Tree",
+    "Dragon Teeth 1",
+    "Dragon Teeth 2",
+    "Specified parents 1"
+};
+
+static const char *const threadingFunctionBodies[] = {
+    "",
+    "return false;",
+    "return true;",
+    "if (descendant % 3 ==1)\n"
+    "    return false;\n"
+    "return true;",
+    "if (descendant % 4 ==1)\n"
+    "    return false;\n"
+    "return true;",
+    "var threaddata = [[1, 2, 3, 4],\n"
+    "                  [13, 14, 15],\n"
+    "                  [13, 16, 17],\n"
+    "                  [5, 6]];\n"
+    "\n"
+    "for (var i = 0; i < threaddata.length; ++i)\n"
+    "{\n"
+    "  var a = threaddata[i].indexOf(ancestor);\n"
+    "  var d = threaddata[i].indexOf(descendant);\n"
+    "  if (a >= 0 && d >= 0)\n"
+    "    return a < d;\n"
+    "}\n"
+    "return false;"
+};
+
+ScriptableReparentingProxyModel::ScriptableReparentingProxyModel(QObject *parent)
+    : KReparentingProxyModel(parent),
+      m_scriptEngine(new QScriptEngine(this))
+{
+}
+
+bool ScriptableReparentingProxyModel::isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const
+{
+    if (!m_implementationFunction.isValid()) {
+        return KReparentingProxyModel::isDescendantOf(ancestor, descendant);
+    }
+
+    QScriptValueList arguments = QScriptValueList() << ancestor.data().toInt() << descendant.data().toInt();
+    QScriptValue returnValue = m_implementationFunction.call(QScriptValue(), arguments);
+
+    if (!returnValue.isBool()) {
+        return KReparentingProxyModel::isDescendantOf(ancestor, descendant);
+    }
+
+    return returnValue.toBool();
+}
+
+void ScriptableReparentingProxyModel::setImplementation(const QString &implementation)
+{
+    beginChangeRule();
+    m_implementationFunction = m_scriptEngine->evaluate(implementation);
+    m_implementationFunction = m_scriptEngine->globalObject().property(QStringLiteral("isDescendantOf"));
+    endChangeRule();
+}
+
+ScriptableReparentingWidget::ScriptableReparentingWidget(QAbstractItemModel *rootModel, QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f),
+      m_reparentingProxyModel(new ScriptableReparentingProxyModel(this))
+{
+    QVBoxLayout *mainLayout = new QVBoxLayout(this);
+    QSplitter *splitter = new QSplitter(Qt::Vertical, this);
+    mainLayout->addWidget(splitter);
+
+    m_treeView = new QTreeView(splitter);
+    QWidget *container = new QWidget(splitter);
+    QVBoxLayout *layout = new QVBoxLayout(container);
+    m_textEdit = new QPlainTextEdit(container);
+    m_textEdit->setFont(QFont(QStringLiteral("monospace")));
+
+    m_comboBox = new QComboBox(container);
+    for (int i = 0; i < int(sizeof threadingFunctionNames / sizeof * threadingFunctionNames); ++i) {
+        m_comboBox->addItem(*(threadingFunctionNames + i), *(threadingFunctionBodies + i));
+    }
+    layout->addWidget(m_comboBox);
+    connect(m_comboBox, SIGNAL(currentIndexChanged(int)), SLOT(setExampleFunction(int)));
+
+    layout->addWidget(new QLabel(QStringLiteral("function isDescendantOf (ancestor, descendant) {"), container));
+    QHBoxLayout *indentedLayout = new QHBoxLayout(container);
+    indentedLayout->addSpacing(30);
+    indentedLayout->addWidget(m_textEdit);
+    layout->addLayout(indentedLayout);
+    layout->addWidget(new QLabel(QStringLiteral("}"), container));
+
+    m_reparentingProxyModel->setSourceModel(rootModel);
+    m_treeView->setModel(m_reparentingProxyModel);
+
+    splitter->setStretchFactor(0, 100);
+
+    connect(m_textEdit, SIGNAL(textChanged()), SLOT(textChanged()));
+    textChanged();
+}
+
+void ScriptableReparentingWidget::setExampleFunction(int index)
+{
+    m_textEdit->setPlainText(m_comboBox->itemData(index).toString());
+}
+
+void ScriptableReparentingWidget::textChanged()
+{
+    m_reparentingProxyModel->setImplementation("function isDescendantOf (ancestor, descendant) { " + m_textEdit->toPlainText()  + " }");
+    m_treeView->expandAll();
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/scriptablereparentingwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/scriptablereparentingwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/scriptablereparentingwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/scriptablereparentingwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,65 @@
+/*
+    Copyright (c) 2009 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef SCRIPTABLEREPARENTINGWIDGET_H
+#define SCRIPTABLEREPARENTINGWIDGET_H
+
+#include <QWidget>
+#include <QScriptValue>
+
+#include "kreparentingproxymodel.h"
+
+class QComboBox;
+class QTreeView;
+class QPlainTextEdit;
+class QScriptEngine;
+
+class ScriptableReparentingProxyModel : public KReparentingProxyModel
+{
+    Q_OBJECT
+public:
+    ScriptableReparentingProxyModel(QObject *parent = 0);
+
+    /* reimp */ bool isDescendantOf(const QModelIndex &ancestor, const QModelIndex &descendant) const;
+
+    void setImplementation(const QString &implementation);
+
+private:
+    QScriptEngine *m_scriptEngine;
+    mutable QScriptValue m_implementationFunction;
+};
+
+class ScriptableReparentingWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    ScriptableReparentingWidget(QAbstractItemModel *rootModel, QWidget *parent = 0, Qt::WindowFlags f = 0);
+
+private Q_SLOTS:
+    void textChanged();
+    void setExampleFunction(int index);
+
+private:
+    QComboBox *m_comboBox;
+    ScriptableReparentingProxyModel *m_reparentingProxyModel;
+    QTreeView *m_treeView;
+    QPlainTextEdit *m_textEdit;
+};
+
+#endif // SCRIPTABLEREPARENTINGWIDGET_H
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/selectioninqmlwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/selectioninqmlwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/selectioninqmlwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/selectioninqmlwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,58 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2015 Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "selectioninqmlwidget.h"
+
+#include <QSplitter>
+#include <QTreeView>
+#include <QQuickWidget>
+#include <QHBoxLayout>
+#include <QLabel>
+#include <QtQml>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include "kselectionproxymodel.h"
+
+SelectionInQmlWidget::SelectionInQmlWidget(QWidget *parent): QWidget(parent)
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *splitter = new QSplitter(this);
+    layout->addWidget(splitter);
+
+    m_rootModel = new DynamicTreeModel(this);
+
+    new DynamicTreeWidget(m_rootModel, splitter);
+
+    QTreeView *selectionTree = new QTreeView(splitter);
+    selectionTree->setSelectionMode(QAbstractItemView::ExtendedSelection);
+    selectionTree->setModel(m_rootModel);
+    selectionTree->expandAll();
+
+    qmlRegisterType<KSelectionProxyModel>("KF5ItemModels", 1, 0, "SelectionProxyModel");
+
+    QQuickWidget *quickView = new QQuickWidget(splitter);
+
+    quickView->engine()->rootContext()->setContextProperty(QStringLiteral("_model"), m_rootModel);
+    quickView->engine()->rootContext()->setContextProperty(QStringLiteral("_selectionModel"), selectionTree->selectionModel());
+
+    quickView->setSource(QUrl::fromLocalFile(SRC_DIR "/selection.qml"));
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/selectioninqmlwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/selectioninqmlwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/selectioninqmlwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/selectioninqmlwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,40 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2015 Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef SELECTIONINQML_WIDGET_H
+#define SELECTIONINQML_WIDGET_H
+
+#include <QWidget>
+
+class QTreeView;
+
+class DynamicTreeModel;
+
+class SelectionInQmlWidget : public QWidget
+{
+public:
+    SelectionInQmlWidget(QWidget *parent = 0);
+
+private:
+    DynamicTreeModel *m_rootModel;
+};
+
+#endif
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/selectionpmwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/selectionpmwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/selectionpmwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/selectionpmwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,163 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "selectionpmwidget.h"
+
+#include <QSplitter>
+#include <QTreeView>
+#include <QHBoxLayout>
+#include <QLabel>
+
+#include "dynamictreemodel.h"
+#include "dynamictreewidget.h"
+#include "kselectionproxymodel.h"
+
+SelectionProxyWidget::SelectionProxyWidget(QWidget *parent): QWidget(parent)
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    QSplitter *splitter = new QSplitter(this);
+    layout->addWidget(splitter);
+
+    m_rootModel = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *dynTreeWidget = new DynamicTreeWidget(m_rootModel, splitter);
+
+    dynTreeWidget->setInitialTree(
+        QString("- 1"
+        "- 2"
+        "- - 3"
+        "- - 3"
+        "- - - 4"
+        "- - - 4"
+        "- - - - 4"
+        "- - 4"
+        "- - 5"
+        "- - - 4"
+        "- - - - 4"
+        "- - 5"
+        "- 6"
+        "- 7"
+        "- - 8"
+        "- - - 9"
+        "- - - 10"
+        "- - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - - - - 9"
+        "- - - - - - - - 10"
+        "- - - - - - - - 9"
+        "- - - - - - - 10"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 9"
+        "- - - - - 10"
+        "- - - - - - 9"
+        "- - - - - - 10"
+        "- - - - 10"
+        "- - 11"
+        "- - 12"
+        "- 13"
+        "- 14"
+        "- 15"
+        "- - 16"
+        "- - - 17"
+        "- - - 18"
+        "- 19"
+        "- 20"
+        "- 21"));
+
+    QTreeView *selectionTree = createLabelledView(QStringLiteral("Selection"), splitter);
+    selectionTree->setSelectionMode(QAbstractItemView::ExtendedSelection);
+    selectionTree->setModel(m_rootModel);
+    selectionTree->expandAll();
+
+#define SUBTREES
+#define SUBTREEROOTS
+#define SUBTREESWITHOUTROOTS
+#define EXACTSELECTION
+#define CHILDRENOFEXACTSELECTION
+
+#ifdef SUBTREES
+    KSelectionProxyModel *selectedBranchesModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
+    selectedBranchesModel->setSourceModel(m_rootModel);
+    selectedBranchesModel->setFilterBehavior(KSelectionProxyModel::SubTrees);
+
+    QTreeView *selectedBranchesView = createLabelledView(QStringLiteral("SubTrees"), splitter);
+    selectedBranchesView->setModel(selectedBranchesModel);
+#endif
+
+#ifdef SUBTREEROOTS
+    KSelectionProxyModel *selectedBranchesRootsModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
+    selectedBranchesRootsModel->setSourceModel(m_rootModel);
+    selectedBranchesRootsModel->setFilterBehavior(KSelectionProxyModel::SubTreeRoots);
+
+    QTreeView *selectedBranchesRootsView = createLabelledView(QStringLiteral("SubTreeRoots"), splitter);
+    selectedBranchesRootsView->setModel(selectedBranchesRootsModel);
+#endif
+
+#ifdef SUBTREESWITHOUTROOTS
+    KSelectionProxyModel *selectedBranchesChildrenModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
+    selectedBranchesChildrenModel->setSourceModel(m_rootModel);
+    selectedBranchesChildrenModel->setFilterBehavior(KSelectionProxyModel::SubTreesWithoutRoots);
+
+    QTreeView *selectedBranchesChildrenView = createLabelledView(QStringLiteral("SubTreesWithoutRoots"), splitter);
+    selectedBranchesChildrenView->setModel(selectedBranchesChildrenModel);
+#endif
+
+#ifdef EXACTSELECTION
+    KSelectionProxyModel *onlySelectedModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
+    onlySelectedModel->setSourceModel(m_rootModel);
+    onlySelectedModel->setFilterBehavior(KSelectionProxyModel::ExactSelection);
+
+    QTreeView *onlySelectedView = createLabelledView(QStringLiteral("ExactSelection"), splitter);
+    onlySelectedView->setModel(onlySelectedModel);
+#endif
+
+#ifdef CHILDRENOFEXACTSELECTION
+    KSelectionProxyModel *onlySelectedChildrenModel = new KSelectionProxyModel(selectionTree->selectionModel(), this);
+    onlySelectedChildrenModel->setSourceModel(m_rootModel);
+    onlySelectedChildrenModel->setFilterBehavior(KSelectionProxyModel::ChildrenOfExactSelection);
+
+    QTreeView *onlySelectedChildrenView = createLabelledView(QStringLiteral("ChildrenOfExactSelection"), splitter);
+    onlySelectedChildrenView->setModel(onlySelectedChildrenModel);
+#endif
+}
+
+QTreeView *SelectionProxyWidget::createLabelledView(const QString &labelText, QWidget *parent)
+{
+    QWidget *labelledTreeWidget = new QWidget(parent);
+    QVBoxLayout *layout = new QVBoxLayout(labelledTreeWidget);
+
+    QLabel *label = new QLabel(labelText, labelledTreeWidget);
+    QTreeView *treeview = new QTreeView(labelledTreeWidget);
+
+    layout->addWidget(label);
+    layout->addWidget(treeview);
+    return treeview;
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/selectionpmwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/selectionpmwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/selectionpmwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/selectionpmwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,45 @@
+/*
+ * This file is part of the proxy model test suite.
+ *
+ * Copyright 2009  Stephen Kelly <steveire@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#ifndef SELECTION_PM_WIDGET_H
+#define SELECTION_PM_WIDGET_H
+
+#include <QWidget>
+
+class QTreeView;
+
+class DynamicTreeModel;
+
+class SelectionProxyWidget : public QWidget
+{
+public:
+    SelectionProxyWidget(QWidget *parent = 0);
+
+protected:
+    QTreeView *createLabelledView(const QString &labelText, QWidget *parent);
+
+private:
+    DynamicTreeModel *m_rootModel;
+
+};
+
+#endif
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/selection.qml kitemmodels-5.17.0/tests/proxymodeltestapp/selection.qml
--- kitemmodels-5.16.0/tests/proxymodeltestapp/selection.qml	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/selection.qml	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,138 @@
+/*
+    Copyright (c) 2015 Stephen Kelly <steveire@gmail.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+import QtQuick 2.4
+
+import KF5ItemModels 1.0
+
+Item {
+  width: 600
+  height: 500
+
+  Component {
+    id: labelledSelectionView
+
+    Column {
+      id: column
+      width : 200
+      property var filterBehavior
+      property var filterBehaviorName
+      Text {
+        id: label
+        width: parent.width
+        horizontalAlignment: Text.AlignHCenter
+        font.bold: true
+        font.pointSize: 10
+        text: column.filterBehaviorName
+      }
+      SelectionProxyModel {
+        id: selection
+        sourceModel: _model
+        selectionModel: _selectionModel
+        filterBehavior: column.filterBehavior
+      }
+      Rectangle {
+        height: parent.height - label.height
+        width: parent.width
+        border.width : 1
+        border.color: "black"
+        radius: 5
+        ListView {
+          width: parent.width
+          height: parent.height
+          y: 5
+          x: 5
+          model: selection
+          delegate: Rectangle {
+            x: 1
+            y: 1
+            height: 30
+            width: 100
+            color: model.index % 2 == 0 ? "lightsteelblue" : "white"
+            Text {
+              x: 5
+              y: 5
+              text: model.display
+            }
+          }
+        }
+      }
+    }
+  }
+
+  Loader {
+    id: loaderExactSelection
+    width : 200
+    height: 300
+    sourceComponent: labelledSelectionView
+    Binding {
+      target: loaderExactSelection.item
+      property: "filterBehavior"
+      value: SelectionProxyModel.ExactSelection
+      when: loaderExactSelection.status == Loader.Ready
+    }
+    Binding {
+      target: loaderExactSelection.item
+      property: "filterBehaviorName"
+      value: "ExactSelection"
+      when: loaderExactSelection.status == Loader.Ready
+    }
+  }
+
+  Loader {
+    id: loaderChildrenOfExactSelection
+    x: 200
+    width : 200
+    height: 300
+    sourceComponent: labelledSelectionView
+    Binding {
+      target: loaderChildrenOfExactSelection.item
+      property: "filterBehavior"
+      value: SelectionProxyModel.ChildrenOfExactSelection
+      when: loaderChildrenOfExactSelection.status == Loader.Ready
+    }
+    Binding {
+      target: loaderChildrenOfExactSelection.item
+      property: "filterBehaviorName"
+      value: "ChildrenOfExactSelection"
+      when: loaderChildrenOfExactSelection.status == Loader.Ready
+    }
+  }
+
+  Loader {
+    id: loaderSubTreeRoots
+    x: 400
+    width : 200
+    height: 300
+    sourceComponent: labelledSelectionView
+    Binding {
+      target: loaderSubTreeRoots.item
+      property: "filterBehavior"
+      value: SelectionProxyModel.SubTreeRoots
+      when: loaderSubTreeRoots.status == Loader.Ready
+    }
+    Binding {
+      target: loaderSubTreeRoots.item
+      property: "filterBehaviorName"
+      value: "SubTreeRoots"
+      when: loaderSubTreeRoots.status == Loader.Ready
+    }
+  }
+
+}
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/statesaverwidget.cpp kitemmodels-5.17.0/tests/proxymodeltestapp/statesaverwidget.cpp
--- kitemmodels-5.16.0/tests/proxymodeltestapp/statesaverwidget.cpp	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/statesaverwidget.cpp	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,99 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#include "statesaverwidget.h"
+
+#include <QSplitter>
+#include <QBoxLayout>
+#include <QTreeView>
+#include <QApplication>
+
+#include <kconfig.h>
+#include <kconfiggroup.h>
+#include <ksharedconfig.h>
+
+#include "dynamictreewidget.h"
+#include "dynamictreemodel.h"
+
+QModelIndex DynamicTreeStateSaver::indexFromConfigString(const QAbstractItemModel *model, const QString &key) const
+{
+    QModelIndexList list = model->match(model->index(0, 0), DynamicTreeModel::DynamicTreeModelId, key.toInt(), 1, Qt::MatchRecursive);
+    if (list.isEmpty()) {
+        return QModelIndex();
+    }
+    return list.first();
+}
+
+QString DynamicTreeStateSaver::indexToConfigString(const QModelIndex &index) const
+{
+    return index.data(DynamicTreeModel::DynamicTreeModelId).toString();
+}
+
+DynamicTreeStateSaver::DynamicTreeStateSaver(QObject *parent)
+    : KViewStateSaver(parent)
+{
+}
+
+StateSaverWidget::StateSaverWidget(QWidget *parent, Qt::WindowFlags f)
+    : QWidget(parent, f)
+{
+    QSplitter *splitter = new QSplitter(this);
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->addWidget(splitter);
+
+    DynamicTreeModel *model = new DynamicTreeModel(this);
+
+    DynamicTreeWidget *dynamicTreeWidget = new DynamicTreeWidget(model, splitter);
+
+    m_view = new QTreeView(splitter);
+    m_view->setSelectionMode(QAbstractItemView::ExtendedSelection);
+    m_view->setModel(model);
+
+    connect(model, SIGNAL(modelAboutToBeReset()), SLOT(saveState()));
+    connect(model, SIGNAL(modelReset()), SLOT(restoreState()));
+    connect(qApp, SIGNAL(aboutToQuit()), SLOT(saveState()));
+
+    restoreState();
+}
+
+StateSaverWidget::~StateSaverWidget()
+{
+    saveState();
+}
+
+void StateSaverWidget::saveState()
+{
+    DynamicTreeStateSaver saver;
+    saver.setView(m_view);
+
+    KConfigGroup cfg(KSharedConfig::openConfig(), "ExampleViewState");
+    saver.saveState(cfg);
+    cfg.sync();
+}
+
+void StateSaverWidget::restoreState()
+{
+    DynamicTreeStateSaver *saver = new DynamicTreeStateSaver;
+    saver->setView(m_view);
+    KConfigGroup cfg(KSharedConfig::openConfig(), "ExampleViewState");
+    saver->restoreState(cfg);
+}
+
diff -Nur kitemmodels-5.16.0/tests/proxymodeltestapp/statesaverwidget.h kitemmodels-5.17.0/tests/proxymodeltestapp/statesaverwidget.h
--- kitemmodels-5.16.0/tests/proxymodeltestapp/statesaverwidget.h	1970-01-01 08:00:00.000000000 +0800
+++ kitemmodels-5.17.0/tests/proxymodeltestapp/statesaverwidget.h	2015-12-06 22:07:13.000000000 +0800
@@ -0,0 +1,60 @@
+/*
+    Copyright (C) 2010 Klarälvdalens Datakonsult AB,
+        a KDAB Group company, info@kdab.net,
+        author Stephen Kelly <stephen@kdab.com>
+
+    This library is free software; you can redistribute it and/or modify it
+    under the terms of the GNU Library General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or (at your
+    option) any later version.
+
+    This library is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+    License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to the
+    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301, USA.
+*/
+
+#ifndef STATESAVERWIDGET_H
+#define STATESAVERWIDGET_H
+
+#include <QWidget>
+
+#include "kviewstatesaver.h"
+
+class QTreeView;
+
+class DynamicTreeWidget;
+
+class DynamicTreeStateSaver : public KViewStateSaver
+{
+    Q_OBJECT
+public:
+    DynamicTreeStateSaver(QObject *parent = 0);
+
+protected:
+    /* reimp */ QModelIndex indexFromConfigString(const QAbstractItemModel *model, const QString &key) const;
+    /* reimp */ QString indexToConfigString(const QModelIndex &index) const;
+};
+
+class StateSaverWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    StateSaverWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);
+    ~StateSaverWidget();
+
+private Q_SLOTS:
+    void saveState();
+    void restoreState();
+
+private:
+    DynamicTreeWidget *m_dynamicTreeWidget;
+    QTreeView *m_view;
+};
+
+#endif
