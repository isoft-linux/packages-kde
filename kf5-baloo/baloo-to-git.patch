diff -Nur baloo-5.16.0/src/engine/CMakeLists.txt baloo/src/engine/CMakeLists.txt
--- baloo-5.16.0/src/engine/CMakeLists.txt	2015-11-08 20:08:54.000000000 +0800
+++ baloo/src/engine/CMakeLists.txt	2015-11-25 12:42:42.172156273 +0800
@@ -23,6 +23,7 @@
     vectorpositioninfoiterator.cpp
     writetransaction.cpp
     global.cpp
+    fsutils.cpp
 )
 
 add_library(KF5BalooEngine ${BALOO_ENGINE_SRCS})
diff -Nur baloo-5.16.0/src/engine/database.cpp baloo/src/engine/database.cpp
--- baloo-5.16.0/src/engine/database.cpp	2015-11-08 20:08:54.000000000 +0800
+++ baloo/src/engine/database.cpp	2015-11-25 12:42:42.172156273 +0800
@@ -38,6 +38,7 @@
 
 #include "writetransaction.h"
 #include "idutils.h"
+#include "fsutils.h"
 
 #include <QFile>
 #include <QFileInfo>
@@ -62,16 +63,30 @@
         return true;
     }
 
-    QFileInfo dirInfo(m_path);
-    if (!dirInfo.exists()) {
-        QDir().mkdir(m_path);
-        dirInfo.refresh();
+    QDir dir(m_path);
+    if (!dir.exists()) {
+        dir.mkpath(QStringLiteral("."));
+        dir.refresh();
     }
-    if (mode == CreateDatabase && !dirInfo.permission(QFile::WriteOwner)) {
-        qCritical() << m_path << "does not have write permissions. Aborting";
+    QFileInfo indexInfo(dir, QStringLiteral("index"));
+
+    if (mode == OpenDatabase && !indexInfo.exists()) {
         return false;
     }
 
+    if (mode == CreateDatabase) {
+        if (!QFileInfo(dir.absolutePath()).permission(QFile::WriteOwner)) {
+            qCritical() << m_path << "does not have write permissions. Aborting";
+            return false;
+        }
+
+        if (!indexInfo.exists()) {
+            if (FSUtils::getDirectoryFileSystem(m_path) == QStringLiteral("btrfs")) {
+                FSUtils::disableCoW(m_path);
+            }
+        }
+    }
+
     int rc = mdb_env_create(&m_env);
     if (rc) {
         m_env = 0;
@@ -82,7 +97,7 @@
     mdb_env_set_mapsize(m_env, static_cast<size_t>(1024) * 1024 * 1024 * 5); // 5 gb
 
     // The directory needs to be created before opening the environment
-    QByteArray arr = QFile::encodeName(m_path) + "/index";
+    QByteArray arr = QFile::encodeName(indexInfo.absoluteFilePath());
     rc = mdb_env_open(m_env, arr.constData(), MDB_NOSUBDIR | MDB_NOMEMINIT, 0664);
     if (rc) {
         m_env = 0;
@@ -91,6 +106,10 @@
 
     rc = mdb_reader_check(m_env, 0);
     Q_ASSERT_X(rc == 0, "Database::open reader_check", mdb_strerror(rc));
+    if (rc) {
+        mdb_env_close(m_env);
+        return false;
+    }
 
     //
     // Individual Databases
@@ -99,6 +118,13 @@
     if (mode == OpenDatabase) {
         int rc = mdb_txn_begin(m_env, NULL, MDB_RDONLY, &txn);
         Q_ASSERT_X(rc == 0, "Database::transaction ro begin", mdb_strerror(rc));
+        if (rc) {
+            mdb_txn_abort(txn);
+            mdb_env_close(m_env);
+            m_env = 0;
+            return false;
+        }
+
         m_dbis.postingDbi = PostingDB::open(txn);
         m_dbis.positionDBi = PositionDB::open(txn);
 
@@ -117,17 +143,31 @@
 
         m_dbis.mtimeDbi = MTimeDB::open(txn);
 
+        Q_ASSERT(m_dbis.isValid());
         if (!m_dbis.isValid()) {
             mdb_txn_abort(txn);
+            mdb_env_close(m_env);
             m_env = 0;
             return false;
         }
+
         rc = mdb_txn_commit(txn);
         Q_ASSERT_X(rc == 0, "Database::transaction ro commit", mdb_strerror(rc));
-    }
-    else {
+        if (rc) {
+            mdb_env_close(m_env);
+            m_env = 0;
+            return false;
+        }
+    } else {
         int rc = mdb_txn_begin(m_env, NULL, 0, &txn);
         Q_ASSERT_X(rc == 0, "Database::transaction begin", mdb_strerror(rc));
+        if (rc) {
+            mdb_txn_abort(txn);
+            mdb_env_close(m_env);
+            m_env = 0;
+            return false;
+        }
+
         m_dbis.postingDbi = PostingDB::create(txn);
         m_dbis.positionDBi = PositionDB::create(txn);
 
@@ -149,11 +189,18 @@
         Q_ASSERT(m_dbis.isValid());
         if (!m_dbis.isValid()) {
             mdb_txn_abort(txn);
+            mdb_env_close(m_env);
             m_env = 0;
             return false;
         }
+
         rc = mdb_txn_commit(txn);
         Q_ASSERT_X(rc == 0, "Database::transaction commit", mdb_strerror(rc));
+        if (rc) {
+            mdb_env_close(m_env);
+            m_env = 0;
+            return false;
+        }
     }
 
     return true;
diff -Nur baloo-5.16.0/src/engine/fsutils.cpp baloo/src/engine/fsutils.cpp
--- baloo-5.16.0/src/engine/fsutils.cpp	1970-01-01 08:00:00.000000000 +0800
+++ baloo/src/engine/fsutils.cpp	2015-11-25 12:42:42.175156273 +0800
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2010 Tobias Koenig <tokoe@kde.org>
+ * Copyright (C) 2014 Daniel Vr√°til <dvratil@redhat.com>
+ * Copyright (C) 2015 Vishesh Handa <vhanda@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "fsutils.h"
+
+#include <QDebug>
+
+#ifdef Q_OS_LINUX
+#include <unistd.h>
+#include <mntent.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#endif
+
+using namespace Baloo;
+
+QString FSUtils::getDirectoryFileSystem(const QString &directory)
+{
+#ifndef Q_OS_LINUX
+    return QString();
+#else
+    QString bestMatchPath;
+    QString bestMatchFS;
+
+    FILE *mtab = setmntent("/etc/mtab", "r");
+    if (!mtab) {
+        return QString();
+    }
+    while (mntent *mnt = getmntent(mtab)) {
+        if (qstrcmp(mnt->mnt_type, MNTTYPE_IGNORE) == 0) {
+            continue;
+        }
+
+        const QString dir = QString::fromLocal8Bit(mnt->mnt_dir);
+        if (!directory.startsWith(dir) || dir.length() < bestMatchPath.length()) {
+            continue;
+        }
+
+        bestMatchPath = dir;
+        bestMatchFS = QString::fromLocal8Bit(mnt->mnt_type);
+    }
+
+    endmntent(mtab);
+
+    return bestMatchFS;
+#endif
+}
+
+void FSUtils::disableCoW(const QString &path)
+{
+#ifndef Q_OS_LINUX
+    Q_UNUSED(path);
+#else
+    // from linux/fs.h, so that Baloo does not depend on Linux header files
+#ifndef FS_IOC_GETFLAGS
+#define FS_IOC_GETFLAGS     _IOR('f', 1, long)
+#endif
+#ifndef FS_IOC_SETFLAGS
+#define FS_IOC_SETFLAGS     _IOW('f', 2, long)
+#endif
+
+    // Disable COW on file
+#ifndef FS_NOCOW_FL
+#define FS_NOCOW_FL         0x00800000
+#endif
+
+    ulong flags = 0;
+    const int fd = open(qPrintable(path), O_RDONLY);
+    if (fd == -1) {
+        qWarning() << "Failed to open" << path << "to modify flags (" << errno << ")";
+        return;
+    }
+
+    if (ioctl(fd, FS_IOC_GETFLAGS, &flags) == -1) {
+        qWarning() << "ioctl error: failed to get file flags (" << errno << ")";
+        close(fd);
+        return;
+    }
+    if (!(flags & FS_NOCOW_FL)) {
+        flags |= FS_NOCOW_FL;
+        if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == -1) {
+            qWarning() << "ioctl error: failed to set file flags (" << errno << ")";
+            close(fd);
+            return;
+        }
+    }
+    close(fd);
+#endif
+}
diff -Nur baloo-5.16.0/src/engine/fsutils.h baloo/src/engine/fsutils.h
--- baloo-5.16.0/src/engine/fsutils.h	1970-01-01 08:00:00.000000000 +0800
+++ baloo/src/engine/fsutils.h	2015-11-25 12:42:42.175156273 +0800
@@ -0,0 +1,51 @@
+/*
+ * This file is part of the KDE Baloo Project
+ * Copyright (C) 2015  Vishesh Handa <me@vhanda.in>
+ * Copyright (C) 2010  Tobias Koenig <tokoe@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) version 3, or any
+ * later version accepted by the membership of KDE e.V. (or its
+ * successor approved by the membership of KDE e.V.), which shall
+ * act as a proxy defined in Section 6 of version 3 of the license.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef BALOO_ENGINE_FSUTILS_H
+#define BALOO_ENGINE_FSUTILS_H
+
+#include <QString>
+
+namespace Baloo {
+namespace FSUtils {
+
+/**
+ * Returns name of filesystem that @p directory is stored on. This
+ * only works on Linux and returns empty string on other platforms or when it's
+ * unable to detect the filesystem.
+ */
+QString getDirectoryFileSystem(const QString &directory);
+
+/**
+ * Disables filesystem copy-on-write feature on given file or directory.
+ * Only works on Linux and does nothing on other platforms.
+ *
+ * It was tested only with Btrfs but in theory can be called on any FS that
+ * supports NOCOW.
+ */
+void disableCoW(const QString &path);
+
+}
+
+}
+#endif
